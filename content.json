{"meta":{"title":"上帝之手-Work makes the workman","subtitle":"Work makes the workman","description":"A blog website for writting articles by Leo","author":"Leo","url":"https://okfood.vip/blog"},"pages":[{"title":"","date":"2019-09-04T06:20:07.211Z","updated":"2019-09-03T07:38:56.940Z","comments":false,"path":"categories/index.html","permalink":"https://okfood.vip/blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-04T06:18:37.000Z","updated":"2019-09-04T06:18:38.000Z","comments":true,"path":"tags/index.html","permalink":"https://okfood.vip/blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.537Z","updated":"2019-09-03T09:54:07.684Z","comments":false,"path":"categories/Java/index.html","permalink":"https://okfood.vip/blog/categories/Java/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.534Z","updated":"2019-09-03T09:53:54.389Z","comments":false,"path":"categories/Android/index.html","permalink":"https://okfood.vip/blog/categories/Android/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.522Z","updated":"2019-09-03T09:55:45.604Z","comments":false,"path":"categories/工具/index.html","permalink":"https://okfood.vip/blog/categories/工具/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T08:39:44.229Z","updated":"2019-09-04T08:39:44.229Z","comments":false,"path":"categories/算法/index.html","permalink":"https://okfood.vip/blog/categories/算法/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.529Z","updated":"2019-09-03T09:56:01.802Z","comments":false,"path":"categories/后端/index.html","permalink":"https://okfood.vip/blog/categories/后端/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T08:39:54.677Z","updated":"2019-09-04T08:39:54.677Z","comments":false,"path":"categories/前端/index.html","permalink":"https://okfood.vip/blog/categories/前端/index.html","excerpt":"","text":""}],"posts":[{"title":"kotlin大法：协程它不香吗(网络交互篇)","slug":"kotlin大法：协程它不香吗(网络交互篇)","date":"2019-09-30T06:44:41.000Z","updated":"2019-09-30T06:48:48.817Z","comments":true,"path":"2019/09/30/kotlin大法：协程它不香吗(网络交互篇)/","link":"","permalink":"https://okfood.vip/blog/2019/09/30/kotlin大法：协程它不香吗(网络交互篇)/","excerpt":"","text":"andriod项目中网络请求使用kotlin和Retrofit的最优雅方式，抛弃Callback，抛弃RxJava，接受协程吧 源码传送门: android-kotlin-retrofit-wrap 网上一大堆都是Retrofit+Rxjava或者使用回调方式，其实使用协程才是真的简单好用 android项目现在基本都是用kotlin开发，而kotlin的优势显而易见，其中的协程也是一大利器 网络交互一般使用okhttp+Retrofit，而在okhttp4.0+已经使用了kotlin作为维护语言，Retrofit在2.6.0版本也开始支持了挂起（suspend）修饰符，这使得android项目中使用kotlin个retrofi进行网络交互尤为方便 该项目内容为kotlin协程配合Retrofit实现网络请求的一个示例 Step0: android项目中加入kotlin及其协程的支持 项目根目录build.gradle文件中加入： buildscript { ext.kotlin_version = &#39;1.3.50&#39; ext.kotlin_coroutines = &#39;1.3.2&#39; ... dependencies { classpath &#39;com.android.tools.build:gradle:3.5.0&#39; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; ... } } app目录下的build.gradle中加入支持并添加依赖： apply plugin: &#39;kotlin-android&#39; apply plugin: &#39;kotlin-android-extensions&#39; dependencies { implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot; implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlin_coroutines&quot; implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutines&quot; implementation &#39;androidx.core:core-ktx:1.1.0&#39; implementation &#39;androidx.appcompat:appcompat:1.1.0&#39; implementation &#39;com.squareup.retrofit2:retrofit:2.6.2&#39; implementation &quot;com.squareup.okhttp3:okhttp:4.2.0&quot; implementation &quot;com.squareup.okhttp3:logging-interceptor:4.2.0&quot; ... } Step1: 对Retrofit的简单封装 详见RetrofitWrap.kt/** * 是否开启打印日志，默认关闭 */ fun init(baseUrl: String, debugEnable: Boolean = false) { instance.retrofit = Retrofit.Builder().apply { baseUrl(baseUrl) client(okhttpClient(debugEnable)) addConverterFactory(StringConverterFactory.create()) }.build() } /** * 获取API服务 */ fun &lt;T&gt; service(service: Class&lt;T&gt;): T { if (instance.retrofit != null) { return instance.retrofit!!.create(service) } else { throw IllegalStateException(&quot;请先调用RetrofitWrap.init()方法进行初始化&quot;) } }就两个对外方法： init：初始化，配置baseUrl和是否打印日志，其他参数可以基于源码修改加入 service：获取服务实例，传入定义api的接口类，然后调用对应方法即可完成数据请求 Step2: 根据业务定义网络交互方法，例如API.ktinterface API { @GET(&quot;test.json&quot;) suspend fun info(): String }使用Example,详见TestActivity.kt 完整示例： class TestActivity : AppCompatActivity(), CoroutineScope by MainScope() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) RetrofitWrap.init(&quot;https://okfood.vip/&quot;, false) btn.setOnClickListener { content.text = &quot;加载中...&quot; launch { val data = withContext(Dispatchers.IO) { RetrofitWrap.service(API::class.java).info() } content.text = if (TextUtils.isEmpty(data)) &quot;error&quot; else data } } } override fun onDestroy() { super.onDestroy() cancel() } } 说明 初始化RetrofitWrap.init需要放置在第一次请求网络之前，可以是application中 不建议使用GlobalScope去launch一个协程任务，android中便于生命周期的管理提供了MainScope，在页面销毁处调用cancel()避免内存泄露 闲外话 该项目内容仅是一种极简使用方式的展示，具体项目中，可以根据项目架构做对应调整，比如加上使用ViewModel以及LiveData等 同理，实现方式也可以用于数据库的操作，毕竟网络和数据库都是android数据存储的方式","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://okfood.vip/blog/tags/kotlin/"},{"name":"协程","slug":"协程","permalink":"https://okfood.vip/blog/tags/协程/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"基于无障碍服务的微信抢红包神器","slug":"基于无障碍服务的微信抢红包神器","date":"2019-09-07T07:12:27.000Z","updated":"2019-09-09T08:57:34.280Z","comments":true,"path":"2019/09/07/基于无障碍服务的微信抢红包神器/","link":"","permalink":"https://okfood.vip/blog/2019/09/07/基于无障碍服务的微信抢红包神器/","excerpt":"","text":"背景 抢红包一直都是一个存在的话题，过年过节凑个热闹，发个红包到家人群同事群热闹热闹，很多时候呢，在红包数量少的时候，都是无缘于红包（只怪别人手速太快），所以，在这个人工智能（人工智障）的时代，能让程序自动化帮你操作，岂不是美滋滋。 目前，抢红包插件有两种实现方式（目前能用的），法1：基于xposed去hook微信红包消息方法名，；法2：利用无障碍服务实现模拟点击操作，当然也可以两者结合使用。 目前android手机对权限的管理越来越严，安全性也提高了，xposed的使用越来越不便利，也可以用一些三方黑科技比如VirtualXposed、太极等等，速度很快，缺点是容易封号。而无障碍服务呢，是android系统面向具有视听障碍人士设计的一个辅助功能，应用所感知到的模拟点击也会被认为是人为操作，所以不存在封号的情况（速度太快另计）。所以本文介绍使用无障碍服务实现一个简单的微信抢红包插件，功能简单，有兴趣的可以基于此优化。 需求设计一个插件，开启后，在任何一个微信群里面停留，当有红包消息出现时，自动快速点击拆开红包。 流程图（装逼惯例） 上代码1.页面UI 像这样简单就可以了，有个开关，控制下是否自动抢即可。UI功能完成三件事： 引导开启无障碍服务开关 控制自动化抢红包开关 检查当前手机微信版本是否更新了，更新了就引导提示升级红包插件 部分源码如下： //引导开启无障碍服务开关 private void alertOpenService() { new AlertDialog.Builder(this) .setTitle(R.string.app_name) .setCancelable(false) .setMessage(&quot;请开启&quot;+getString(R.string.app_name)+&quot;描辅助功能&quot;) .setPositiveButton(&quot;去开启&quot;, (dialog, which) -&gt; { dialog.cancel(); Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); Util.postDelayed(() -&gt; Util.toast(MainActivity.this, &quot;请打开: 无障碍中&quot;+getString(R.string.app_name)+&quot;服务开关&quot;), 1000); }) .create().show(); } //校验适配微信版本 String wxVersionName = Util.getVersionName(getApplicationContext(), &quot;com.tencent.mm&quot;); int wxVer = Integer.valueOf(wxVersionName.replace(&quot;.&quot;, &quot;&quot;)); if(wxVer &gt; Integer.valueOf(Configs.WX_VERSION.replace(&quot;.&quot;, &quot;&quot;))) { new AlertDialog.Builder(this) .setTitle(R.string.app_name) .setCancelable(false) .setMessage(&quot;当前手机安装的微信版本不适用，可能无法正常工作，请安装不高于&quot;+Configs.WX_VERSION+&quot;版本微信，或者联系开发者进行工具升级\\n\\n&quot; +&quot;查看微信版本号：\\n微信-&gt;我-&gt;设置-&gt;关于微信-&gt;查看Version&quot;) .setPositiveButton(&quot;我知道了&quot;, (dialog, which) -&gt; dialog.cancel()) .create().show(); }2.添加无障碍服务功能 定义类AccServiceWX继承AccessibilityService，主页复写onAccessibilityEvent方法。 res目录下新建xml目录，里面新增文件accessibility_service_info.xml，内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:accessibilityEventTypes=&quot;typeAllMask&quot; android:accessibilityFeedbackType=&quot;feedbackGeneric&quot; android:accessibilityFlags=&quot;flagReportViewIds|flagDefault|flagEnableAccessibilityVolume|flagIncludeNotImportantViews|flagRequestAccessibilityButton|flagRequestEnhancedWebAccessibility|flagRequestFilterKeyEvents|flagRequestFingerprintGestures|flagRequestTouchExplorationMode|flagRetrieveInteractiveWindows&quot; android:canPerformGestures=&quot;true&quot; android:canRetrieveWindowContent=&quot;true&quot; android:description=&quot;@string/app_name&quot; android:notificationTimeout=&quot;100&quot; android:packageNames=&quot;com.tencent.mm&quot; /&gt; AndroidManifest文件中添加Service声明。 &lt;service android:name=&quot;vip.okfood.luckmoneywx.wx_acc.AccServiceWX&quot; android:canPerformGestures=&quot;true&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; android:label=&quot;@string/app_name&quot; android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.accessibilityservice&quot; android:resource=&quot;@xml/accessibility_service_info&quot; /&gt; &lt;/service&gt; 复写onAccessibilityEvent方法，遍历节点，按照流程图处理event HelperUtil.iterateNode(this, rootNode, rootNode, (rootNode13, node, accessibilityService) -&gt; { if(working) return; if(node == null || node.getViewIdResourceName() == null) return; if(node.getViewIdResourceName().equals(Configs.WXID.PKG_ITEM_WORD)) {//微信红包 LogUtil.d(TAG, &quot;===&gt;发现红包&quot;); //找到红包布局根节点 AccessibilityNodeInfo clickableParent = HelperUtil.findClickableParent(node); AtomicBoolean notClick = new AtomicBoolean(true); HelperUtil.iterateNode(accessibilityService, clickableParent, clickableParent, (rootNode1, node1, accessibilityService1) -&gt; { if(node1 == null || node1.getViewIdResourceName() == null) return; if(node1.getViewIdResourceName().equals(Configs.WXID.PKG_ITEM_NOT_CLICK_ID)) {//已点击 notClick.getAndSet(false); } }); if(notClick.get()) { LogUtil.d(TAG, &quot;===&gt;发现红包,红包还没点过&quot;); working = true; clickableParent.performAction(AccessibilityNodeInfo.ACTION_CLICK); mHandler.postDelayed(() -&gt; { AccessibilityNodeInfo nodeButtonOpen = HelperUtil.loopFindById(accessibilityService, Configs.WXID.PKG_BUTTON_OPEN, &quot;看看大家的手气&quot;); if(nodeButtonOpen == null) { LogUtil.d(TAG, &quot;===&gt;没发现开按钮，执行下返回并延迟开启事件进入&quot;); performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK); mHandler.postDelayed(() -&gt; working = false, 800); } else { LogUtil.d(TAG, &quot;===&gt;发现开按钮,点击&gt;开&quot;); nodeButtonOpen.performAction(AccessibilityNodeInfo.ACTION_CLICK); } }, 800); } else { LogUtil.d(TAG, &quot;===&gt;发现红包,红包已点&quot;); } } }); 点击开后，详情页可以做个延时关闭，再进行下一轮，避免过快速度而被封号 if(eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) { String className = &quot;&quot;; try { className = event.getClassName().toString(); } catch(Exception e) {LogUtil.e(TAG, &quot;Exception:===&gt;&quot;+e.getMessage());} LogUtil.v(TAG, &quot;className=&quot;+className); if(className.equals(&quot;com.tencent.mm.plugin.luckymoney.ui.LuckyMoneyDetailUI&quot;)) { mHandler.postDelayed(() -&gt; { performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK); working = false; }, 500); } } 核心代码就上面这些，用浏览器扫描下面二维码体验试试，有兴趣可以在首页联系QQ联系方式，共同探讨。 APK下载：","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"无障碍","slug":"无障碍","permalink":"https://okfood.vip/blog/tags/无障碍/"},{"name":"抢红包","slug":"抢红包","permalink":"https://okfood.vip/blog/tags/抢红包/"},{"name":"微信","slug":"微信","permalink":"https://okfood.vip/blog/tags/微信/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"HTTP请求相关的几个问题","slug":"HTTP请求相关的几个问题","date":"2019-09-05T01:11:17.000Z","updated":"2019-09-06T08:41:17.698Z","comments":true,"path":"2019/09/05/HTTP请求相关的几个问题/","link":"","permalink":"https://okfood.vip/blog/2019/09/05/HTTP请求相关的几个问题/","excerpt":"","text":"5个问题 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？ 一个 TCP 连接可以对应几个 HTTP 请求？ 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？ 为什么有的时候刷新页面不需要重新建立 SSL 连接？ 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？ 第一个问题 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？ 在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是我短时间内两次访问 https://www.github.com 的时间统计： 头一次访问，有初始化连接和 SSL 开销 初始化连接和 SSL 开销消失了，说明使用的是同一个 TCP 连接 持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。 所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。 第二个问题 一个 TCP 连接可以对应几个 HTTP 请求？ 了解了第一个问题之后，其实这个问题已经有了答案，如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。 第三个问题 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？ HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。 虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。 先来看一下 Pipelining 是什么，RFC 2616 中规定了： A client that supports persistent connections MAY “pipeline” its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received. 一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。 至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET/query?q=A 和 GET/query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。 Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题： 一些代理服务器不能正确的处理 HTTP Pipelining。 正确的流水线实现是复杂的。 Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。 所以现代浏览器默认是不开启 HTTP Pipelining 的。 但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果。 绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个 Connection，并行完成的 所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。 那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点： 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。 和服务器建立多个 TCP 连接。 第四个问题 为什么有的时候刷新页面不需要重新建立 SSL 连接？ 在第一个问题的讨论中已经有答案了，TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。 第五个问题 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？ 假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。 所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。 那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？ 如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。 如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"http","slug":"http","permalink":"https://okfood.vip/blog/tags/http/"},{"name":"TCP","slug":"TCP","permalink":"https://okfood.vip/blog/tags/TCP/"},{"name":"网络","slug":"网络","permalink":"https://okfood.vip/blog/tags/网络/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Flutter插件flutter-img-sync使用指南","slug":"Flutter插件flutter-img-sync使用指南","date":"2019-05-28T03:38:00.000Z","updated":"2019-09-09T06:51:41.197Z","comments":true,"path":"2019/05/28/Flutter插件flutter-img-sync使用指南/","link":"","permalink":"https://okfood.vip/blog/2019/05/28/Flutter插件flutter-img-sync使用指南/","excerpt":"","text":"flutter-img-synca plugin for flutter images synchronization Android Studio及IDEA可在插件商店中搜索并安装: flutter-img-sync 使用说明 vs code编辑器在扩展商店中搜索并安装： flutter-img-sync 使用说明 功能：将资产目录下的图片自动添加到pubspec.yaml的assets配置下面，并生成R文件，代码中直接引用R文件下的定义即可 效果演示(Android Studio or IDEA) 效果演示(vs code) How To Usestep1.创建资产图片存放目录创建资产图片存放目录 如: ./assets/img step2.修改pubspec.yaml定义资产图片存放目录，如: assets: # assets-generator-begin # assets/img/* # assets-generator-endstep3.执行 FlutterImgSync (flutter-img-sync),AS和IDEA需要输入自定义图片预览的端口再点击确定执行插件 命令执行后，图片将会被自动放置到pubspec.yaml文件的assets变量中 ./lib/r.dart 将会被创建 在代码中导入r.dart文件，然后引用R类的变量 step4.pub get 刷新一下","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://okfood.vip/blog/tags/Flutter/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"设计模式：单例","slug":"设计模式：单例","date":"2018-10-27T03:10:27.000Z","updated":"2019-09-11T09:22:38.096Z","comments":true,"path":"2018/10/27/设计模式：单例/","link":"","permalink":"https://okfood.vip/blog/2018/10/27/设计模式：单例/","excerpt":"","text":"单例模式就是确保一个类只有一个实例，并为整个系统提供一个全局访问点 (向整个系统提供这个实例)。 单例三要素 私有的构造方法； 指向自己实例的私有静态引用； 以自己实例为返回值的静态的公有方法。 1.饿汉式public class S { private static S singleton = new S(); public static S getS() { return singleton; } private S() {} }类加载的方式是按需加载，且加载一次。 因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。 2.懒汉式public class S { private static S singleton; public static S getS() { if(singleton == null) { singleton = new S(); } return singleton; } private S() {} }懒汉式单例可以看到，单例实例被延迟加载，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。 在多线程环境下：由于饿汉式单例天生就是线程安全的，可以直接用于多线程而不会出现问题；但懒汉式单例本身是非线程安全的，因此会出现多个实例的情况。 3.synchronized同步单例synchronized方法public class S { private static S singleton; public static synchronized S getS() { if(singleton == null) { singleton = new S(); } return singleton; } private S() {} }使用synchronized修饰getS()方法，保证了对临界资源的同步互斥访问，也就保证了单例。 但是这种实现方式的运行效率会很低，因为同步块的作用域有点大，而且锁的粒度有点粗。 synchronized代码块public class S { private static S singleton; public static S getS() { synchronized(S.class) { if(singleton == null) { singleton = new S(); } } return singleton; } private S() {} }但是这种实现方式的运行效率仍然比较低，事实上，和使用synchronized方法的版本相比，基本没有任何效率上的提高。 4.双重检查方式public class S { //使用volatile关键字防止重排序， //因为 new S()是一个非原子操作，可能创建一个不完整的实例 private static S singleton; public static S getS() { if(singleton == null) { synchronized(S.class) { //只需在第一次创建实例时才同步 if(singleton == null) { singleton = new S(); } } } return singleton; } private S() {} }为了在保证单例的前提下提高运行效率，对singleton进行第二次检查，目的是避开过多的同步（因为这里的同步只需在第一次创建实例时才同步，一旦创建成功，以后获取实例时就不需要同步获取锁了）。 必须使用volatile关键字修饰单例引用。 5.静态内部类public class S { // 私有内部类，按需加载，用时加载，也就是延迟加载 private static class Holder { private static S singleton = new S(); } public static S getS() { return Holder.singleton; } private S() {} }使用内部类实现线程安全的懒汉式单例，这种方式也是一种效率比较高的做法，而且类加载是按需加载，只加载一次。 6.枚举public enum S { INSTANCE; public static S getS() { return INSTANCE; } }线程安全、调用效率高、没有延时加载。并且具有天然的防止反射和反序列化漏洞 7.原子操作public class S { private static final AtomicReference&lt;S&gt; INSTANCE = new AtomicReference&lt;&gt;(); public static S instance() { for(; ; ) { S instance = INSTANCE.get(); if(instance != null) { return instance; } instance = new S(); if(INSTANCE.compareAndSet(null, instance)) { return instance; } } } private S() {} }利用原子引用AtomicReference的CAS操作，确保线程安全并且单例。","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"单例","slug":"单例","permalink":"https://okfood.vip/blog/tags/单例/"},{"name":"设计模式","slug":"设计模式","permalink":"https://okfood.vip/blog/tags/设计模式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"webpack的基本操作","slug":"webpack的基本操作","date":"2018-10-17T04:10:27.000Z","updated":"2019-09-09T09:33:20.487Z","comments":true,"path":"2018/10/17/webpack的基本操作/","link":"","permalink":"https://okfood.vip/blog/2018/10/17/webpack的基本操作/","excerpt":"","text":"webpack的常用命令及安装工作目录下创建项目目录webpack-study 初始化项目npm init -y生成package.json 安装webpack环境//一步到位，安装webpack，webpack-dev-server，webpack-merge，babel npm i -D webpack webpack-dev-server webpack-merge babel-cli babel-preset-env babel-loader也可单独各个安装: //全局安装，已全局安装过忽略这步 npm install -g webpack //安装到你的项目目录 npm install --save-dev webpack //方便后期调试，建议安装devServer和merge npm i -D webpack-dev-server webpack-merge最终： 考虑到ES6兼容的问题，安装下babel npm i -D babel-cli babel-preset-env babel-loader创建配置文件存放文件夹 创建目录路径： webpack-study-&gt;config-&gt;webpack 用于存放webpack配置文件 概念介绍及4大参数本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 它是高度可配置的，但是，在开始前你需要先理解四个核心概念： 入口(entry) 输出(output) loader 插件(plugins) 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中，我们将在下一章节详细讨论这个过程。 接下来我们看一个 entry 配置的最简单例子： webpack.config.js module.exports = { entry: &#39;./path/to/my/entry/file.js&#39; };出口(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： webpack.config.js const path = require(&#39;path&#39;); module.exports = { entry: &#39;./path/to/my/entry/file.js&#39;, output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;my-first-webpack.bundle.js&#39; } };在上面的例子中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要生成(emit)到哪里。 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。 注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。 在更高层面，在 webpack 的配置中 loader 有两个目标。 识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性) 转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(use 属性) webpack.config.js const path = require(&#39;path&#39;); const config = { entry: &#39;./path/to/my/entry/file.js&#39;, output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;my-first-webpack.bundle.js&#39; }, module: { rules: [ { test: /\\.txt$/, use: &#39;raw-loader&#39; } ] } }; module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用raw-loader 转换一下。” 重要的是要记得，在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules。然而，在定义错误时 webpack 会给出严重的警告。为了使你受益于此，如果没有按照正确方式去做，webpack 会“给出严重的警告” 插件(plugins)loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 webpack.config.js const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); // 通过 npm 安装 const webpack = require(&#39;webpack&#39;); // 用于访问内置插件 const path = require(&#39;path&#39;); const config = { entry: &#39;./path/to/my/entry/file.js&#39;, output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;my-first-webpack.bundle.js&#39; }, module: { rules: [ { test: /\\.txt$/, use: &#39;raw-loader&#39; } ] }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;}) ] }; module.exports = config;","categories":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://okfood.vip/blog/tags/webpack/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}]},{"title":"HashMap和HashTable","slug":"HashMap和HashTable","date":"2018-09-02T03:10:18.000Z","updated":"2019-09-06T08:00:04.758Z","comments":true,"path":"2018/09/02/HashMap和HashTable/","link":"","permalink":"https://okfood.vip/blog/2018/09/02/HashMap和HashTable/","excerpt":"","text":"（内部数据结构，哈希碰撞，哈希计算，哈希映射，为什么是头插法，扩容为什么是 2 的幂次） 是一个“链表散列”的数据结构，即数组和链表的结合体，底层就是一个数组结构，数组中的每一项又是一个链表。 相同点 都是以哈希表数据结构存储数据. 都是以链表来作为解决冲突方案:由于不同的对象最终获取的hash值可能一致,这时候就会在该hash表所对应的链表的头结点插入这个键值对. 都可以进行数组扩容，填充因子默认都是0.75 异同点 HashMap非同步实现，线程不安全，允许使用null值和null键 HashTable同步实现，线程安全，不允许null值和键 哈希碰撞 对象Hash的前提是实现equals()和hashCode()两个方法，那么HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样时，这就发生了碰撞冲突，叫做哈希碰撞。 解决方法：开放地址法，再哈希法，链地址法（拉链法），建立一个公共溢出区 详解：https://www.cnblogs.com/little-fly/p/7907935.html 链地址法 ：核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。 为什么是头插法 头插法是操作速度最快的，找到数组位置就直接找到插入位置了，jdk8之前hashmap这种插入方法在并发场景下如果多个线程同时扩容会出现循环列表。jdk8开始hashmap链表在节点长度达到8之后会变成红黑树，这样一来在数组后节点长度不断增加时，遍历一次的次数就会少很多很多（否则每次要遍历所有），相比头插法而言，尾插法操作额外的遍历消耗已经小很多了，也可以避免之前的循环列表问题。（同时如果变成红黑树，也不可能做头插法了） 扩容为什么是 2 的幂次 HashMap计算添加元素的位置时，使用的位运算，这是特别高效的运算；另外，HashMap的初始容量（16）是2的n次幂，扩容也是2倍的形式进行扩容，是因为容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"},{"name":"算法","slug":"Java/算法","permalink":"https://okfood.vip/blog/categories/Java/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://okfood.vip/blog/tags/数据结构/"},{"name":"hash","slug":"hash","permalink":"https://okfood.vip/blog/tags/hash/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"},{"name":"算法","slug":"Java/算法","permalink":"https://okfood.vip/blog/categories/Java/算法/"}]},{"title":"HashMap之10问","slug":"HashMap之10问","date":"2018-08-28T05:59:00.000Z","updated":"2019-09-06T08:00:43.982Z","comments":true,"path":"2018/08/28/HashMap之10问/","link":"","permalink":"https://okfood.vip/blog/2018/08/28/HashMap之10问/","excerpt":"","text":"为什么用HashMap？ HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射 HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap是非synchronized，所以HashMap很快 HashMap可以接受null键和值，而Hashtable则不能（原因就是equlas()方法需要对象，因为HashMap是后出的API经过处理才可以） HashMap的工作原理是什么？HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。 HashMap具体的存取过程： put键值对的方法，过程如下（JDK1.8） ①、判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容(初始化赋值) ②、根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转⑥，如果table[i]不为空，转向③ ③、判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals ④、判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤ ⑤、遍历table[i]，判断链表长度是否超过阀值( TREEIFY THRESHOLD==8)，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作，链表长度低于6，会把红黑树转回链表；遍历过程中若发现key已经存在直接覆盖value即可 ⑥、插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，就需要 resize（扩容2倍后重排） get键值对的方法，过程如下（JDK1.8） ①、指定key 通过hash函数得到key的hash值：int hash=key.hashCode() ②、调用内部方法 getNode()，得到桶号(一般为hash值对桶数求模：int index =hash % tab.length; jdk1.6版本后使用位运算替代模运算，int index=( tab.length - 1）&amp; hash ; ③、比较桶的内部元素是否与key相等，若都不相等，则没有找到；相等，则取出相等记录的value。 ④、如果得到 key 所在的桶的头结点恰好是红黑树节点，就调用红黑树节点的 getTreeNode() 方法，否则就遍历链表节点。getTreeNode 方法使通过调用树形节点的 find()方法进行查找。由于之前添加时已经保证这个树是有序的，因此查找时基本就是折半查找，效率很高。 ⑤、如果对比节点的哈希值和要查找的哈希值相等，就会判断 key 是否相等，相等就直接返回；不相等就从子树中递归查找。 有什么方法可以减少碰撞？ 扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。） 使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。 HashMap中hash函数怎么是是实现的?我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); }返回散列值也就是hashcode与其无符号右移16位后进行异或。 简单来说就是 高16bit不变，低16bit和高16bit做了一个异或(得到的hashcode转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或) (n-1) &amp; hash –&gt; 得到下标 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。 说说你对红黑树的见解？ 1、每个节点非红即黑 2、根节点总是黑色的 3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定） 4、每个叶子节点都是黑色的空节点（NIL节点） 5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 解决hash 碰撞还有那些办法？a. 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 b. 开放定址法：即发生冲突时，去寻找下一个空的哈希地址。只要哈希表足够大，总能找到空的哈希地址。 c. 再哈希法：即发生冲突时，由其他的函数再计算一次哈希值。 d. 建立公共溢出区：将哈希表分为基本表和溢出表，发生冲突时，将冲突的元素放入溢出表。 HashMap 就是使用链地址法来解决冲突的（jdk8中采用平衡树来替代链表存储冲突的元素，但hash() 方法原理相同）。当两个对象的hashcode相同时，它们的bucket位置相同，碰撞就会发生。此时，可以将 put 进来的 K- V 对象插入到链表的尾部。对于储存在同一个bucket位置的链表对象，可通过键对象的equals()方法用来找到键值对。 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作reHashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置 重新调整HashMap大小存在什么问题吗？ 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap） 为什么多线程会导致死循环，它是怎么发生的？HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。2.ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"},{"name":"算法","slug":"Java/算法","permalink":"https://okfood.vip/blog/categories/Java/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://okfood.vip/blog/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"},{"name":"算法","slug":"Java/算法","permalink":"https://okfood.vip/blog/categories/Java/算法/"}]},{"title":"双指针","slug":"双指针","date":"2018-07-20T02:16:27.000Z","updated":"2019-09-09T06:31:51.366Z","comments":true,"path":"2018/07/20/双指针/","link":"","permalink":"https://okfood.vip/blog/2018/07/20/双指针/","excerpt":"","text":"双指针思想类型一般来说分为两类：快慢指针、左右指针。 前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环 后者主要解决数组（或者字符串）中的问题，比如二分查找。 快慢指针 快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。 实例1、判定链表中是否含有环 用两个指针，一个每次前进两步，一个每次前进一步。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。 boolean hasCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while(fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow){ return true; } } return false; } 实例2、已知链表中含有环，返回这个环的起始位置 实例3、寻找链表的中点 可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置 实例4、寻找链表的倒数第 k 个元素 左右指针 左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。 实例1、二分查找 实例2、两数之和 实例3、反转数组 void reverse(int[] nums) { int left = 0; int right = nums.length - 1; while (left &lt; right) { // swap(nums[left], nums[right]) int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; } } 实例4、滑动窗口算法 该算法展示了如何将嵌套for循环在少数问题中转换为单个for循环，从而减少了时间的复杂性。 一个经典的问题 给一组大小为n的整数数组，计算长度为k的子数组的最大值, 我们希望的结果如下 Input : arr[] = {100, 200, 300, 400} k = 2 Output : 700 Input : arr[] = {1, 4, 2, 10, 23, 3, 1, 0, 20} k = 4 Output : 39 We get maximum sum by adding subarray {4, 2, 10, 23} of size 4. Input : arr[] = {2, 3} k = 3 Output : -1 There is no subarray of size 3 as size of whole array is 2.该技术可以通过总线上的窗格得到最好的理解，考虑长度为n的窗口和长度为k的窗格。考虑一下，最初窗格处于极端的左边，即从左边开始的0个单位。现在，将窗口与大小为n和平面的数组arr []以k大小的元素的current_sum相关联。现在，如果我们在窗户上施加力量，使其向前移动一个单位距离。该窗格将覆盖下一个k个连续元素。 考虑数组arr [] = { 5，2，-1，0，3 }，k = 3和n = 5的值 应用滑动窗口技术： 我们使用线性循环计算n个项中前k个元素的总和，并将总和存储在变量window_sum中。 然后，我们将在阵列上线性滑动直至达到最终并同时追踪最大和。 要获得k个元素块的当前总和，只需从前一个块中减去第一个元素并添加当前块的最后一个元素即可。 下面的表示将清楚说明窗口如何在阵列上滑动。 这是我们计算从索引0开始的初始窗口总和的初始阶段。在这个阶段，窗口和为6.现在，我们将maximum_sum设置为current_window，即6。 现在，我们用单位索引来滑动我们的窗口。因此，现在它从窗口中丢弃5并将0添加到窗口。因此，我们将得到新的窗口总和，减去5，然后加上0。所以，我们的窗口和现在变成1.现在，我们将比较这个窗口和与maximum_sum。因为它更小，我们不会改变maximum_sum。 同样，现在我们再次用一个单位索引来滑动我们的窗口，并获得新的窗口总和为2.我们再一次检查这个当前窗口总和是否大于maximum_sum，直到现在。有一次，它再小一些，所以我们不改变maximum_sum。 因此，对于上面的数组，我们的maximum_sum是6。 public static int slideWindowForMaxSum(int arr[], int k) { if(arr.length &lt; k) return -1; int max_sum = 0; for(int i = 0; i &lt; k; i++) { max_sum += arr[i]; } int windows_sum = max_sum; for(int i = k; i &lt; arr.length; i++) { windows_sum += arr[i]-arr[i-k]; max_sum = Math.max(max_sum, windows_sum); } return max_sum; }","categories":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://okfood.vip/blog/tags/双指针/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}]},{"title":"二分查找","slug":"二分查找","date":"2018-06-26T12:16:27.000Z","updated":"2019-09-09T06:06:22.039Z","comments":true,"path":"2018/06/26/二分查找/","link":"","permalink":"https://okfood.vip/blog/2018/06/26/二分查找/","excerpt":"","text":"注意：二分查找的数组一定是有序的！！！ 在有序数组array[]中，不断将数组的中间值（mid）和被查找的值比较，如果被查找的值等于array[mid],就返回下标mid; 否则，就将查找范围缩小一半。如果被查找的值小于array[mid], 就继续在左半边查找;如果被查找的值大于array[mid], 就继续在右半边查找。 直到查找到该值或者查找范围为空时， 查找结束。 public static int binarySearch(int[] a, int key) { int low = 0; int high = a.length-1; while(low &lt;= high) { int mid = (low+high) &gt;&gt;&gt; 1; int midVal = a[mid]; if(midVal &lt; key) low = mid+1; else if(midVal &gt; key) high = mid-1; else return mid; // key found } return -(low+1); // key not found. }","categories":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://okfood.vip/blog/tags/二分查找/"},{"name":"双指针","slug":"双指针","permalink":"https://okfood.vip/blog/tags/双指针/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}]},{"title":"10大排序算法","slug":"10大排序算法","date":"2018-06-22T05:11:37.000Z","updated":"2019-09-09T05:57:42.406Z","comments":true,"path":"2018/06/22/10大排序算法/","link":"","permalink":"https://okfood.vip/blog/2018/06/22/10大排序算法/","excerpt":"","text":"0、排序算法说明0.1 排序的定义对一序列对象根据某个关键字进行排序。 0.2 术语说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。 0.3 算法复杂度总结 0.4 图片名词解释 n: 数据规模 k: “桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存 0.5 算法分类 0.6 比较和非比较的区别常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。 在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。 比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。 计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。 非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 1、冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2 动图演示 1.3 代码实现//冒泡排序 public static int[] bubbleSort(int[] array) { if (array.length == 0) return array; for (int i = 0; i &lt; array.length; i++) for (int j = 0; j &lt; array.length - 1 - i; j++) if (array[j] &gt; array[j + 1]) { int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; } return array; }1.4 算法分析最佳情况：T(n) = O(n) 最差情况：T(n) = O(n²) 平均情况：T(n) = O(n²) 2、选择排序（Selection Sort）表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.1 算法描述 n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.2 动图演示 2.3 代码实现//选择排序 public static int[] selectionSort(int[] array) { if(array.length == 0) return array; for(int i = 0; i &lt; array.length; i++) { int minIndex = i; for(int j = i; j &lt; array.length; j++) { if(array[j] &lt; array[minIndex]) minIndex = j; } int temp = array[minIndex]; array[minIndex] = array[i]; array[i] = temp; } return array; }2.4 算法分析最佳情况：T(n) = O(n²) 最差情况：T(n) = O(n²) 平均情况：T(n) = O(n²) 3、插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 3.1 算法描述 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 动图演示 3.2 代码实现//插入排序 public static int[] insertionSort(int[] array) { if (array.length == 0) return array; int current; for (int i = 0; i &lt; array.length - 1; i++) { current = array[i + 1]; int preIndex = i; while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) { array[preIndex + 1] = array[preIndex]; preIndex--; } array[preIndex + 1] = current; } return array; }3.4 算法分析最佳情况：T(n) = O(n) 最坏情况：T(n) = O(n²) 平均情况：T(n) = O(n²) 4、希尔排序（Shell Sort）希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 4.1 算法描述我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 过程演示 4.3 代码实现//希尔排序 public static int[] ShellSort(int[] array) { int len = array.length; int temp, gap = len / 2; while (gap &gt; 0) { for (int i = gap; i &lt; len; i++) { temp = array[i]; int preIndex = i - gap; while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) { array[preIndex + gap] = array[preIndex]; preIndex -= gap; } array[preIndex + gap] = temp; } gap /= 2; } return array; }4.4 算法分析最佳情况：T(n) = O(nlogn) 最坏情况：T(n) = O(nlogn) 平均情况：T(n) =O(nlogn) #5、归并排序（Merge Sort）# 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 5.3 代码实现//归并排序 private static int[] MergeSort(int[] array) { if(array.length &lt; 2) return array; int mid = array.length/2; int[] left = Arrays.copyOfRange(array, 0, mid); int[] right = Arrays.copyOfRange(array, mid, array.length); return merge(MergeSort(left), MergeSort(right)); } //归并排序——将两段排序好的数组结合成一个排序数组 private static int[] merge(int[] left, int[] right) { int[] result = new int[left.length+right.length]; for(int index = 0, i = 0, j = 0; index &lt; result.length; index++) { if(i &gt;= left.length) result[index] = right[j++]; else if(j &gt;= right.length) result[index] = left[i++]; else if(left[i] &gt; right[j]) result[index] = right[j++]; else result[index] = left[i++]; } return result; }5.4 算法分析最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 6、快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 动图演示 6.3 代码实现//快速排序方法 public static int[] QuickSort(int[] array, int start, int end) { if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null; int smallIndex = partition(array, start, end); if (smallIndex &gt; start) QuickSort(array, start, smallIndex - 1); if (smallIndex &lt; end) QuickSort(array, smallIndex + 1, end); return array; } //快速排序算法——partition public static int partition(int[] array, int start, int end) { int pivot = (int) (start + Math.random() * (end - start + 1)); int smallIndex = start - 1; swap(array, pivot, end); for (int i = start; i &lt;= end; i++) if (array[i] &lt;= array[end]) { smallIndex++; if (i &gt; smallIndex) swap(array, i, smallIndex); } return smallIndex; } //交换数组内两个元素 public static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; }6.4 算法分析最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n²) 平均情况：T(n) = O(nlogn) 7、堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 动图演示 7.3 代码实现//堆排序-声明全局变量，用于记录数组array的长度； private static int len; //堆排序-堆排序算法 private static int[] HeapSort(int[] array) { len = array.length; if(len &lt; 1) return array; //1.构建一个最大堆 buildMaxHeap(array); //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆 while(len &gt; 0) { swap(array, 0, len-1); len--; adjustHeap(array, 0); } return array; } //堆排序-建立最大堆 private static void buildMaxHeap(int[] array) { //从最后一个非叶子节点开始向上构造最大堆 for(int i = (len/2-1); i &gt;= 0; i--) { adjustHeap(array, i); } } //堆排序-调整使之成为最大堆 private static void adjustHeap(int[] array, int i) { int maxIndex = i; //如果有左子树，且左子树大于父节点，则将最大指针指向左子树 if(i*2 &lt; len &amp;&amp; array[i*2] &gt; array[maxIndex]) maxIndex = i*2; //如果有右子树，且右子树大于父节点，则将最大指针指向右子树 if(i*2+1 &lt; len &amp;&amp; array[i*2+1] &gt; array[maxIndex]) maxIndex = i*2+1; //如果父节点不是最大值，则将父节点与最大值交换， //并且递归调整与父节点交换的位置。 if(maxIndex != i) { swap(array, maxIndex, i); adjustHeap(array, maxIndex); } }7.4 算法分析最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 8、计数排序（Counting Sort）计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 动图演示 8.3 代码实现//计数排序 private static int[] CountingSort(int[] array) { if(array.length == 0) return array; int bias, min = array[0], max = array[0]; for(int i = 1; i &lt; array.length; i++) { if(array[i] &gt; max) max = array[i]; if(array[i] &lt; min) min = array[i]; } bias = 0-min; int[] bucket = new int[max-min+1]; Arrays.fill(bucket, 0); for(int value : array) { bucket[value+bias]++; } int index = 0, i = 0; while(index &lt; array.length) { if(bucket[i] != 0) { array[index] = i-bias; bucket[i]--; index++; } else i++; } return array; }8.4 算法分析当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k) 9、桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排 9.1 算法描述 人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序； 从不是空的桶里把排好序的数据拼接起来。 注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。 9.2 图片演示 9.3 代码实现//桶排序 private static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) { if(array == null || array.size() &lt; 2) return array; int max = array.get(0), min = array.get(0); // 找到最大值最小值 for(int num : array) { if(num &gt; max) max = num; if(num &lt; min) min = num; } int bucketCount = (max-min)/bucketSize+1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount); ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; bucketCount; i++) { bucketArr.add(new ArrayList&lt;&gt;()); } for(int num : array) { bucketArr.get((num-min)/bucketSize).add(num); } for(int i = 0; i &lt; bucketCount; i++) { if(bucketSize == 1) { resultArr.addAll(bucketArr.get(i)); } else { if(bucketCount == 1) bucketSize--; ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize); resultArr.addAll(temp); } } return resultArr; }9.4 算法分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n²) 10、基数排序（Radix Sort） 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 10.3 代码实现//基数排序 private static int[] RadixSort(int[] array) { if(array == null || array.length &lt; 2) return array; // 1.先算出最大数的位数； int max = array[0]; for(int i = 1; i &lt; array.length; i++) { max = Math.max(max, array[i]); } int maxDigit = 0; while(max != 0) { max /= 10; maxDigit++; } int mod = 10, div = 1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 10; i++) bucketList.add(new ArrayList&lt;&gt;()); for(int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) { for(int value : array) { int num = (value%mod)/div; bucketList.get(num).add(value); } int index = 0; for(ArrayList&lt;Integer&gt; integers : bucketList) { for(Integer integer : integers) array[index++] = integer; integers.clear(); } } return array; }10.4 算法分析最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值","categories":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://okfood.vip/blog/tags/排序/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}]},{"title":"二叉树的遍历","slug":"二叉树的遍历","date":"2018-04-12T08:21:37.000Z","updated":"2019-09-09T03:33:21.575Z","comments":true,"path":"2018/04/12/二叉树的遍历/","link":"","permalink":"https://okfood.vip/blog/2018/04/12/二叉树的遍历/","excerpt":"","text":"二叉树遍历方式 前序遍历 先访问根节点，然后遍历左子树，再遍历右子树。(根左右) (先序遍历) 中序遍历 先遍历根节点的左子树，然后访问根节点，最后遍历右子树。(左根右) 后序遍历 从左到右先叶子后节点的方式遍历访问左右子树，最后访问根节点。(左右根) 层序遍历 从根节点从上往下逐层遍历，同一层，按从左到右的顺序逐个访问节点。 二叉树节点定义public class TreeNode { public int val = 0; public TreeNode left = null; public TreeNode right = null; public TreeNode() {} public TreeNode(int val) { this.val = val; } }前序遍历递归 先访问根节点 再序遍历左子树 最后序遍历右子树 public static void preOrder(TreeNode treeNode) { if(treeNode == null) return; System.out.println(&quot;node:&quot;+treeNode.val); preOrder(treeNode.left); preOrder(treeNode.right); }非递归 首先申请一个新的栈，记为stack； 将头结点head压入stack中； 每次从stack中弹出栈顶节点，记为cur，然后打印cur值，如果cur右孩子不为空，则将右孩子压入栈中；如果cur的左孩子不为空，将其压入stack中； 重复步骤3，直到stack为空. public static void PreOrder(TreeNode head) { if(head == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(head); while(!(stack.size() == 0)) { TreeNode cur = stack.pop(); System.out.println(&quot;node:&quot;+cur.val); if(cur.right != null) { stack.push(cur.right); } if(cur.left != null) { stack.push(cur.left); } } }非递归演示，打印结果：1 2 4 5 3 6 7 中序遍历递归 先中序遍历左子树 再访问根节点 最后中序遍历右子树 public static void midOrder(TreeNode treeNode) { if(treeNode == null) return; midOrder(treeNode.left); System.out.println(&quot;node:&quot;+treeNode.val); midOrder(treeNode.right); }非递归 申请一个新栈，记为stack，申请一个变量cur，初始时令cur为头节点； 先把cur节点压入栈中，对以cur节点为头的整棵子树来说，依次把整棵树的左子树压入栈中，即不断令cur=cur.left，然后重复步骤2； 不断重复步骤2，直到发现cur为空，此时从stack中弹出一个节点记为node，打印node的值，并让cur = node.right，然后继续重复步骤2； 当stack为空并且cur为空时结束。 public static void InOrder(TreeNode treeNode) { if(treeNode == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = treeNode; while(!(stack.size() == 0) || cur != null) { while(cur != null) { stack.push(cur); cur = cur.left; } TreeNode node = stack.pop(); System.out.println(&quot;node:&quot;+node.val); cur = node.right; } }非递归演示，打印结果：4 2 5 1 6 3 7 后序遍历递归 先后序遍历左子树 再后序遍历右子树 最后访问根节点 public static void posOrder(TreeNode treeNode) { if(treeNode == null) return; posOrder(treeNode.left); posOrder(treeNode.right); System.out.println(&quot;node:&quot;+treeNode.val); }非递归(方式1) 申请两个栈stack1，stack2，然后将头结点压入stack1中； 从stack1中弹出的节点记为cur，然后先把cur的左孩子压入stack1中，再把cur的右孩子压入stack1中； 在整个过程中，每一个从stack1中弹出的节点都放在第二个栈stack2中；不断重复步骤2和步骤3，直到stack1为空，过程停止； 从stack2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序； public static void posOrderOne(TreeNode treeNode) { if(treeNode == null) return; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); stack1.push(treeNode); TreeNode cur; while(!(stack1.size() == 0)) { cur = stack1.pop(); if(cur.left != null) { stack1.push(cur.left); } if(cur.right != null) { stack1.push(cur.right); } stack2.push(cur); } while(!(stack2.size() == 0)) { TreeNode node = stack2.pop(); System.out.println(&quot;node:&quot;+node.val); } }非递归演示，打印结果：4 5 2 6 7 3 1 非递归(方式2) 使用一个栈实现 申请一个栈stack，将头节点压入stack，同时设置两个变量 h 和 c，在整个流程中，h代表最近一次弹出并打印的节点，c代表当前stack的栈顶节点，初始时令h为头节点，，c为null； 每次令c等于当前stack的栈顶节点，但是不从stack中弹出节点，此时分一下三种情况： 如果c的左孩子不为空，并且h不等于c的左孩子，也不等于c的右孩子，则吧c的左孩子压入stack中 如果情况1不成立，并且c的右孩子不为空，并且h不等于c的右孩子，则把c的右孩子压入stack中； 如果情况1和2不成立，则从stack中弹出c并打印，然后令h等于c； 一直重复步骤2，直到stack为空. public static void posOrder(TreeNode treeNode) { if(treeNode == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(treeNode); TreeNode h = treeNode; TreeNode c; while(!(stack.size() == 0)) { c = stack.peek(); //c结点有左孩子 并且 左孩子没被遍历（输出）过 并且 右孩子没被遍历过 if(c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) stack.push(c.left); //c结点有右孩子 并且 右孩子没被遍历（输出）过 else if(c.right != null &amp;&amp; h != c.right) stack.push(c.right); //c结点没有孩子结点 或者孩子结点已经被遍历（输出）过 else { TreeNode node = stack.pop(); System.out.println(&quot;node:&quot;+node.val); h = c; } } }非递归演示，打印结果：4 5 2 6 7 3 1 层序遍历 首先申请一个新的队列，记为queue； 将头结点head压入queue中； 每次从queue中出队，记为node，然后打印node值，如果node左孩子不为空，则将左孩子入队；如果node的右孩子不为空，则将右孩子入队； 重复步骤3，直到queue为空。 public static void levelOrder(TreeNode treeNode) { if(treeNode == null) return; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(treeNode); while(!queue.isEmpty()) { TreeNode node = queue.poll(); System.out.println(&quot;node:&quot;+node.val); if(node.left != null) { queue.offer(node.left); } if(node.right != null) { queue.offer(node.right); } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://okfood.vip/blog/tags/二叉树/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}]},{"title":"数据结构与算法简介","slug":"数据结构与算法简介","date":"2017-10-16T05:21:37.000Z","updated":"2019-09-06T09:24:52.865Z","comments":true,"path":"2017/10/16/数据结构与算法简介/","link":"","permalink":"https://okfood.vip/blog/2017/10/16/数据结构与算法简介/","excerpt":"","text":"数据结构数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 一、数据结构的基本功能①、如何插入一条新的数据项 ②、如何寻找某一特定的数据项 ③、如何删除某一特定的数据项 ④、如何迭代的访问各个数据项，以便进行显示或其他操作 二、常用的数据结构 这几种结构优缺点如下： 算法算法简单来说就是解决问题的步骤。 在Java中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。 一、算法的五个特征①、有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。 ②、确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。 ③、可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。 ④、有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。 ⑤、有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。 二、算法的设计原则①、正确性：首先，算法应当满足以特定的“规则说明”方式给出的需求。其次，对算法是否“正确”的理解可以有以下四个层次： 一、程序语法错误。 二、程序对于几组输入数据能够得出满足需要的结果。 三、程序对于精心选择的、典型、苛刻切带有刁难性的几组输入数据能够得出满足要求的结果。 四、程序对于一切合法的输入数据都能得到满足要求的结果。 PS：通常以第 三 层意义的正确性作为衡量一个算法是否合格的标准。②、可读性：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。 ③、健壮性：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。 ④、高效率与低存储量需求：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。 前面三点 正确性，可读性和健壮性相信都好理解。对于第四点算法的执行效率和存储量，我们知道比较算法的时候，可能会说“A算法比B算法快两倍”之类的话，但实际上这种说法没有任何意义。因为当数据项个数发生变化时，A算法和B算法的效率比例也会发生变化，比如数据项增加了50%，可能A算法比B算法快三倍，但是如果数据项减少了50%，可能A算法和B算法速度一样。所以描述算法的速度必须要和数据项的个数联系起来。也就是“大O”表示法，它是一种算法复杂度的相对表示方式，这里我简单介绍一下，后面会根据具体的算法来描述。 相对(relative)：你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西； 表示(representation)：大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式； 复杂度(complexity)：如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。 然后我们在说说算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间； 一个算法的效率越高越好，而存储量是越低越好。 算法是解决问题的步骤，而数据结构的实现离不开算法。","categories":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://okfood.vip/blog/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}]},{"title":"Android-M-Permission-Tool-Library","slug":"Android-M-Permission-Tool-Library","date":"2017-07-11T03:44:00.000Z","updated":"2019-09-05T08:46:02.513Z","comments":true,"path":"2017/07/11/Android-M-Permission-Tool-Library/","link":"","permalink":"https://okfood.vip/blog/2017/07/11/Android-M-Permission-Tool-Library/","excerpt":"简单易用的andorid M权限相关处理的库，通过极为简单的调用方式实现授权校验、授权申请，开发者可以根据结果反馈做相应的处理。项目源码Library","text":"简单易用的andorid M权限相关处理的库，通过极为简单的调用方式实现授权校验、授权申请，开发者可以根据结果反馈做相应的处理。项目源码Library Step1.添加依赖implementation &#39;com.leo618:SplashAuth:0.0.3&#39;Step2.声明权限，在manifest中声明需要授权的权限。 举个例子如下:&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;Step3.项目manifest中添加提示对话框组件&lt;activity android:name=&quot;com.leo618.splashpermissionsauth.SplashAuthUI&quot; android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot; android:theme=&quot;@style/SplashPermissionsAuthThemeForSplash&quot; /&gt;Step4.使用栗子如下(共有三种使用姿势)： 1.校验是否授权 2.请求授权，在onActivityResult中处理结果 3.校验并请求授权，若存在未授权则启动申请授权，无法处理结果,需要用户再次点击操作触发已授权后的操作 public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } private String[] perms = new String[]{ Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE, Manifest.permission.CAMERA, }; //1.校验是否授权 public void check(View view) { boolean checkResult = SplashAuthUI.check(this, perms); Toast.makeText(this, checkResult ? &quot;全部已授权&quot; : &quot;包含未授权&quot;, Toast.LENGTH_SHORT).show(); } //2.请求授权，在onActivityResult中处理结果 public void request(View view) { SplashAuthUI.launch(this, 100, perms); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if(requestCode == 100) { String result = resultCode == RESULT_OK ? &quot;授权成功&quot; : &quot;授权失败&quot;; Toast.makeText(this, result, Toast.LENGTH_SHORT).show(); } } //3.校验并请求授权，若存在未授权则启动申请授权，无法处理结果,需要用户再次点击操作触发已授权后的操作 public void checkAndRequest(View view) { boolean checkResult = SplashAuthUI.checkAndLaunch(this, perms, true); Toast.makeText(this, checkResult ? &quot;全部已授权&quot; : &quot;包含未授权&quot;, Toast.LENGTH_SHORT).show(); } }","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"Permission","slug":"Permission","permalink":"https://okfood.vip/blog/tags/Permission/"},{"name":"AndroidM","slug":"AndroidM","permalink":"https://okfood.vip/blog/tags/AndroidM/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"AndroidStudio打包apk输出文件目录自定义","slug":"AndroidStudio打包apk输出文件目录自定义","date":"2017-04-25T08:49:00.000Z","updated":"2019-09-05T08:46:57.560Z","comments":true,"path":"2017/04/25/AndroidStudio打包apk输出文件目录自定义/","link":"","permalink":"https://okfood.vip/blog/2017/04/25/AndroidStudio打包apk输出文件目录自定义/","excerpt":"","text":"烦恼背景：每次AS打包后输出的apk会自动生成到指定的目录下，mapping文件也会在build目录下，打包完成需求去拷贝出来，很是麻烦，于是乎，也许可以实现将编译生成的apk包及mapping文件移到自己想要的一个项目目录里面，那岂不是美滋滋，于是就有了这篇文章。 项目源码地址： https://github.com/Leo0618/ASOutputFormat 混淆规则指定生成mappingproguard-rules.pro中加入生成mapping文件语句，如下： build文件配置的必要条件要实现指定输出位置，还需要app目录下的build.gradle文件需要至少有如下几点的配置： buildTypes需要有release类型的配置 productFlavors作为可选，可以不用配置，多渠道打包可使用其他方式（360加固保、美团多渠道打包工具等等） 最后一步做的就是应用gradle文件，在app目录下的build.gradle里面最末尾加入一行代码 apply from: &#39;../output_format.gradle&#39; , 并且你需要将output_format.gradle这个文件拷贝到你的项目根目录，文件下载 正常编译打包，输出效果 自己定义名称的方法可以根据自己情况设置输出根目录名称、mapping文件名称、apk文件名称、是否删除多渠道的原包apk目录等配置，在如下代码位置处修改： /** * 定义输出根目录名称 * @param versionName 可用的参数：当前打包版本名称 * @param versionCode 可用的参数：当前打包版本号码 * @param flavorName 可用的参数：flavor名称，此参数可能为空字符串 */ @SuppressWarnings(&quot;GroovyUnusedDeclaration&quot;) static String outputFileDirName(versionName, versionCode, flavorName) { return &quot;output/app_release-v&quot; + versionName + &quot;-&quot; + versionCode + &quot;-&quot; + dateRelease() } /** * 定义输出mapping文件名称 * @param versionName 可用的参数：当前打包版本名称 * @param versionCode 可用的参数：当前打包版本号码 * @param flavorName 可用的参数：flavor名称，此参数可能为空字符串 */ @SuppressWarnings(&quot;GroovyUnusedDeclaration&quot;) static String mappingFileName(versionName, versionCode, flavorName) { return &quot;mapping-v&quot; + versionName + &quot;-&quot; + versionCode + &quot;-&quot; + dateRelease() + &quot;.txt&quot; } /** * 定义输出apk文件名称 * @param versionName 可用的参数：当前打包版本名称 * @param versionCode 可用的参数：当前打包版本号码 * @param flavorName 可用的参数：flavor名称，此参数可能为空字符串 */ @SuppressWarnings(&quot;GroovyUnusedDeclaration&quot;) static String apkFileName(versionName, versionCode, flavorName) { return &quot;app-release-v&quot; + versionName + &quot;-&quot; + versionCode + &quot;-&quot; + dateRelease() + &quot;.apk&quot; } /** * 是否删除多渠道的原包apk目录 */ static boolean deleteInitApk() { return true }","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://okfood.vip/blog/tags/Android-Studio/"},{"name":"apk","slug":"apk","permalink":"https://okfood.vip/blog/tags/apk/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"【JavaEE】填坑：Web部署不成功","slug":"【JavaEE】填坑：Web部署不成功","date":"2017-04-05T07:19:18.000Z","updated":"2019-09-06T07:45:28.331Z","comments":true,"path":"2017/04/05/【JavaEE】填坑：Web部署不成功/","link":"","permalink":"https://okfood.vip/blog/2017/04/05/【JavaEE】填坑：Web部署不成功/","excerpt":"","text":"Web部署不成功 JmxAdminException ExecutionException FileNotFoundException 现象：编译运行基本的helloworld项目，Tomcat能够正常启动，部署应用老是报错，显示异常 java.lang.IllegalStateException: java.io.FileNotFoundException org.apache.catalina.core.StandardContext.startInternal One or more Filters failed to start. Full details will be found in the appropriate container log file org.apache.catalina.core.StandardContext.startInternal Context [] startup failed due to previous errors解决方案： Project Structure – Artifacts – 勾选 Include in project build","categories":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://okfood.vip/blog/tags/JavaEE/"},{"name":"服务端","slug":"服务端","permalink":"https://okfood.vip/blog/tags/服务端/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}]},{"title":"内存泄漏的场景和解决办法","slug":"内存泄漏的场景和解决办法","date":"2017-01-15T04:17:27.000Z","updated":"2019-09-06T09:13:59.625Z","comments":true,"path":"2017/01/15/内存泄漏的场景和解决办法/","link":"","permalink":"https://okfood.vip/blog/2017/01/15/内存泄漏的场景和解决办法/","excerpt":"","text":"非静态内部类的静态实例 非静态内部类会持有外部类的引用，如果非静态内部类的实例是静态的，就会长期的维持着外部类的引用，组织被系统回收，解决办法是使用静态内部类 多线程相关的匿名内部类和非静态内部类 匿名内部类同样会持有外部类的引用，如果在线程中执行耗时操作就有可能发生内存泄漏，导致外部类无法被回收，直到耗时任务结束，解决办法是在页面退出时结束线程中的任务 Handler内存泄漏 Handler导致的内存泄漏也可以被归纳为非静态内部类导致的，Handler内部message是被存储在MessageQueue中的，有些message不能马上被处理，存在的时间会很长，导致handler无法被回收，如果handler是非静态的，就会导致它的外部类无法被回收，解决办法是1.使用静态handler，外部类引用使用弱引用处理2.在退出页面时移除消息队列中的消息 Context导致内存泄漏 根据场景确定使用Activity的Context还是Application的Context,因为二者生命周期不同，对于不必须使用Activity的Context的场景（Dialog）,一律采用Application的Context,单例模式是最常见的发生此泄漏的场景，比如传入一个Activity的Context被静态类引用，导致无法回收 静态View导致泄漏 使用静态View可以避免每次启动Activity都去读取并渲染View，但是静态View会持有Activity的引用，导致无法回收，解决办法是在Activity销毁的时候将静态View设置为null（View一旦被加载到界面中将会持有一个Context对象的引用，在这个例子中，这个context对象是我们的Activity，声明一个静态变量引用这个View，也就引用了activity） WebView导致的内存泄漏 WebView只要使用一次，内存就不会被释放，所以WebView都存在内存泄漏的问题，通常的解决办法是为WebView单开一个进程，使用AIDL进行通信，根据业务需求在合适的时机释放掉 资源对象未关闭导致 如Cursor，File等，内部往往都使用了缓冲，会造成内存泄漏，一定要确保关闭它并将引用置为null 集合中的对象未清理 集合用于保存对象，如果集合越来越大，不进行合理的清理，尤其是入股集合是静态的 Bitmap导致内存泄漏 bitmap是比较占内存的，所以一定要在不使用的时候及时进行清理，避免静态变量持有大的bitmap对象 监听器未关闭 很多需要register和unregister的系统服务要在合适的时候进行unregister,手动添加的listener也需要及时移除","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"内存泄露","slug":"内存泄露","permalink":"https://okfood.vip/blog/tags/内存泄露/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"避免OOM，及ANR的一些建议","slug":"避免OOM，及ANR的一些建议","date":"2017-01-10T08:11:37.000Z","updated":"2019-09-06T09:10:42.424Z","comments":true,"path":"2017/01/10/避免OOM，及ANR的一些建议/","link":"","permalink":"https://okfood.vip/blog/2017/01/10/避免OOM，及ANR的一些建议/","excerpt":"","text":"避免OOM减少内存对象的占用 ArrayMap/SparseArray代替hashmap 避免在android里面使用Enum 减少bitmap的内存占用 尺寸压缩：通过InSampleSize设置合适的缩放，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。 颜色质量：设置合适的format，ARGB_6666/RBG_545/ARGB_4444/ALPHA_6，存在很大差异。 inBitmap:使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。 减少资源图片的大小，过大的图片可以考虑分段加载 内存对象的重复利用大多数对象的复用，都是利用对象池的技术。 listview/gridview/recycleview contentview的复用 inBitmap 属性对于内存对象的复用ARGB_8888/RBG_565/ARGB_4444/ALPHA_8 避免在ondraw方法里面 new对象 StringBuilder 代替+ ANRApplication Not Responding 也就是在规定的时间内，没有响应。 三种类型 KeyDispatchTimeout(5 seconds) —主要类型按键或触摸事件在特定时间内无响应 BroadcastTimeout(10 seconds) —BroadcastReceiver在特定时间内无法处理完成 ServiceTimeout(20 seconds) —小概率类型 Service在特定的时间内无法处理完成 为什么会超时：事件没有机会处理 &amp; 事件处理超时 避免ANR 避免在activity里面做耗时操作，oncreate &amp; onresume 避免在onReceiver里面做过多操作 避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。 尽量使用handler来处理UI thread &amp; workthread的交互。","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"OOM","slug":"OOM","permalink":"https://okfood.vip/blog/tags/OOM/"},{"name":"ANR","slug":"ANR","permalink":"https://okfood.vip/blog/tags/ANR/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"APK瘦身的一些建议","slug":"APK瘦身的一些建议","date":"2017-01-08T07:21:37.000Z","updated":"2019-09-06T09:05:47.668Z","comments":true,"path":"2017/01/08/APK瘦身的一些建议/","link":"","permalink":"https://okfood.vip/blog/2017/01/08/APK瘦身的一些建议/","excerpt":"","text":"从三个方面进行apk的瘦身操作： Java代码，对应classes.dex文件，剔除无效代码，减小dex文件大小 资源文件，对应res文件夹，assets目录 减小lib中引入的so大小 减小Java代码的体积 开启minifyEnable 定期review重构代码 慎重选择你使用的开源库 资源文件瘦身 优先采用WebP图片 PNG格式图片尽量使用NinePatch格式 Lint查找无效资源 开启shrinkResources功能 resConfigs剔除第三方库或者SDK中的资源 libs目录瘦身so文件最终会被打包到libs目录中，我们针对libs目录的瘦身主要是去除不必要的平台ABI的so文件，例如我们只保留v7a和x86平台的so 其他的一些优化 不涉及透明图层的图片可以转换为jpg格式，比如欢迎页的图片 使用shape(Vector)替换图片 删除或者替换兼容包中无用的一些图（v4.v7.v13） 删除第三方aar库中使用的大图 把so文件放置在网上或者sd卡内","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"APK","slug":"APK","permalink":"https://okfood.vip/blog/tags/APK/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Handler机制原理","slug":"Handler机制原理","date":"2016-12-10T02:21:37.000Z","updated":"2019-09-06T08:59:55.432Z","comments":true,"path":"2016/12/10/Handler机制原理/","link":"","permalink":"https://okfood.vip/blog/2016/12/10/Handler机制原理/","excerpt":"","text":"Handler机制也可叫异步消息机制，它主要由Message,Handler,MessageQueue,Looper4个部分组成 MessageMessage是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。使用Message的arg1和arg2便可携带int数据，使用obj便可携带Object类型数据。 HandlerHandler顾名思义就是处理者的意思，它只要用于在子线程发送消息对象Message,在UI线程处理消息对象Message，在子线程调用sendMessage方法发送消息对象Message，而发送的消息经过一系列地辗转之后最终会被传递到Handler的handleMessage方法中,最终在handleMessage方法中消息对象Message被处理。 MessageQueueMessageQueue就是消息队列的意思,它只要用于存放所有通过Handler发送过来的消息。这部分消息会一直存放于消息队列当中，等待被处理。每个线程中只会有一个MessageQueue对象，请牢记这句话。其实从字面上就可以看出，MessageQueue底层数据结构是队列，而且这个队列只存放Message对象。 LooperLooper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，然后每当MesssageQueue中存在一条消息，Looper就会将这条消息取出，并将它传递到Handler的handleMessage()方法中。每个线程只有一个Looper对象。 首先在UI线程我们创建了一个Handler实例对象，无论是匿名内部类还是自定义类生成的Handler实例对象，我们都需要对handleMessage方法进行重写，在handleMessage方法中我们可以通过参数msg来写接受消息过后UIi线程的逻辑处理，接着我们创建子线程，在子线程中需要更新UI的时候，新建一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，比如arg1,arg2,obj等，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理，此时MessageQueue的管家Looper正在不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法，最终前面提到的消息会被Looper从MessageQueue中取出来传递给handleMessage方法，最终得到处理。","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"https://okfood.vip/blog/tags/Handler/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Android事件分发机制","slug":"Android事件分发机制","date":"2016-11-15T03:21:37.000Z","updated":"2019-09-06T08:55:58.668Z","comments":true,"path":"2016/11/15/Android事件分发机制/","link":"","permalink":"https://okfood.vip/blog/2016/11/15/Android事件分发机制/","excerpt":"","text":"时间类型 MotionEvent.ACTION_DOWN 当我们手指按下屏幕的第一个事件便是ACTION_DOWN了,也就是意味着事件的开始。 MotionEvent.ACTION_MOVE 当我们手指按下屏幕后，在屏幕上滑动的过程，此事件就会不断的触发。 MotionEvent.ACTION_UP 此事件在我们手指从屏幕抬起的时候会触发。 MotionEvent.ACTION_CANCEL 这个事件说起来稍微复杂一点，举个栗子：当我们的外层View将事件传递给内层View去处理时，外层View的拦截方法一般会返回false，但是当某个条件触发后，外层View想自己处理接下来的事件，就拦截了事件分发，此时内层View就会收到ACTION_CANCEL的事件。 MotionEvent.ACTION_OUTSIDE 这个事件我们不常用到，考虑这种场景。我们有一个Diallog弹出，当我们按Dialog以外的屏幕将Dialog消失掉。这个时候可以考虑监听这个事件，要想使用这个事件我们必须对当前的Window设置一个Flag：FLAG_WATCH_OUTSIDE_TOUCH。 几个方法 dispatchTouchEvent(MotionEvent event) 这个方法仅在ViewGrope中，会先判断子View是否有调用disallowIntercept父View去拦截事件，如果没有，父View自己会调用onInterceptTouchEvent判断自己是否有拦截，如果拦截事件，将调用父View自己的onTouchEvent方法去处理事件，如果没有拦截事件，事件将继续分发到子View中处理。 onInterceptTouchEvent(MotionEvent event) 用来申明是否拦截事件继续向下分发，如果返回true，事件将不会继续向下分发，而是交由自己的onTouchEvent方法处理。 onTouchEvent(MotionEvent event) 显然，这个就是事件处理的方法了。 onTouch(MotionEvent event) 这个方法是在我们对某一个setOnTouchListener时回调，也就是在传递事件的时候，在交给View本身的onTouchEvent处理之前判断是否有监听的TouchListener，如果有优先调用TouchListener的onTouch方法处理。 ViewGroup有以下三个与事件分发的方法，而View只有dispatchTouchEvent和onTouchEvent。","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"事件分发","slug":"事件分发","permalink":"https://okfood.vip/blog/tags/事件分发/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Android APK打包流程","slug":"Android APK打包流程","date":"2016-11-05T13:01:37.000Z","updated":"2019-09-06T08:49:17.537Z","comments":true,"path":"2016/11/05/Android APK打包流程/","link":"","permalink":"https://okfood.vip/blog/2016/11/05/Android APK打包流程/","excerpt":"","text":"①. 打包资源文件，生成R.java文件打包资源的工具是aapt（The Android Asset Packaing Tool）。项目中的AndroidManifest.xml文件和布局文件XML都会编译，然后生成相应的R.java，另外AndroidManifest.xml会被aapt编译成二进制。存放在APP的res目录下的资源，该类资源在APP打包前大多会被编译，变成二进制文件，并会为每个该类文件赋予一个resource id。对于该类资源的访问，应用层代码则是通过resource id进行访问的。Android应用在编译过程中aapt工具会对资源文件进行编译，并生成一个resource.arsc文件，resource.arsc文件相当于一个文件索引表，记录了很多跟资源相关的信息。 ②. 处理aidl文件，生成相应的Java文件这一过程中使用到的工具是aidl（Android Interface Definition Language），即Android接口描述语言。aidl工具解析接口定义文件然后生成相应的Java代码接口供程序调用。如果在项目没有使用到aidl文件，则可以跳过这一步。 ③. 编译项目源代码，生成class文件项目中所有的Java代码，包括R.java和.aidl文件，都会变Java编译器（javac）编译成.class文件，生成的class文件位于工程中的bin/classes目录下。 ④. 转换所有的class文件，生成classes.dex文件dx工具生成可供Android系统Dalvik虚拟机执行的classes.dex文件，任何第三方的libraries和.class文件都会被转换成.dex文件，dx工具的主要工作是将Java字节码转成成Dalvik字节码、压缩常量池、消除冗余信息等。 ⑤. 打包生成APK文件所有没有编译的资源，如images、assets目录下资源（该类文件是一些原始文件，APP打包时并不会对其进行编译，而是直接打包到APP中，对于这一类资源文件的访问，应用层代码需要通过文件名对其进行访问）；编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中。 ⑥. 对APK文件进行签名一旦APK文件生成，它必须被签名才能被安装在设备上。在开发过程中，主要用到的就是两种签名的keystore。一种是用于调试的debug.keystore，它主要用于调试，在Eclipse或者Android Studio中直接run以后跑在手机上的就是使用的debug.keystore。另一种就是用于发布正式版本的keystore。 ⑦. 对签名后的APK文件进行对齐处理如果你发布的apk是正式版的话，就必须对APK进行对齐处理，用到的工具是zipalign对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用。","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://okfood.vip/blog/tags/基础/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"TCP、三次握手四次挥手、http和https的区别","slug":"TCP、三次握手四次挥手、http和https的区别","date":"2016-10-21T02:01:17.000Z","updated":"2019-09-06T08:29:35.086Z","comments":true,"path":"2016/10/21/TCP、三次握手四次挥手、http和https的区别/","link":"","permalink":"https://okfood.vip/blog/2016/10/21/TCP、三次握手四次挥手、http和https的区别/","excerpt":"","text":"TCP/IP四层模型 应用层：负责处理特定的应用程序细节。 运输层：主要为两台主机上的应用提供端到端的通信。 网络层（互联网层）：处理分组在网络中的活动，比如分组的选路。 链路层（数据链路层/网络接口层）：包括操作系统中的设备驱动程序、计算机中对应的网络接口卡 假设在一个局域网(LAN)如以太网中有两台主机，二者运行FTP协议： 网络层与运输层的区别在TCP/TP协议族中，网络层IP提供的是一种不可靠的服务。它只是尽可能快地把分组从源节点送到目的节点，但不提供任何可靠性的保证。 Tcp在不可靠的ip层上，提供了一个可靠的运输层，为了提供这种可靠的服务，TCP采用了超时重传、发送和接受端到端的确认分组等机制。 TCP/IP协议族的分层 TCP11种状态，3次握手建立连接，4次挥手关闭连接为什么要进行三次握手（两次确认）这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了。 四次挥手关闭连接 当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1, 服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。 为什么要等待呢？为了防止这种情况：A接到B的释放连接请求后会发送一个确认信息，但是如果这个确认信息丢了，也就是B没有收到确认释放连接，那么B就会重发一个释放连接请求，这时候A还处于TIME_WAIT状态，所以会再次发送一个确认信息。 为什么TIME_WAIT 状态还需要等2*MSL秒之后才能返回到CLOSED 状态呢？A2因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态（就好比从SYN_SENT 状态到ESTABLISH 状态那样），但是我们必须假想网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。 11种状态 CLOSED：初始状态，表示TCP连接是“关闭着的”或“未打开的”。 LISTEN ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。 SYN_RCVD ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的- SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。 SYN_SENT ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。 ESTABLISHED ：表示TCP连接已经成功建立。 FIN_WAIT_1 ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。 FIN_WAIT_2 ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。 TIME_WAIT ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况） CLOSING ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。 LAST_ACK ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。 CLOSING状态 http和https的区别与联系 http的中文叫做超文本传输协议,它负责完成客户端到服务端的一系列操作,是专门用来传输注入HTML的超媒体文档等web内容的协议,它是基于传输层的TCP协议的应用层协议 https:https是基于安全套接字的http协议,也可以理解为是http+ssl/tls(数字证书)的组合 区别主要如下 https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 扩展知识: https://blog.csdn.net/xionghuixionghui/article/details/68569282 浏览器输入一个 URL，按下回车网络传输的流程 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址。 解析出ip地址后，根据IP地址和默认端口，和服务器建立TCP连接。 浏览器发出读取文件（URL域名后面的部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文传送给服务器。 服务器对浏览器请求作出响应，并把对应的html文本发送给浏览器。 释放TCP链接。 浏览器将该html文本显示内容。","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"http","slug":"http","permalink":"https://okfood.vip/blog/tags/http/"},{"name":"TCP","slug":"TCP","permalink":"https://okfood.vip/blog/tags/TCP/"},{"name":"网络","slug":"网络","permalink":"https://okfood.vip/blog/tags/网络/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Android的4大启动模式","slug":"Android的4大启动模式","date":"2016-09-15T11:11:17.000Z","updated":"2019-09-06T08:46:04.095Z","comments":true,"path":"2016/09/15/Android的4大启动模式/","link":"","permalink":"https://okfood.vip/blog/2016/09/15/Android的4大启动模式/","excerpt":"","text":"“standard” (默认)、“singleTop”、“singleTask”、“singleInstance” standard 模式标准模式，每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。Activity的启动三回调(onCreate()-&gt;onStart()-&gt;onResume())都会执行 singleTop 模式栈顶复用模式，如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建，重用该Activity并回调其onNewIntent()方法；如果Activity已经存在但是不在栈顶,那么作用与standard模式一样。使用场景如新闻类或者阅读类App的内容页面。 singleTask 模式栈内复用模式，如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance 模式在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://okfood.vip/blog/tags/基础/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Nginx-Tomcat极简方式配置Https","slug":"Nginx-Tomcat极简方式配置Https","date":"2016-08-08T09:55:00.000Z","updated":"2019-09-05T08:48:47.481Z","comments":true,"path":"2016/08/08/Nginx-Tomcat极简方式配置Https/","link":"","permalink":"https://okfood.vip/blog/2016/08/08/Nginx-Tomcat极简方式配置Https/","excerpt":"","text":"Nginx+Tomcat极简方式配置，实现https安全访问。 效果网站： https://okfood.vip Step1.获取证书并下载拷贝获取SSL证书并拷贝至指定目录：方式一：使用SSL For Free生成 方式二：阿里云腾讯云获取，获取方法官网有 此文以阿里云获取的SSL证书为例。 获取到证书后，nginx配置文件nginx.conf所在的目录下创建文件夹命名为cert,下载并将xxx.key和xxx.pem文件拷贝至cert文件夹下。 Step2.配置Nginx支持SSL编辑nginx.conf，我得配置文件在/etc/nginx/下面，修改如下配置，主要是ssl_certificate和ssl_certificate_key指向文件位置，xxx改成自己证书文件名称，其他配置可参考Nginx官网进行可选配置。 upstream tomcat { server 127.0.0.1:8080 fail_timeout=0; } # HTTPS server server { listen 443 ssl; server_name localhost; ssl_certificate cert/xxx.pem; ssl_certificate_key cert/xxx.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto https; proxy_redirect off; proxy_connect_timeout 240; proxy_send_timeout 240; proxy_read_timeout 240; # note, there is not SSL here! plain HTTP is used proxy_pass http://tomcat; } }Step3.配置Tomcat支持SSL编辑server.xml，我的配置文件位于/www/server/apache-tomcat-8.5.32/conf/下面， 修改此处为如下， &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;443&quot; proxyPort=&quot;443&quot; /&gt; 修改Host,节点下新增一个Valve &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot; remoteIpHeader=&quot;x-forwarded-for&quot; remoteIpProxiesHeader=&quot;x-forwarded-by&quot; protocolHeader=&quot;x-forwarded-proto&quot; /&gt; &lt;/Host&gt;Step4.保存文件到服务器上，重启一下Nginx和Tomcat，到此结束，就这么简单！","categories":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://okfood.vip/blog/tags/Nginx/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://okfood.vip/blog/tags/Tomcat/"},{"name":"https","slug":"https","permalink":"https://okfood.vip/blog/tags/https/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}]},{"title":"Android客户端应用内检测升级框架AppUpdate","slug":"Android客户端应用内检测升级框架AppUpdate","date":"2016-05-29T03:27:25.000Z","updated":"2019-09-06T07:43:03.929Z","comments":true,"path":"2016/05/29/Android客户端应用内检测升级框架AppUpdate/","link":"","permalink":"https://okfood.vip/blog/2016/05/29/Android客户端应用内检测升级框架AppUpdate/","excerpt":"","text":"an independent util library for checking app update info and hint message by dialog,download latest version with notification progress. 功能说明： 支持Android版本号9+，不依赖第三方库； 支持更新信息查询、线上新版apk文件下载； 支持默认更新提示对话框，同时支持自定义处理； app更新接口json数据格式: { &quot;app_name&quot;: &quot;apk更新demo&quot;, &quot;download_url&quot;: &quot;http://www.xxx/apk-v2.3.0.apk&quot;, &quot;file_md5&quot;: &quot;9d4522b59a92742124110a7abf440267&quot;, &quot;file_size&quot;: &quot;31227937&quot;, &quot;is_forced&quot;: &quot;0&quot;, &quot;msg&quot;: &quot;&quot;, &quot;package&quot;: &quot;com.lzj.appupdate&quot;, &quot;remark&quot;: &quot;1、全新首页，新视觉 新体验\\n2、修复若干bug&quot;, &quot;status&quot;: 0, &quot;version_id&quot;: &quot;102&quot;, &quot;version_name&quot;: &quot;v2.0.0&quot; }version_id : 应用版本号码，必填； download_url : 线上最新版apk文件下载地址，必填； file_md5 : 线上最新版apk文件的md5值，必填； is_forced : 是否为强制更新，0：不强制更新，1：强制更新， 默认为0； app_name : 应用名称，可选； file_size : 线上最新版apk文件的大小，可选； version_name : 应用版本名称，可选； package : 应用包名，可选； remark : 应用升级提示语，可选； status : 接口请求状态码，可选； msg : 接口请求附加消息，可选； How to Use Step1: Add the dependency dependencies { compile &#39;com.lzj.appupdate:library:0.0.3&#39; }Step2: Use in code UpdateManager.config(getApplication(), true, true); UpdateManager.checkUpdate(&quot;http://ppwapp.simuwang.com/Other/getAndroidVersion?&quot;, null); 需要使用到的权限： &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; 如果使用默认dialog显示更新信息需要在project/app/AndroidManifest.xml中加入UpdateDefaultDisplayDialogUI： &lt;application &gt; ... &lt;activity android:name=&quot;com.lzj.appupdate.UpdateDefaultDisplayDialogUI&quot; android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot; android:theme=&quot;@style/UpdateDefaultDisplayDialog&quot;/&gt; &lt;/application&gt; 混淆 -dontwarn com.lzj.appupdate.** -keep class com.lzj.appupdate.** { *; } 觉得好用欢迎fork和star github传送门","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"APP升级","slug":"APP升级","permalink":"https://okfood.vip/blog/tags/APP升级/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Linux系统下忘记MySQL的root密码怎么办？","slug":"Linux系统下忘记MySQL的root密码怎么办？","date":"2016-02-13T10:03:00.000Z","updated":"2019-09-04T08:59:55.824Z","comments":true,"path":"2016/02/13/Linux系统下忘记MySQL的root密码怎么办？/","link":"","permalink":"https://okfood.vip/blog/2016/02/13/Linux系统下忘记MySQL的root密码怎么办？/","excerpt":"","text":"修改MySQL的配置文件（默认为/etc/my.cnf）,在[mysqld]下添加一行skip-grant-tables 保存配置文件后，重启MySQL服务 service mysqld restart 再次进入MySQL命令行 mysql -u root -p,输入密码时直接回车，就会进入MySQL数据库了，这个时候按照常规流程修改root密码即可。依次输入： &gt;use mysql; 更改数据库 &gt;UPDATE user SET PASSWORD =password(&quot;这里写新密码&quot;) WHERE USER= &#39;root&#39;; 重设密码 &gt;flush privileges; 刷新MySQL的系统权限相关表，以防止更改后拒绝访问；或或者重启MySQL服务器 注意：若出现找不到PASSWORD字段时，使用authentication_string,即： &gt;UPDATE user SET authentication_string =password(&quot;这里写新密码&quot;) WHERE USER= &#39;root&#39;; 重设密码 密码修改完毕后，再按照步骤1中的流程，删掉配置文件中的那行，并且重启MySQL服务，新密码就生效了。","categories":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://okfood.vip/blog/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"https://okfood.vip/blog/tags/Linux/"},{"name":"数据库","slug":"数据库","permalink":"https://okfood.vip/blog/tags/数据库/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}]},{"title":"sleep 、wait、yield的区别，wait的线程如何唤醒它","slug":"sleep 、wait、yield的区别，wait的线程如何唤醒它","date":"2015-10-22T02:01:17.000Z","updated":"2019-09-06T08:11:04.578Z","comments":true,"path":"2015/10/22/sleep 、wait、yield的区别，wait的线程如何唤醒它/","link":"","permalink":"https://okfood.vip/blog/2015/10/22/sleep 、wait、yield的区别，wait的线程如何唤醒它/","excerpt":"","text":"sleep()在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。sleep()使当前线程进入阻塞状态，在指定时间内不会执行。 wait()方法在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。 wait的线程如何唤醒?唤醒当前对象锁的等待线程使用notify或notifyAll方法，必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。waite()和notify()必须在synchronized函数或synchronized block中进行调用。如果在non-synchronized函数或non-synchronized block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。 yield方法暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 yield()只能使同优先级或更高优先级的线程有执行的机会。 调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。 join方法等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。 在很多情况下，主线程创建并启动了线程，如果子线程中要进行大量耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。方法join()的作用是等待线程对象销毁。 sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会； yield()方法只会给相同优先级或更高优先级的线程以运行的机会； join的意思是会等到调用改join方法的线程执行完毕之后才会执行其他线程，","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://okfood.vip/blog/tags/多线程/"},{"name":"线程安全","slug":"线程安全","permalink":"https://okfood.vip/blog/tags/线程安全/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"synchronized 和 volatile 、ReentrantLock 、CAS 的区别","slug":"synchronized 和 volatile 、ReentrantLock 、CAS 的区别","date":"2015-09-12T04:11:18.000Z","updated":"2019-09-06T08:07:42.860Z","comments":true,"path":"2015/09/12/synchronized 和 volatile 、ReentrantLock 、CAS 的区别/","link":"","permalink":"https://okfood.vip/blog/2015/09/12/synchronized 和 volatile 、ReentrantLock 、CAS 的区别/","excerpt":"","text":"JAVA的内存模块特点，原子性、可见性、有序性 Synchronized和volatile的区别 Synchronized保证内存可见性和操作的原子性，Volatile只能保证内存可见性(atomic关键字正好弥补了volatile的缺点)。 volatile不需要加锁，比Synchronized更轻量级，并不会阻塞线程（volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。） volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化（如编译器重排序的优化） volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符 Synchronized与ReentrantLock的区别 两者都是可重入锁（重入锁：自己可以再次获取自己的内部锁） Synchronized是依赖于JVM实现的；而ReentrantLock是依赖于JDK实现的，是API层面的，需要Lock()和unLock()方法配合try/finally语句块来完成。 ReentrantLock比Synchronized多了三项功能：等待可中断，可实现公平锁，可实现选择性通知（锁可绑定多个条件）。 Synchronized只能是非公平锁。ReenTrantLock默认情况是非公平的，可以通过 ReentrantLock(boolean fair)构造方法来指定是公平锁还是非公平锁。 Synchronized可重入的实现原理 每一个Synchronized可重入锁都关联一个线程持有者和一个计数器。当计数器为0时，表示该锁可以被任何线程获取，一旦有线程成功获取该锁，计数器为1。如果其他线程也申请该锁，则会进入等待状态，直到持有该锁的线程释放锁；但是如果持有锁的线程再次申请该锁，程序计数器会加1（前提是该锁是可重入锁，否则进入等待状态）。当退出一次Synchronized方法或代码块时，计数器减1，直至计数器为0，线程释放锁。 synchronized 和 CAS 的区别 synchronized 采用的是 CPU 悲观锁机制，即线程获得的是独占锁。独占锁就意味着 其他线程只能依靠阻塞来等待线程释放锁。而在 CPU 转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起 CPU 频繁的上下文切换导致效率很低。尽管 Java1.6 为 synchronized 做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。 CAS (Compare And Swap)，比较并替换。它当中使用了3个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。采用的是一种乐观锁的机制，它不会阻塞任何线程，所以在效率上，它会比 synchronized 要高。所谓乐观锁就是：每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。 所以，在并发量非常高的情况下，尽量的用同步锁，而在其他情况下，我们可以灵活的采用 CAS 机制。 synchronized 修饰静态方法和修饰实例方法有什么不同 静态方法的锁和实例方法的锁，默认是不同的对象锁 静态方法加锁，能和该类中所有用synchronized修饰静态方法的相互互斥，和​未用synchronized修饰的静态方法不互斥 静态​方法锁实际是对类对象加锁，实例方法加锁实际是对实例对象加锁","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://okfood.vip/blog/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"多渠道批量打包方式之一适用于需将渠道号写入meta中的","slug":"多渠道批量打包方式之一适用于需将渠道号写入meta中的","date":"2015-07-29T02:23:25.000Z","updated":"2019-09-06T07:40:01.901Z","comments":true,"path":"2015/07/29/多渠道批量打包方式之一适用于需将渠道号写入meta中的/","link":"","permalink":"https://okfood.vip/blog/2015/07/29/多渠道批量打包方式之一适用于需将渠道号写入meta中的/","excerpt":"","text":"操作步骤： 安装Eclipse插件：将AndroidTools_1.1.4.201410081930.jar拷贝至plugins，重启Eclipse； bom拷贝到项目根目录下，填写统计SDK的keyName，加入需要的渠道名channel，填写keystore信息及apk输出路径（不拷贝也行 运行第三步 检测到没有bom会自动生成模板，自己修改即可）； 右键点击项目，选择蓝贝壳儿，打包发布，搞定。 特点：逐个包签名，相对耗时一点(耗时还能接受，平均一个包10秒左右吧)，生成的包数据准确，每次打包仅修改了清单文件中的指定统计渠道的meta的value值。 注：插件带的其他功能：定位文件于资源管理器(一般用open explore,功能一样)；第三方依赖jar包的更新(很少用). 工具包下载地址 ： http://download.csdn.net/detail/lzj922718/8942023","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://okfood.vip/blog/tags/工具/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"OkHttp使用教程","slug":"OkHttp使用教程","date":"2015-06-18T04:22:25.000Z","updated":"2019-09-06T07:37:33.355Z","comments":true,"path":"2015/06/18/OkHttp使用教程/","link":"","permalink":"https://okfood.vip/blog/2015/06/18/OkHttp使用教程/","excerpt":"","text":"OkHttp源码解析–传送门 Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。 尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。 OkHttp处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。 使用OkHttp无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。 注：在国内使用OkHttp会因为这个问题导致部分酷派手机用户无法联网，所以对于大众app来说，需要等待这个bug修复后再使用。或者尝试使用OkHttp的老版本。 截止到目前，OkHttp一直没有修复，并把修复计划延迟到了OkHttp2.3中。不是所有设备都能重现，仅少量设备会出现这个问题。（如果问题这么明显，OkHttp早就修复了） 入门官方资料官方介绍 github源码 使用范围OkHttp支持Android 2.3及其以上版本。 对于Java, JDK1.7以上。 jar包准备官方介绍页面有链接位置。这里把下载链接也写在下面。 OkHttp Okio 基本使用HTTP GETOkHttpClient client = new OkHttpClient(); String run(String url) throws IOException { Request request = new Request.Builder().url(url).build(); Response response = client.newCall(request).execute(); if (response.isSuccessful()) { return response.body().string(); } else { throw new IOException(&quot;Unexpected code &quot; + response); } }Request是OkHttp中访问的请求，Builder是辅助类。Response即OkHttp中的响应。 Response类： public boolean isSuccessful() Returns true if the code is in [200..300), which means the request was successfully received, understood, and accepted. response.body()返回ResponseBody类可以方便的获取string public final String string() throws IOExceptionReturns the response as a string decoded with the charset of the Content-Type header. If that header is either absent or lacks a charset, this will attempt to decode the response body as UTF-8.Throws: IOException 当然也能获取到流的形式： public final InputStream byteStream()HTTP POSTPOST提交Json数据 public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;); OkHttpClient client = new OkHttpClient(); String post(String url, String json) throws IOException { RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); f (response.isSuccessful()) { return response.body().string(); } else { throw new IOException(&quot;Unexpected code &quot; + response); } }使用Request的post方法来提交请求体RequestBody POST提交键值对 很多时候我们会需要通过POST方式把键值对数据传送到服务器。 OkHttp提供了很方便的方式来做这件事情。 OkHttpClient client = new OkHttpClient(); String post(String url, String json) throws IOException { RequestBody formBody = new FormEncodingBuilder().add(“platform”, “android”).add(“name”, “bug”).add(“subject”, “XXXXXXXXXXXXXXX”) .build(); Request request = new Request.Builder().url(url).post(body).build(); Response response = client.newCall(request).execute(); if (response.isSuccessful()) { return response.body().string(); } else { throw new IOException(“Unexpected code “ + response); } } 总结通过上面的例子我们可以发现，OkHttp在很多时候使用都是很方便的，而且很多代码也有重复，因此特地整理了下面的工具类。 注意： OkHttp官方文档并不建议我们创建多个OkHttpClient，因此全局使用一个。 如果有需要，可以使用clone方法，再进行自定义。这点在后面的高级教程里会提到。 enqueue为OkHttp提供的异步方法，入门教程中并没有提到，后面的高级教程里会有解释。 import java.io.IOException; import java.util.List; import java.util.concurrent.TimeUnit; import org.apache.http.client.utils.URLEncodedUtils; import org.apache.http.message.BasicNameValuePair; import cn.wiz.sdk.constant.WizConstant; import com.squareup.okhttp.Callback; import com.squareup.okhttp.OkHttpClient; import com.squareup.okhttp.Request; import com.squareup.okhttp.Response; public class OkHttpUtil { private static final OkHttpClient mOkHttpClient = new OkHttpClient(); static{ mOkHttpClient.setConnectTimeout(30, TimeUnit.SECONDS); } /** * 该不会开启异步线程。 * @param request * @return * @throws IOException */ public static Response execute(Request request) throws IOException{ return mOkHttpClient.newCall(request).execute(); } /** * 开启异步线程访问网络 * @param request * @param responseCallback */ public static void enqueue(Request request, Callback responseCallback){ mOkHttpClient.newCall(request).enqueue(responseCallback); } /** * 开启异步线程访问网络, 且不在意返回结果（实现空callback） * @param request */ public static void enqueue(Request request){ mOkHttpClient.newCall(request).enqueue(new Callback() { @Override public void onResponse(Response arg0) throws IOException { } @Override public void onFailure(Request arg0, IOException arg1) { } }); } public static String getStringFromServer(String url) throws IOException{ Request request = new Request.Builder().url(url).build(); Response response = execute(request); if (response.isSuccessful()) { String responseUrl = response.body().string(); return responseUrl; } else { throw new IOException(&quot;Unexpected code &quot; + response); } } private static final String CHARSET_NAME = &quot;UTF-8&quot;; /** * 这里使用了HttpClinet的API。只是为了方便 * @param params * @return */ public static String formatParams(List&lt;BasicNameValuePair&gt; params){ return URLEncodedUtils.format(params, CHARSET_NAME); } /** * 为HttpGet 的 url 方便的添加多个name value 参数。 * @param url * @param params * @return */ public static String attachHttpGetParams(String url, List&lt;BasicNameValuePair&gt; params){ return url + &quot;?&quot; + formatParams(params); } /** * 为HttpGet 的 url 方便的添加1个name value 参数。 * @param url * @param name * @param value * @return */ public static String attachHttpGetParam(String url, String name, String value){ return url + &quot;?&quot; + name + &quot;=&quot; + value; } }高级高级属性其实用的不多，这里主要是对OkHttp github官方教程进行了翻译。 同步get下载一个文件，打印他的响应头，以string形式打印响应体。 响应体的 string() 方法对于小文档来说十分方便、高效。但是如果响应体太大（超过1MB），应避免适应 string()方法 ，因为他会将把整个文档加载到内存中。 对于超过1MB的响应body，应使用流的方式来处理body。 private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { Request request = new Request.Builder().url(&quot;http://publicobject.com/helloworld.txt&quot;).build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) { System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i)); } System.out.println(response.body().string()); }异步get在一个工作线程中下载文件，当响应可读时回调Callback接口。读取响应时会阻塞当前线程。OkHttp现阶段不提供异步api来接收响应体。 private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { Request request = new Request.Builder().url(&quot;http://publicobject.com/helloworld.txt&quot;).build(); client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Request request, Throwable throwable) { throwable.printStackTrace(); } @Override public void onResponse(Response response) throws IOException { if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) { System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i)); } System.out.println(response.body().string()); } }); }提取响应头典型的HTTP头 像是一个 Map&lt;String, String&gt; :每个字段都有一个或没有值。但是一些头允许多个值，像Guava的Multimap。例如：HTTP响应里面提供的Vary响应头，就是多值的。OkHttp的api试图让这些情况都适用。 当写请求头的时候，使用header(name, value)可以设置唯一的name、value。如果已经有值，旧的将被移除，然后添加新的。使用addHeader(name, value)可以添加多值（添加，不移除已有的）。 当读取响应头时，使用header(name)返回最后出现的name、value。通常情况这也是唯一的name、value。如果没有值，那么header(name)将返回null。如果想读取字段对应的所有值，使用headers(name)会返回一个list。 为了获取所有的Header，Headers类支持按index访问。 private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { Request request = new Request.Builder().url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;) .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;).addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;) .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;).build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;)); System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;)); System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;)); }Post方式提交String使用HTTP POST提交请求到服务。这个例子提交了一个markdown文档到web服务，以HTML方式渲染markdown。因为整个请求体都在内存中，因此避免使用此api提交大文档（大于1MB）。 public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { String postBody = &quot;&quot; + &quot;Releases\\n&quot; + &quot;--------\\n&quot; + &quot;\\n&quot; + &quot; * _1.0_ May 6, 2013\\n&quot; + &quot; * _1.1_ June 15, 2013\\n&quot; + &quot; * _1.2_ August 11, 2013\\n&quot;; Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string()); }Post方式提交流以流的方式POST提交请求体。请求体的内容由流写入产生。这个例子是流直接写入Okio的BufferedSink。你的程序可能会使用OutputStream，你可以使用BufferedSink.outputStream()来获取。 public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { RequestBody requestBody = new RequestBody() { @Override public MediaType contentType() { return MEDIA_TYPE_MARKDOWN; } @Override public void writeTo(BufferedSink sink) throws IOException { sink.writeUtf8(&quot;Numbers\\n&quot;); sink.writeUtf8(&quot;-------\\n&quot;); for (int i = 2; i &lt;= 997; i++) { sink.writeUtf8(String.format(&quot; * %s = %s\\n&quot;, i, factor(i))); } } private String factor(int n) { for (int i = 2; i &lt; n; i++) { int x = n / i; if (x * i == n) return factor(x) + &quot; × &quot; + i; } return Integer.toString(n); } }; Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string()); }Post方式提交文件以文件作为请求体是十分简单的。 public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { File file = new File(&quot;README.md&quot;); Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string()); }Post方式提交表单使用FormEncodingBuilder来构建和HTML标签相同效果的请求体。键值对将使用一种HTML兼容形式的URL编码来进行编码。 private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { RequestBody formBody = new FormEncodingBuilder() .add(&quot;search&quot;, &quot;Jurassic Park&quot;) .build(); Request request = new Request.Builder() .url(&quot;https://en.wikipedia.org/w/index.php&quot;) .post(formBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string()); }Post方式提交分块请求MultipartBuilder可以构建复杂的请求体，与HTML文件上传形式兼容。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如他的Content-Disposition。如果Content-Length和Content-Type可用的话，他们会被自动添加到请求头中。 private static final String IMGUR_CLIENT_ID = &quot;...&quot;; private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image RequestBody requestBody = new MultipartBuilder() .type(MultipartBuilder.FORM) .addPart( Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\\&quot;title\\&quot;&quot;), RequestBody.create(null, &quot;Square Logo&quot;)) .addPart( Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\\&quot;image\\&quot;&quot;), RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;))) .build(); Request request = new Request.Builder() .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID) .url(&quot;https://api.imgur.com/3/image&quot;) .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string()); }使用Gson来解析JSON响应Gson是一个在JSON和Java对象之间转换非常方便的api。这里我们用Gson来解析Github API的JSON响应。注意：ResponseBody.charStream()使用响应头Content-Type指定的字符集来解析响应体。默认是UTF-8。 private final OkHttpClient client = new OkHttpClient(); private final Gson gson = new Gson(); public void run() throws Exception { Request request = new Request.Builder() .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Gist gist = gson.fromJson(response.body().charStream(), Gist.class); for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) { System.out.println(entry.getKey()); System.out.println(entry.getValue().content); } } static class Gist { Map&lt;String, GistFile&gt; files; } static class GistFile { String content; }响应缓存为了缓存响应，你需要一个你可以读写的缓存目录，和缓存大小的限制。这个缓存目录应该是私有的，不信任的程序应不能读取缓存内容。 一个缓存目录同时拥有多个缓存访问是错误的。大多数程序只需要调用一次new OkHttp()，在第一次调用时配置好缓存，然后其他地方只需要调用这个实例就可以了。否则两个缓存示例互相干扰，破坏响应缓存，而且有可能会导致程序崩溃。 响应缓存使用HTTP头作为配置。你可以在请求头中添加Cache-Control: max-stale=3600 ,OkHttp缓存会支持。你的服务通过响应头确定响应缓存多长时间，例如使用Cache-Control: max-age=9600。 private final OkHttpClient client; public CacheResponse(File cacheDirectory) throws Exception { int cacheSize = 10 * 1024 * 1024; // 10 MiB Cache cache = new Cache(cacheDirectory, cacheSize); client = new OkHttpClient(); client.setCache(cache); } public void run() throws Exception { Request request = new Request.Builder() .url(&quot;http://publicobject.com/helloworld.txt&quot;) .build(); Response response1 = client.newCall(request).execute(); if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1); String response1Body = response1.body().string(); System.out.println(&quot;Response 1 response: &quot; + response1); System.out.println(&quot;Response 1 cache response: &quot; + response1.cacheResponse()); System.out.println(&quot;Response 1 network response: &quot; + response1.networkResponse()); Response response2 = client.newCall(request).execute(); if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2); String response2Body = response2.body().string(); System.out.println(&quot;Response 2 response: &quot; + response2); System.out.println(&quot;Response 2 cache response: &quot; + response2.cacheResponse()); System.out.println(&quot;Response 2 network response: &quot; + response2.networkResponse()); System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body)); }扩展在这一节还提到了下面一句： There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET. 我不是很懂cache，平时用到的也不多，所以把Google在Android Developers一段相关的解析放到这里吧。 Force a Network Response In some situations, such as after a user clicks a ‘refresh’ button, it may be necessary to skip the cache, and fetch data directly from the server. To force a full refresh, add the no-cache directive: connection.addRequestProperty(“Cache-Control”, “no-cache”); If it is only necessary to force a cached response to be validated by the server, use the more efficient max-age=0 instead: connection.addRequestProperty(“Cache-Control”, “max-age=0”); Force a Cache Response Sometimes you’ll want to show resources if they are available immediately, but not otherwise. This can be used so your application can show something while waiting for the latest data to be downloaded. To restrict a request to locally-cached resources, add the only-if-cached directive: try { connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;only-if-cached&quot;); InputStream cached = connection.getInputStream(); // the resource was cached! show it catch (FileNotFoundException e) { // the resource was not cached } }This technique works even better in situations where a stale response is better than no response. To permit stale cached responses, use the max-stale directive with the maximum staleness in seconds: int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks staleconnection.addRequestProperty(“Cache-Control”, “max-stale=” + maxStale); 以上信息来自：HttpResponseCache - Android SDK | Android Developers 取消一个Call使用Call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException。当call没有必要的时候，使用这个api可以节约网络资源。例如当用户离开一个应用时。不管同步还是异步的call都可以取消。 你可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call。 private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { Request request = new Request.Builder() .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay. .build(); final long startNanos = System.nanoTime(); final Call call = client.newCall(request); // Schedule a job to cancel the call in 1 second. executor.schedule(new Runnable() { @Override public void run() { System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f); call.cancel(); System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f); } }, 1, TimeUnit.SECONDS); try { System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f); Response response = call.execute(); System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;, (System.nanoTime() - startNanos) / 1e9f, response); } catch (IOException e) { System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;, (System.nanoTime() - startNanos) / 1e9f, e); } }超时没有响应时使用超时结束call。没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西。OkHttp支持连接，读取和写入超时。 private final OkHttpClient client; public ConfigureTimeouts() throws Exception { client = new OkHttpClient(); client.setConnectTimeout(10, TimeUnit.SECONDS); client.setWriteTimeout(10, TimeUnit.SECONDS); client.setReadTimeout(30, TimeUnit.SECONDS); } public void run() throws Exception { Request request = new Request.Builder() .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay. .build(); Response response = client.newCall(request).execute(); System.out.println(&quot;Response completed: &quot; + response); }每个call的配置使用OkHttpClient，所有的HTTP Client配置包括代理设置、超时设置、缓存设置。当你需要为单个call改变配置的时候，clone 一个OkHttpClient。这个api将会返回一个浅拷贝（shallow copy），你可以用来单独自定义。下面的例子中，我们让一个请求是500ms的超时、另一个是3000ms的超时。 private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { Request request = new Request.Builder() .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay. .build(); try { Response response = client.clone() // Clone to make a customized OkHttp for this request. .setReadTimeout(500, TimeUnit.MILLISECONDS) .newCall(request) .execute(); System.out.println(&quot;Response 1 succeeded: &quot; + response); } catch (IOException e) { System.out.println(&quot;Response 1 failed: &quot; + e); } try { Response response = client.clone() // Clone to make a customized OkHttp for this request. .setReadTimeout(3000, TimeUnit.MILLISECONDS) .newCall(request) .execute(); System.out.println(&quot;Response 2 succeeded: &quot; + response); } catch (IOException e) { System.out.println(&quot;Response 2 failed: &quot; + e); } }处理验证这部分和HTTP AUTH有关。 OkHttp会自动重试未验证的请求。当响应是401 Not Authorized时，Authenticator会被要求提供证书。Authenticator的实现中需要建立一个新的包含证书的请求。如果没有证书可用，返回null来跳过尝试。 public List&lt;Challenge&gt; challenges()Returns the authorization challenges appropriate for this response’s code. If the response code is 401 unauthorized, this returns the “WWW-Authenticate” challenges. If the response code is 407 proxy unauthorized, this returns the “Proxy-Authenticate” challenges. Otherwise this returns an empty list of challenges. 当需要实现一个Basic challenge， 使用Credentials.basic(username, password)来编码请求头。 private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { client.setAuthenticator(new Authenticator() { @Override public Request authenticate(Proxy proxy, Response response) { System.out.println(&quot;Authenticating for response: &quot; + response); System.out.println(&quot;Challenges: &quot; + response.challenges()); String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;); return response.request().newBuilder() .header(&quot;Authorization&quot;, credential) .build(); } @Override public Request authenticateProxy(Proxy proxy, Response response) { return null; // Null indicates no attempt to authenticate. } }); Request request = new Request.Builder() .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string()); }","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://okfood.vip/blog/tags/框架/"},{"name":"okhttp","slug":"okhttp","permalink":"https://okfood.vip/blog/tags/okhttp/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Android项目基础框架","slug":"Android项目基础框架","date":"2015-05-26T07:32:25.000Z","updated":"2019-09-06T07:26:05.889Z","comments":true,"path":"2015/05/26/Android项目基础框架/","link":"","permalink":"https://okfood.vip/blog/2015/05/26/Android项目基础框架/","excerpt":"","text":"本文初衷：由于很多Android项目的基础框架大致一致，于是针对主流的Android项目基础需求，严格按照MVC模式进行基类代码封装，以便可以将工程应用到任何一个新项目开发中，或者在代码重构时引入。框架抽取存在可优化性，以及针对具体场景可针对性低优化，由于代码量少使用起来非常简单，本文就简单介绍，可在底部直接下载源码，分分钟理解源码。欢迎提出意见或建议。 本项目所遵循的MVC模式MVC的概念就不多介绍了，请自行glgoo，或者百度。本项目的MVC模式图如下所示： 大致设计思路Activity作为V视图显示层，适配器adapter和数据中心manager作为C控制层，模式对象model及数据库持久化作为Model模型层。由manager作为数据获取的入口，负责数据的获取、处理，将处理好的数据通过IGetDataListener接口回调给适配器，适配器拿到数据填充视图，同时通过接口UIListener回调给Activity进行UI动作刷新。另外manager处理好的数据由继承类进行数据化持久或者内存缓存等操作。 IGetDataListener接口设计 工作在主线程，接口定义数据获取开始，获取中以及获取结束的方法，通过这三个方法将异步线程处理的数据进度以及具体内容抛到主线程。 public interface IGetDataListener&lt;T&gt; { /** 开始获取数据 */ public void startLoadData(); /** 获取到数据 从异步线程抛到这里 */ public void loadedData(Map&lt;String, List&lt;T&gt;&gt; datas); /** 结束获取数据 */ public void loadDataFinish(); } UIListener接口设计 工作在主线程，类似与IGetDataListener，接口定义数据获取开始，获取中以及获取结束的方法，通过这三个方法将适配器数据量的处理进度与结果通知给UI,让UI刷新所需的功能。 public static interface UIListener { /** 正在加载数据 */ void isLoading(); /** 总数据个数变化 */ void dataCountChanged(int count); /** 加载数据完毕 */ void loadFinished(); } 基类抽取封装 项目中对Android四大组件进行了必要的封装抽取基类，主要已抽象类加接口的模式设计，便于扩展以及开发。类图如下所示： Application启动入口 获取主线程的一些信息，包括全局上下文、主线程、主线程handler、主线程Looper、主线程Id,初始化未捕获异常管理器 ，以及异步加载其他初始化数据。 Activity基类 抽象基类，实现IBaseActivity接口，子类只需实现三个方法即可。 public interface IBaseActivity { /** * 绑定渲染视图的布局文件 * * @return 布局文件资源id */ public int bindLayout(); /** 初始化控件 */ public void findViews(final View v); /** * 业务处理操作（onCreate方法中被调用）&lt;br/&gt; * 数据逻辑及业务操作在此方法中&lt;br/&gt; * * @param mContext * 当前Activity对象上下文 */ public void doBusiness(Context context); } Fragment基类 抽象基类，实现IBaseFragment接口，使用V4包，兼容低版本。子类只需实现三个方法即可。 public interface IBaseFragment { /** * 绑定渲染视图的布局文件 * * @return 布局文件资源id */ public int bindLayout(); /** 初始化控件 (onCreateView方法中调用) */ public void findView(final View v); /** * 业务处理操作（onViewCreated方法中调用） * * @param mContext * 当前Activity对象上下文 */ public void doBusiness(Context context); } Service基类抽象基类 BroadcastReceiver基类抽象基类 ContentProvider基类抽象基类 Exception基类抽象基类 Model基类抽象基类 Adapter基类抽象基类，子类需调用refreshData()加载视图数据，在加载过程中会将进度通知到UI显示，该基类定义UIListener接口，该接口负责adapter与UI进行视图交互。 DataManager基类抽象基类，该基类定义IGetDataListener接口，该接口负责将异步数据交给主线程的adapter处理。 同时封装了注册、取消注册监听的接口，需要使用者进行注册和取消注册，调用asyncAquireData方法启动数据获取，具体获取数据由子类在requestGetData()方法中实现。并通过sendStartLoadDataMsgToUI()、sendLoadedDataMsgToUI()、sendLoadFinishMsgToUI()三个方法通知UI数据的处理进度。 项目源码下载—&gt; http://download.csdn.net/detail/lzj922718/8741051 github项目地址：https://github.com/Leo0618/Android-BaseProject 注：本文参考：AJava的主流开源框架demo","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://okfood.vip/blog/tags/框架/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"自定义控件viewbadger提示红点","slug":"自定义控件viewbadger提示红点","date":"2015-05-21T04:02:25.000Z","updated":"2019-09-06T07:21:53.056Z","comments":true,"path":"2015/05/21/自定义控件viewbadger提示红点/","link":"","permalink":"https://okfood.vip/blog/2015/05/21/自定义控件viewbadger提示红点/","excerpt":"","text":"使用场景：该控件主要用于需要提示的地方，比如显示消息个数红点提示、数量提示等等。 使用步骤： 创建对象 BadgeView badgeView = new BadgeView(MainActivity.this, targetView); 设置显示的文本信息 badgeView.setText(&quot;message&quot;); //文本显示内容 badgeView.setTextSize(12);//文本字体大小 badgeView.setTextColor(Color.BLUE);//文本内容的颜色 badgeView.setBadgePosition(BadgeView.POSITION_CENTER);//在目标视图上的位置，如居中 badgeView.setBadgeMargin(15, 10);//设置自定义提示视图与目标视图的horizontal，vertical 边距 badgeView.setBadgeBackgroundColor(Color.YELLOW);//文本背景色 显示自定义提示视图 badgeView.show()； Demo下载地址：http://download.csdn.net/detail/lzj922718/8712207","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://okfood.vip/blog/tags/自定义控件/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"自定义控件dialog","slug":"自定义控件dialog","date":"2015-05-18T04:10:22.000Z","updated":"2019-09-06T07:19:52.161Z","comments":true,"path":"2015/05/18/自定义控件dialog/","link":"","permalink":"https://okfood.vip/blog/2015/05/18/自定义控件dialog/","excerpt":"","text":"通过自定义的布局资源并添加了各类动画效果以及3D效果自定义dialog。单例模式自定义dialog入口类NiftyDialogBuilder，继承自Dialog并实现DialogInterface。使用比较简单，三步即可完成。 获取dialog实例 NiftyDialogBuilder dialogBuilder = NiftyDialogBuilder.getInstance(this); 设置动画效果 Effectstype effect = Effectstype.Shake 设置dialog信息及按钮点击事件 dialogBuilder .withTitle(&quot;Modal Dialog&quot;) //.withTitle(null) no title .withTitleColor(&quot;#FFFFFF&quot;) //def .withDividerColor(&quot;#11000000&quot;) //def .withMessage(&quot;This is a modal Dialog.&quot;) //.withMessage(null) no Msg .withMessageColor(&quot;#FFFFFFFF&quot;) //def | withMessageColor(int resid) .withDialogColor(&quot;#FFE74C3C&quot;) //def | withDialogColor(int resid) //def .withIcon(getResources().getDrawable(R.drawable.icon)) .isCancelableOnTouchOutside(true) //def | isCancelable(true) .withDuration(700) //def .withEffect(effect) //def Effectstype.Slidetop .withButton1Text(&quot;OK&quot;) //def gone .withButton2Text(&quot;Cancel&quot;) //def gone .setCustomView(R.layout.custom_view,v.getContext()) //.setCustomView(View or ResId,context) .setButton1Click(new View.OnClickListener() { @Override public void onClick(View v) { dialogBuilder.dismiss(); Toast.makeText(v.getContext(), &quot;i&#39;m btn1&quot;, Toast.LENGTH_SHORT).show(); } }) .setButton2Click(new View.OnClickListener() { @Override public void onClick(View v) { dialogBuilder.dismiss(); Toast.makeText(v.getContext(), &quot;i&#39;m btn2&quot;, Toast.LENGTH_SHORT).show(); } }) .show(); Demo下载地址： http://download.csdn.net/detail/lzj922718/8711517","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://okfood.vip/blog/tags/自定义控件/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"自定义控件ListViewForRefresh","slug":"自定义控件ListViewForRefresh","date":"2015-05-10T08:13:27.000Z","updated":"2019-09-06T07:20:04.139Z","comments":true,"path":"2015/05/10/自定义控件ListViewForRefresh/","link":"","permalink":"https://okfood.vip/blog/2015/05/10/自定义控件ListViewForRefresh/","excerpt":"","text":"功能描述： 支持自定义顶部视图，以视图+ListView方式展示 支持下拉刷新，可选择打开或关闭 支持加载更多，可选择打开或关闭 使用步骤 调用addCustomHeadView添加顶部视图，如轮播广告图等。 mListView.addCustomHeadView(View.inflate(this, R.layout.view_custom, null)); 调用enablePullDownRefresh和enableLoadMoreRefresh分别设置打开或关闭下拉刷新、加载更多. mListView.enablePullDownRefresh(true); mListView.enableLoadMoreRefresh(true); 调用setOnRefreshListener设置监听，在回调接口中实现数据加载，数据加载完成发送消息通知视图刷新. mListView.setOnRefreshListener(mListener); 监听mListener如下： private onRefreshListener mListener = new onRefreshListener() { @Override public void onPullDownRefresh() { // 异步加载数据 new Thread(new Runnable() { @Override public void run() { SystemClock.sleep(3000); mData.add(0, &quot;test--data--&gt;newdata&quot;); mHandler.obtainMessage(WHAT_DATA_LOAD_FINISH).sendToTarget(); } }).start(); } @Override public void onLoadMoreRefresh() { // 异步加载数据 new Thread(new Runnable() { @Override public void run() { SystemClock.sleep(3000); mData.add(&quot;test--data--&gt;newdata&quot;); mHandler.obtainMessage(WHAT_DATA_LOAD_FINISH).sendToTarget(); } }).start(); } }; 接收到消息后关闭刷新视图 private Handler mHandler = new Handler(Looper.getMainLooper()) { public void handleMessage(android.os.Message msg) { switch (msg.what) { case WHAT_DATA_LOAD_FINISH: mListView.FinishRefesh(); mAdapter.notifyDataSetChanged(); break; } }; } 效果图： 下拉刷新 加载更多 直接上代码—&gt;自定义RefreshListView code: package com.leo.demo; import java.text.SimpleDateFormat; import java.util.Date; import android.annotation.SuppressLint; import android.content.Context; import android.util.AttributeSet; import android.util.Log; import android.view.MotionEvent; import android.view.View; import android.view.animation.Animation; import android.view.animation.RotateAnimation; import android.widget.AbsListView; import android.widget.AbsListView.OnScrollListener; import android.widget.ImageView; import android.widget.LinearLayout; import android.widget.ListView; import android.widget.ProgressBar; import android.widget.TextView; public class RefreshListView extends ListView implements OnScrollListener { private static final String TAG = &quot;RefreshListView&quot;; private static final Boolean DEBUG = false; /** 头控件整个布局(包含下拉刷新和用户自定义需要添加的控件) */ private LinearLayout mHeadView; /** 下拉刷新控件 */ private View mPullDownHeadView; /** 下拉刷新布局高度 */ private int mPullDownHeadViewHeigth; /** 触摸按下的Y坐标 */ private int downY = -1; /** 下拉刷新状态 */ private static final int STATE_PULL_DOWN_REFRESH = 0x000; /** 释放刷新状态 */ private static final int STATE_RELEASE_REFRESH = 0x001; /** 正在刷新状态 */ private static final int STATE_REFRESHING = 0x002; /** 当前刷新状态 */ private int currentState = STATE_PULL_DOWN_REFRESH;// 默认是下拉刷新状态 /** 向上旋转动画 */ private RotateAnimation upRa; /** 向下旋转动画 */ private RotateAnimation downRa; /** 下拉刷新 动画箭头 */ private ImageView mRefreshArrow; /** 下拉刷新 进度环 */ private ProgressBar mRefreshProgressBar; /** 下拉刷新 状态文字显示 */ private TextView mRefreshState; /** 下拉刷新 上次刷新时间 */ private TextView mRefreshDate; /** 用户自定义的需要加在头部的view */ private View mCustomView; /** ListView左上角在屏幕上的位置Y */ private int mListViewHeigthOnScreen = -1; /** 刷新列表回调监听器 */ private onRefreshListener mListener; /** 底部加载更多控件 */ private View mLoadMoreView; /** 底部加载更多控件的测量高度 */ private int mLoadMoreViewHeight; /** 是否加载更多 */ private boolean isLoadMore = false; /** 是否启用下拉刷新 (默认关闭下拉刷新) */ private boolean isEnablePullDownRefresh = false; /** 是否启用加载更多 (默认关闭加载更多) */ private boolean isEnableLoadMoreRefresh = false; public RefreshListView(Context context) { super(context); initHeadView(); initFootView(); } public RefreshListView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); initHeadView(); initFootView(); } public RefreshListView(Context context, AttributeSet attrs) { super(context, attrs); initHeadView(); initFootView(); } /** 初始化底部加载更多控件 */ private void initFootView() { mLoadMoreView = View.inflate(getContext(), R.layout.refresh_load_more, null); mLoadMoreView.measure(0, 0); mLoadMoreViewHeight = mLoadMoreView.getMeasuredHeight(); mLoadMoreView.setPadding(0, -mLoadMoreViewHeight, 0, 0); this.addFooterView(mLoadMoreView); this.setOnScrollListener(this);// 给当前Listview设置一个滑动的监听事件 } /** 初始化头部下拉刷新控件 */ private void initHeadView() { mHeadView = (LinearLayout) View.inflate(getContext(), R.layout.refresh_pull_down, null); mPullDownHeadView = mHeadView.findViewById(R.id.ll_pull_down_refresh_root); mRefreshArrow = (ImageView) mHeadView.findViewById(R.id.iv_pull_dowd_refresh_arrow); mRefreshProgressBar = (ProgressBar) mHeadView.findViewById(R.id.pb_pull_dowd_refresh_progressbar); mRefreshState = (TextView) mHeadView.findViewById(R.id.tv_pull_dowd_refresh_state_desc); mRefreshDate = (TextView) mHeadView.findViewById(R.id.tv_pull_dowd_refresh_date); mRefreshDate.setText(&quot;上次刷新:&quot; + getCurentTime());// 设置默认显示上次刷新时间 mPullDownHeadView.measure(0, 0);// 测量，以获取测量高度 mPullDownHeadViewHeigth = mPullDownHeadView.getMeasuredHeight(); mPullDownHeadView.setPadding(0, -mPullDownHeadViewHeigth, 0, 0);// 默认隐藏头控件 this.addHeaderView(mHeadView);// 添加到头控件中 initAnimation();// 初始化箭头动画 } /** 初始化头部控件中箭头的旋转动画 */ private void initAnimation() { upRa = new RotateAnimation(0, -180, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); upRa.setDuration(500); upRa.setFillAfter(true); downRa = new RotateAnimation(-180, -360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); downRa.setDuration(500); downRa.setFillAfter(true); } /** 在头部控件内添加用户自定义的view */ public void addCustomHeadView(View v) { this.mCustomView = v; mHeadView.addView(v); } @SuppressLint(&quot;ClickableViewAccessibility&quot;) @Override public boolean onTouchEvent(MotionEvent ev) { switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: downY = (int) ev.getY(); break; case MotionEvent.ACTION_MOVE: if (downY == -1) { downY = (int) ev.getY(); } // 如果是没有启用下拉刷新 则跳出循环 if (!isEnablePullDownRefresh) { break; } // 如果当前是正在刷新中，则跳出循环 if (currentState == STATE_REFRESHING) { break; } // 判断添加的顶部View是否完全显示了, 如果没有完全显示,跳出switch语句, 执行父元素的touch事件. if (mCustomView != null) { int[] location = new int[2];// 0位是x轴的值, 1位是y轴的值 // 获取Listview在屏幕中y轴的值. if (mListViewHeigthOnScreen == -1) { this.getLocationOnScreen(location); mListViewHeigthOnScreen = location[1]; showLog(&quot;ListView--Y:&quot; + mListViewHeigthOnScreen); } // 获取mCustomHeaderView在屏幕y轴的值. mCustomView.getLocationOnScreen(location); int mCustomViewHeigthOnScreen = location[1]; showLog(&quot;mCustomView--Y:&quot; + mCustomViewHeigthOnScreen); if (mCustomViewHeigthOnScreen &lt; mListViewHeigthOnScreen) { break;// 未完全显示自定义的view,jump out } } int moveY = (int) ev.getY(); int dy = moveY - downY; if (dy &gt; 0 &amp;&amp; getFirstVisiblePosition() == 0) { // 如果是下拉，并且当前第一个可视条目是列表中的第一个，可以拉出头控件 int paddingTop = -mPullDownHeadViewHeigth + dy; if (paddingTop &gt; 0 &amp;&amp; currentState != STATE_RELEASE_REFRESH) { // 完全拉出来了，并且当前状态不是释放刷新，则切换到释放刷新状态 currentState = STATE_RELEASE_REFRESH; changeRefreshState(); } else if (paddingTop &lt; 0 &amp;&amp; currentState != STATE_PULL_DOWN_REFRESH) { // 没有完全拉出来，并且当前状态不是下拉刷新，则切换到下拉刷新状态 currentState = STATE_PULL_DOWN_REFRESH; changeRefreshState(); } mPullDownHeadView.setPadding(0, paddingTop, 0, 0); return true; } break; case MotionEvent.ACTION_UP: downY = -1; if (currentState == STATE_PULL_DOWN_REFRESH) { // 如果当前是下拉刷新状态,则直接隐藏 mPullDownHeadView.setPadding(0, -mPullDownHeadViewHeigth, 0, 0); } else if (currentState == STATE_RELEASE_REFRESH) { // 如果当前是释放刷新状态，则切换到正在刷新 currentState = STATE_REFRESHING; changeRefreshState(); mPullDownHeadView.setPadding(0, 0, 0, 0); // 回调用户处理操作 if (mListener != null) { mListener.onPullDownRefresh(); } } break; } return super.onTouchEvent(ev); } /** 切换当前头控件显示的刷新状态 */ private void changeRefreshState() { switch (currentState) { case STATE_PULL_DOWN_REFRESH: // 下拉刷新 mRefreshArrow.startAnimation(downRa); mRefreshState.setText(&quot;下拉刷新&quot;); break; case STATE_RELEASE_REFRESH: // 释放刷新 mRefreshArrow.startAnimation(upRa); mRefreshState.setText(&quot;释放刷新&quot;); break; case STATE_REFRESHING: // 正在刷新 mRefreshArrow.clearAnimation(); mRefreshArrow.setVisibility(View.INVISIBLE); mRefreshProgressBar.setVisibility(View.VISIBLE); mRefreshState.setText(&quot;正在刷新中...&quot;); break; } } /** 当刷新完成后调用此方法，隐藏头部上拉刷新和底部加在更多 */ public void FinishRefesh() { if (isLoadMore) { // 隐藏加载更多,复位变量 isLoadMore = false; mLoadMoreView.setPadding(0, -mLoadMoreViewHeight, 0, 0); } else { // 隐藏上拉刷新,复位变量 mPullDownHeadView.setPadding(0, -mPullDownHeadViewHeigth, 0, 0); currentState = STATE_PULL_DOWN_REFRESH; mRefreshState.setText(&quot;下拉刷新&quot;); mRefreshArrow.setVisibility(View.VISIBLE); mRefreshProgressBar.setVisibility(View.INVISIBLE); mRefreshDate.setText(&quot;上次刷新:&quot; + getCurentTime()); } } /** 获取当前时间, 格式为: 1990-09-09 09:09:09 */ @SuppressLint(&quot;SimpleDateFormat&quot;) private String getCurentTime() { SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); return format.format(new Date()); } /** 下拉刷新回调接口 */ public interface onRefreshListener { /** 下拉刷新 加载数据处理 */ void onPullDownRefresh(); /** 加载更多 加载数据处理 */ void onLoadMoreRefresh(); } /** 设置下拉刷新回调监听器 */ public void setOnRefreshListener(onRefreshListener listener) { this.mListener = listener; } /** 监听滑动状态，设置加载更多 */ @Override public void onScrollStateChanged(AbsListView view, int scrollState) { if (!isEnableLoadMoreRefresh) { return;// false 关闭加载更多，直接返回 } if (currentState == SCROLL_STATE_IDLE || currentState == SCROLL_STATE_FLING) { if (getLastVisiblePosition() == getCount() - 1 &amp;&amp; !isLoadMore) { // 滑动到listview最后一个条目,显示加载更多 isLoadMore = true; mLoadMoreView.setPadding(0, 0, 0, 0);// 显示加载更多控件 setSelection(getCount());// 显示最后一个条目 // 处理用户的回调操作 if (mListener != null) { mListener.onLoadMoreRefresh(); } } } } @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) { } /** 是否启用下拉刷新 */ public void enablePullDownRefresh(boolean isEnable) { this.isEnablePullDownRefresh = isEnable; } /** 是否启用加载更多 */ public void enableLoadMoreRefresh(boolean isEnable) { this.isEnableLoadMoreRefresh = isEnable; } /** 打印log信息 */ private static void showLog(String msg) { if (DEBUG) { Log.e(TAG, msg); } } }","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"https://okfood.vip/blog/tags/自定义控件/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Volley框架原理分析","slug":"Volley框架原理分析","date":"2015-05-04T06:03:17.000Z","updated":"2019-09-06T07:11:03.136Z","comments":true,"path":"2015/05/04/Volley框架原理分析/","link":"","permalink":"https://okfood.vip/blog/2015/05/04/Volley框架原理分析/","excerpt":"","text":"1. 功能介绍1.1. VolleyVolley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。 名字由来：a burst or emission of many things or a large amount at once发布演讲时候的配图 从名字由来和配图中无数急促的火箭可以看出 Volley 的特点：特别适合数据量小，通信频繁的网络操作。（个人认为 Android 应用中绝大多数的网络操作都属于这种类型）。 1.2 Volley 的主要特点(1). 扩展性强。Volley 中大多是基于接口的设计，可配置性强。(2). 一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。(3). 默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现，这两者的区别及优劣在4.2.1 Volley中具体介绍。(4). 提供简便的图片加载工具。 2. 总体设计2.1. 总体设计图 上面是 Volley 的总体设计图，主要是通过两种Diapatch Thread不断从RequestQueue中取出请求，根据是否已缓存调用Cache或Network这两类数据获取接口之一，从内存缓存或是服务器取得请求的数据，然后交由ResponseDelivery去做结果分发及回调处理。 2.2. Volley 中的概念简单介绍一些概念，在详细设计中会仔细介绍。Volley 的调用比较简单，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue后，只需要往这个RequestQueue不断 add Request 即可。 Volley：Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue。 Request：表示一个请求的抽象类。StringRequest、JsonRequest、ImageRequest 都是它的子类，表示某种类型的请求。 RequestQueue：表示请求队列，里面包含一个CacheDispatcher(用于处理走缓存请求的调度线程)、NetworkDispatcher数组(用于处理走网络请求的调度线程)，一个ResponseDelivery(返回结果分发接口)，通过 start() 函数启动时会启动CacheDispatcher和NetworkDispatchers。 CacheDispatcher：一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。 NetworkDispatcher：一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。 ResponseDelivery：返回结果分发接口，目前只有基于ExecutorDelivery的在入参 handler 对应线程内进行分发。 HttpStack：处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的HurlStack和 基于 Apache HttpClient 的HttpClientStack。 Network：调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。 Cache：缓存请求结果，Volley 默认使用的是基于 sdcard 的DiskBasedCache。NetworkDispatcher得到请求结果后判断是否需要存储在 Cache，CacheDispatcher会从 Cache 中取缓存结果。 3. 流程图Volley 请求流程图 上图是 Volley 请求时的流程图，在 Volley 的发布演讲中给出，我在这里将其用中文重新画出。 4. 详细设计4.1 类关系图 这是 Volley 框架的主要类关系图 图中红色圈内的部分，组成了 Volley 框架的核心，围绕 RequestQueue 类，将各个功能点以组合的方式结合在了一起。各个功能点也都是以接口或者抽象类的形式提供。红色圈外面的部分，在 Volley 源码中放在了toolbox包中，作为 Volley 为各个功能点提供的默认的具体实现。通过类图我们看出， Volley 有着非常好的拓展性。通过各个功能点的接口，我们可以给出自定义的，更符合我们需求的具体实现。 多用组合，少用继承；针对接口编程，不针对具体实现编程。 优秀框架的设计，令人叫绝，受益良多。 4.2 核心类功能介绍4.2.1 Volley.java这个和 Volley 框架同名的类，其实是个工具类，作用是构建一个可用于添加网络请求的RequestQueue对象。 (1). 主要函数 Volley.java 有两个重载的静态方法。 public static RequestQueue newRequestQueue(Context context) public static RequestQueue newRequestQueue(Context context, HttpStack stack) 第一个方法的实现调用了第二个方法，传 HttpStack 参数为 null。第二个方法中，如果 HttpStatck 参数为 null，则如果系统在 Gingerbread 及之后(即 API Level &gt;= 9)，采用基于 HttpURLConnection 的 HurlStack，如果小于 9，采用基于 HttpClient 的 HttpClientStack。 if (stack == null) { if (Build.VERSION.SDK_INT &gt;= 9) { stack = new HurlStack(); } else { stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); } } 得到了 HttpStack,然后通过它构造一个代表网络（Network）的具体实现BasicNetwork。接着构造一个代表缓存（Cache）的基于 Disk 的具体实现DiskBasedCache。最后将网络（Network）对象和缓存（Cache）对象传入构建一个 RequestQueue，启动这个 RequestQueue，并返回。 Network network = new BasicNetwork(stack); RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); return queue; 我们平时大多采用Volly.newRequestQueue(context)的默认实现，构建RequestQueue。通过源码可以看出，我们可以抛开 Volley 工具类构建自定义的RequestQueue，采用自定义的HttpStatck，采用自定义的Network实现，采用自定义的Cache实现等来构建RequestQueue。优秀框架的高可拓展性的魅力来源于此啊 (2). HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。 (3). 关于 User Agent通过代码我们发现如果是使用 AndroidHttpClient，Volley 还会将请求头中的 User-Agent 字段设置为 App 的 ${packageName}/${versionCode}，如果异常则使用 “volley/0”，不过这个获取 User-Agent 的操作应该放到 if else 内部更合适。而对于 HttpURLConnection 却没有任何操作，为什么呢？如果用 Fiddler 或 Charles 对数据抓包我们会发现，我们会发现 HttpURLConnection 默认是有 User-Agent 的，类似： Dalvik/1.6.0 (Linux; U; Android 4.1.1; Google Nexus 4 - 4.1.1 - API 16 - 768x1280_1 Build/JRO03S) 经常用 WebView 的同学会也许会发现似曾相识，是的，WebView 默认的 User-Agent 也是这个。实际在请求发出之前，会检测 User-Agent 是否为空，如果不为空，则加上系统默认 User-Agent。在 Android 2.1 之后，我们可以通过 String userAgent = System.getProperty(&quot;http.agent&quot;); 得到系统默认的 User-Agent，Volley 如果希望自定义 User-Agent，可在自定义 Request 中重写 getHeaders() 函数 @Override public Map&lt;String, String&gt; getHeaders() throws AuthFailureError { // self-defined user agent Map&lt;String, String&gt; headerMap = new HashMap&lt;String, String&gt;(); headerMap.put(&quot;User-Agent&quot;, &quot;android-open-project-analysis/1.0&quot;); return headerMap; } 4.2.2 Request.java代表一个网络请求的抽象类。我们通过构建一个Request类的非抽象子类(StringRequest、JsonRequest、ImageRequest或自定义)对象，并将其加入到·RequestQueue·中来完成一次网络请求操作。Volley 支持 8 种 Http 请求方式 GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCHRequest 类中包含了请求 url，请求请求方式，请求 Header，请求 Body，请求的优先级等信息。 因为是抽象类，子类必须重写的两个方法。 abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response); 子类重写此方法，将网络返回的原生字节内容，转换成合适的类型。此方法会在工作线程中被调用。 abstract protected void deliverResponse(T response); 子类重写此方法，将解析成合适类型的内容传递给它们的监听回调。 以下两个方法也经常会被重写 public byte[] getBody() 重写此方法，可以构建用于 POST、PUT、PATCH 请求方式的 Body 内容。 protected Map&lt;String, String&gt; getParams() 在上面getBody函数没有被重写情况下，此方法的返回值会被 key、value 分别编码后拼装起来转换为字节码作为 Body 内容。 4.2.3 RequestQueue.javaVolley 框架的核心类，将请求Request加入到一个运行的RequestQueue中，来完成请求操作。 (1). 主要成员变量RequestQueue 中维护了两个基于优先级的 Request 队列，缓存请求队列和网络请求队列。放在缓存请求队列中的 Request，将通过缓存获取数据；放在网络请求队列中的 Request，将通过网络获取数据。 private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;(); private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;(); 维护了一个正在进行中，尚未完成的请求集合。 private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;(); 维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。 private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;(); (2). 启动队列创建出 RequestQueue 以后，调用 start 方法，启动队列。 /** * Starts the dispatchers in this queue. */ public void start() { stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) { NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); } } start 方法中，开启一个缓存调度线程CacheDispatcher和 n 个网络调度线程NetworkDispatcher，这里 n 默认为4，存在优化的余地，比如可以根据 CPU 核数以及网络类型计算更合适的并发数。缓存调度线程不断的从缓存请求队列中取出 Request 去处理，网络调度线程不断的从网络请求队列中取出 Request 去处理。 (3). 加入请求public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request); 流程图如下： (4). 请求完成void finish(Request&lt;?&gt; request) Request 请求结束 (1). 首先从正在进行中请求集合mCurrentRequests中移除该请求。(2). 然后查找请求等待集合mWaitingRequests中是否存在等待的请求，如果存在，则将等待队列移除，并将等待队列所有的请求添加到缓存请求队列中，让缓存请求处理线程CacheDispatcher自动处理。 (5). 请求取消public void cancelAll(RequestFilter filter) public void cancelAll(final Object tag) 取消当前请求集合中所有符合条件的请求。filter 参数表示可以按照自定义的过滤器过滤需要取消的请求。tag 表示按照Request.setTag设置好的 tag 取消请求，比如同属于某个 Activity 的。 4.2.4 CacheDispatcher.java一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery 去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。 (1). 成员变量BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue 缓存请求队列BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue 网络请求队列Cache mCache 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存ResponseDelivery mDelivery 请求结果传递类 (2). 处理流程图 4.2.5 NetworkDispatcher.java一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。 (1). 成员变量BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue 网络请求队列Network mNetwork 网络类，代表了一个可以执行请求的网络Cache mCache 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存ResponseDelivery mDelivery 请求结果传递类，可以传递请求的结果或者错误到调用者 (2). 处理流程图 4.2.6 Cache.java缓存接口，代表了一个可以获取请求结果，存储请求结果的缓存。 (1). 主要方法：public Entry get(String key); 通过 key 获取请求的缓存实体public void put(String key, Entry entry); 存入一个请求的缓存实体public void remove(String key); 移除指定的缓存实体public void clear(); 清空缓存 (2). 代表缓存实体的内部类 Entry成员变量和方法byte[] data 请求返回的数据（Body 实体）String etag Http 响应首部中用于缓存新鲜度验证的 ETaglong serverDate Http 响应首部中的响应产生时间long ttl 缓存的过期时间long softTtl 缓存的新鲜时间Map&lt;String, String&gt; responseHeaders 响应的 Headersboolean isExpired() 判断缓存是否过期，过期缓存不能继续使用boolean refreshNeeded() 判断缓存是否新鲜，不新鲜的缓存需要发到服务端做新鲜度的检测 4.2.7 DiskBasedCache.java继承 Cache 类，基于 Disk 的缓存实现类。 (1). 主要方法：public synchronized void initialize() 初始化，扫描缓存目录得到所有缓存数据摘要信息放入内存。public synchronized Entry get(String key) 从缓存中得到数据。先从摘要信息中得到摘要信息，然后读取缓存数据文件得到内容。public synchronized void put(String key, Entry entry) 将数据存入缓存内。先检查缓存是否会满，会则先删除缓存中部分数据，然后再新建缓存文件。private void pruneIfNeeded(int neededSpace) 检查是否能再分配 neededSpace 字节的空间，如果不能则删除缓存中部分数据。public synchronized void clear() 清空缓存。public synchronized void remove(String key) 删除缓存中某个元素。 (2). CacheHeader 类CacheHeader 是缓存文件摘要信息，存储在缓存文件的头部，与上面的Cache.Entry相似。 4.2.8 NoCache.java继承 Cache 类，不做任何操作的缓存实现类，可将它作为构建RequestQueue的参数以实现一个不带缓存的请求队列。 4.2.9 Network.java代表网络的接口，处理网络请求。唯一的方法，用于执行特定请求。 public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError; 4.2.10 NetworkResponse.javaNetwork中方法 performRequest 的返回值，Request的 parseNetworkResponse(…) 方法入参，是 Volley 中用于内部 Response 转换的一级。封装了网络请求响应的 StatusCode，Headers 和 Body 等。 (1). 成员变量int statusCode Http 响应状态码byte[] data Body 数据Map&lt;String, String&gt; headers 响应 Headersboolean notModified 表示是否为 304 响应long networkTimeMs 请求耗时 (2). Volley 的内部 Response 转换流程图从上到下表示从得到数据后一步步的处理，箭头旁的注释表示该步处理后的实体类。 4.2.11 BasicNetwork.java实现 Network，Volley 中默认的网络接口实现类。调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。主要实现了以下功能：(1). 利用 HttpStack 执行网络请求。(2). 如果 Request 中带有实体信息，如 Etag,Last-Modify 等，则进行缓存新鲜度的验证，并处理 304（Not Modify）响应。(3). 如果发生超时，认证失败等错误，进行重试操作，直到成功、抛出异常(不满足重试策略等)结束。 4.2.12 HttpStack.java用于处理 Http 请求，返回请求结果的接口。目前 Volley 中的实现有基于 HttpURLConnection 的 HurlStack 和 基于 Apache HttpClient 的 HttpClientStack。唯一方法，执行请求 public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError; 执行 Request 代表的请求，第二个参数表示发起请求之前，添加额外的请求 Headers。 4.2.13 HttpClientStack.java实现 HttpStack 接口，利用 Apache 的 HttpClient 进行各种请求方式的请求。基本就是 org.apache.http 包下面相关类的常见用法，不做详解，不过与下面 HttpURLConnection 做下对比就能发现 HttpURLConnection 的 API 相对简单的多。 4.2.14 HurlStack.java实现 HttpStack 接口，利用 Java 的 HttpURLConnection 进行各种请求方式的请求。 4.2.15 Response.java封装了经过解析后的数据，用于传输。并且有两个内部接口 Listener 和 ErrorListener 分别可表示请求失败和成功后的回调。Response 的构造函数被私有化，而通过两个函数名更易懂的静态方法构建对象。 4.2.16 ByteArrayPool.javabyte[] 的回收池，用于 byte[] 的回收再利用，减少了内存的分配和回收。主要通过一个元素长度从小到大排序的ArrayList作为 byte[] 的缓存，另有一个按使用时间先后排序的ArrayList属性用于缓存满时清理元素。 public synchronized void returnBuf(byte[] buf) 将用过的 byte[] 回收，根据 byte[] 长度按照从小到大的排序将 byte[] 插入到缓存中合适位置。 public synchronized byte[] getBuf(int len) 获取长度不小于 len 的 byte[]，遍历缓存，找出第一个长度大于传入参数len的 byte[]，并返回；如果最终没有合适的byte[]，new 一个返回。 private synchronized void trim() 当缓存的 byte 超过预先设置的大小时，按照先进先出的顺序删除最早的 byte[]。 4.2.17 PoolingByteArrayOutputStream.java继承ByteArrayOutputStream，原始 ByteArrayOutputStream 中用于接受写入 bytes 的 buf，每次空间不足时便会 new 更大容量的 byte[]，而 PoolingByteArrayOutputStream 使用了 ByteArrayPool 作为 Byte[] 缓存来减少这种操作，从而提高性能。 4.2.18 HttpHeaderParser.javaHttp header 的解析工具类，在 Volley 中主要作用是用于解析 Header 从而判断返回结果是否需要缓存，如果需要返回 Header 中相关信息。有三个方法 public static long parseDateAsEpoch(String dateStr) 解析时间，将 RFC1123 的时间格式，解析成 epoch 时间 public static String parseCharset(Map&lt;String, String&gt; headers) 解析编码集，在 Content-Type 首部中获取编码集，如果没有找到，默认返回 ISO-8859-1 public static Cache.Entry parseCacheHeaders(NetworkResponse response) 比较重要的方法，通过网络响应中的缓存控制 Header 和 Body 内容，构建缓存实体。如果 Header 的 Cache-Control 字段含有no-cache或no-store表示不缓存，返回 null。(1). 根据 Date 首部，获取响应生成时间(2). 根据 ETag 首部，获取响应实体标签(3). 根据 Cache－Control 和 Expires 首部，计算出缓存的过期时间，和缓存的新鲜度时间 两点需要说明下：1.没有处理Last-Modify首部，而是处理存储了Date首部，并在后续的新鲜度验证时，使用Date来构建If-Modified-Since。这与 Http 1.1 的语义有些违背。2.计算过期时间，Cache－Control 首部优先于 Expires 首部。 4.2.19 RetryPolicy.java重试策略接口有三个方法： public int getCurrentTimeout(); 获取当前请求用时（用于Log） public int getCurrentRetryCount(); 获取已经重试的次数（用于Log） public void retry(VolleyError error) throws VolleyError; 确定是否重试，参数为这次异常的具体信息。在请求异常时此接口会被调用，可在此函数实现中抛出传入的异常表示停止重试。 4.2.20 DefaultRetryPolicy.java实现 RetryPolicy，Volley 默认的重试策略实现类。主要通过在 retry(…) 函数中判断重试次数是否达到上限确定是否继续重试。其中mCurrentTimeoutMs变量表示已经重试次数。mBackoffMultiplier表示每次重试之前的 timeout 该乘以的因子。mCurrentTimeoutMs变量表示当前重试的 timeout 时间，会以mBackoffMultiplier作为因子累计前几次重试的 timeout。 4.2.21 ResponseDelivery.java请求结果的传输接口，用于传递请求结果或者请求错误。有三个方法： public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response); 此方法用于传递请求结果，request 和 response 参数分别表示请求信息和返回结果信息。 public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable); 此方法用于传递请求结果，并在完成传递后执行 Runnable。 public void postError(Request&lt;?&gt; request, VolleyError error); 此方法用于传输请求错误。 4.2.22 ExecutorDelivery.java请求结果传输接口具体实现类。在 Handler 对应线程中传输缓存调度线程或者网络调度线程中产生的请求结果或请求错误，会在请求成功的情况下调用 Request.deliverResponse(…) 函数，失败时调用 Request.deliverError(…) 函数。 4.2.23 StringRequest.java继承 Request 类,代表了一个返回值为 String 的请求。将网络返回的结果数据解析为 String 类型。通过构造函数的 listener 传参，支持请求成功后的 onResponse(…) 回调。 4.2.24 JsonRequest.java抽象类，继承自 Request，代表了 body 为 JSON 的请求。提供了构建 JSON 请求参数的方法。 4.2.25 JsonObjectRequest.java继承自 JsonRequest，将网络返回的结果数据解析为 JSONObject 类型。 4.2.26 JsonArrayRequest.java继承自 JsonRequest，将网络返回的结果数据解析为 JSONArray 类型。 4.2.27 ImageRequest.java继承 Request 类，代表了一个返回值为 Image 的请求。将网络返回的结果数据解析为 Bitmap 类型。可以设置图片的最大宽度和最大高度，并计算出合适尺寸返回。每次最多解析一张图片防止 OOM。 4.2.28 ImageLoader.java封装了 ImageRequst 的方便使用的图片加载工具类。 1.可以设置自定义的ImageCache，可以是内存缓存，也可以是 Disk 缓存，将获取的图片缓存起来，重复利用，减少请求。2.可以定义图片请求过程中显示的图片和请求失败后显示的图片。3.相同请求（相同地址，相同大小）只发送一个，可以避免重复请求。// TODO 4.2.29 NetworkImageView.java利用 ImageLoader，可以加载网络图片的 ImageView有三个公开的方法： public void setDefaultImageResId(int defaultImage) 设置默认图片，加载图片过程中显示。 public void setErrorImageResId(int errorImage) 设置错误图片，加载图片失败后显示。 public void setImageUrl(String url, ImageLoader imageLoader) 设置网络图片的 Url 和 ImageLoader，将利用这个 ImageLoader 去获取网络图片。 如果有新的图片加载请求，会把这个ImageView上旧的加载请求取消。 4.2.30 ClearCacheRequest.java用于人为清空 Http 缓存的请求。添加到 RequestQueue 后能很快执行，因为优先级很高，为Priority.IMMEDIATE。并且清空缓存的方法mCache.clear()写在了isCanceled()方法体中，能最早的得到执行。 ClearCacheRequest 的写法不敢苟同，目前看来唯一的好处就是可以将清空缓存操作也当做一个请求。而在isCanceled()中做清空操作本身就造成了歧义，不看源码没人知道在NetworkDispatcher run 方法循环的过程中，isCanceled()这个读操作竟然做了可能造成缓存被清空。只能跟源码的解释一样当做一个 Hack 操作。 4.2.31 Authenticator.java身份认证接口，用于基本认证或者摘要认证。这个类是 Volley 用于和身份验证打通的接口，比如 OAuth，不过目前的使用不是特别广泛和 Volley 的内部结合也不是特别紧密。 4.2.32 AndroidAuthenticator.java继承 Authenticator，基于 Android AccountManager 的认证交互实现类。 4.2.33 VolleyLog.javaVolley 的 Log 工具类。 4.2.34 VolleyError.javaVolley 中所有错误异常的父类，继承自 Exception，可通过此类设置和获取 NetworkResponse 或者请求的耗时。 4.2.35 AuthFailureError.java继承自 VolleyError，代表请求认证失败错误，如 RespondeCode 的 401 和 403。 4.2.36 NetworkError.java继承自 VolleyError，代表网络错误。 4.2.37 ParseError.java继承自 VolleyError，代表内容解析错误。 4.2.38 ServerError.java继承自 VolleyError，代表服务端错误。 4.2.39 TimeoutError.java继承自 VolleyError，代表请求超时错误。 4.2.40 NoConnectionError.java继承自NetworkError，代表无法建立连接错误。 5. 杂谈5.1 关于 Http 缓存Volley 构建了一套相对完整的符合 Http 语义的缓存机制。优点和特点(1). 根据Cache-Control和Expires首部来计算缓存的过期时间。如果两个首部都存在情况下，以Cache-Control为准。(2). 利用If-None-Match和If-Modified-Since对过期缓存或者不新鲜缓存，进行请求再验证，并处理 304 响应，更新缓存。(3). 默认的缓存实现，将缓存以文件的形式存储在 Disk，程序退出后不会丢失。 我个人认为的不足之处缓存的再验证方面，在构建If-Modified-Since请求首部时，Volley 使用了服务端响应的Date首部，没有使用Last-Modified首部。整个框架没有使用Last-Modified首部。这与 Http 语义不符。 private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) { // If there&#39;s no cache entry, we&#39;re done. if (entry == null) { return; } if (entry.etag != null) { headers.put(&quot;If-None-Match&quot;, entry.etag); } if (entry.serverDate &gt; 0) { Date refTime = new Date(entry.serverDate); headers.put(&quot;If-Modified-Since&quot;, DateUtils.formatDate(refTime)); } } 服务端根据请求时通过If-Modified-Since首部传过来的时间，判断资源文件是否在If-Modified-Since时间 以后 有改动，如果有改动，返回新的请求结果。如果没有改动，返回 304 not modified。Last-Modified代表了资源文件的最后修改时间。通常使用这个首部构建If-Modified-Since的时间。Date代表了响应产生的时间，正常情况下Date时间在Last-Modified时间之后。也就是Date&gt;=Last-Modified。通过以上原理，既然Date&gt;=Last-Modified。那么我利用Date构建，也是完全正确的。 可能的问题出在服务端的 Http 实现上，如果服务端完全遵守 Http 语义，采用时间比较的方式来验证If-Modified-Since，判断服务器资源文件修改时间是不是在If-Modified-Since之后。那么使用Date完全正确。可是有的服务端实现不是比较时间，而是直接的判断服务器资源文件修改时间，是否和If-Modified-Since所传时间相等。这样使用Date就不能实现正确的再验证，因为Date的时间总不会和服务器资源文件修改时间相等。 尽管使用Date可能出现的不正确情况，归结于服务端没有正确的实现 Http 语义。但我还是希望Volley也能完全正确的实现Http语义，至少同时处理Last-Modified和Date,并且优先使用Last-Modified。 5.2 Bug(1). BasicNetwork.performRequest(…)如下代码： @Override public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError { …… while (true) { …… try { …… } catch (IOException e) { int statusCode = 0; NetworkResponse networkResponse = null; …… if (responseContents != null) { …… } else { throw new NetworkError(networkResponse); } } } } BasicNetwork.performRequest(…) 最后的 throw new NetworkError(networkResponse); 应该是 throw new NetworkError(e); 更合理。","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"网络框架","slug":"网络框架","permalink":"https://okfood.vip/blog/tags/网络框架/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"xUtils框架原理分析","slug":"xUtils框架原理分析","date":"2015-04-27T06:25:17.000Z","updated":"2019-09-06T07:10:04.415Z","comments":true,"path":"2015/04/27/xUtils框架原理分析/","link":"","permalink":"https://okfood.vip/blog/2015/04/27/xUtils框架原理分析/","excerpt":"","text":"1. 功能介绍xUtils一个Android公共库框架，主要包括四个部分：View，Db, Http, Bitmap 四个模块。 View模块主要的功能是通过注解绑定UI，资源，事件。 Db模块是一个数据库orm框架， 简单的语句就能进行数据的操作。 Http模块主要访问网络，支持同步，异步方式的请求，支持文件的下载。 Bitmap模块是加载图片以及图片的处理， 支持加载本地，网络图片。而且支持图片的内存和本地缓存。 2. 详细设计2.1 View模块2.1.1 总体设计流程和关系较少， 请看下面的详细分析 2.1.2 流程图 2.1.3 核心类功能介绍注解和反射知识是这个模块的主要内容 1.ViewUtils.javaView和各种事件的注入以及资源的注入。 (1)主要函数private static void injectObject(Object handler, ViewFinder finder) 第一个参数Object handler代表的是需要注入的对象， 第二个参数是需要注入View（这个View就是handler的成员变量）所在的View或者Activity的包装对象。 该方法完成了View和各种事件的注入以及资源的注入。主要的原理就是通过反射和注解。 完成Activity的setContentView。 完成View的注入。 完成资源的注入。 完成各种事件的注入。 2.ViewFinder.java(1)主要函数public View findViewById(int id, int pid) public View findViewById(int id)如果存在父View， 优先从父View寻找，否则从当前的View或者Activity中寻找。 3.ResLoader.javapublic static Object loadRes(ResType type, Context context, int id)获取资源文件值。支持多种资源的获取。 4.EventListenerManager.java事件的注入， 其中的设计是通过动态代理。 private final static DoubleKeyValueMap&lt;ViewInjectInfo, Class&lt;?&gt;, Object&gt; listenerCache = new DoubleKeyValueMap&lt;ViewInjectInfo, Class&lt;?&gt;, Object&gt;(); 存放监听事件接口map。 因为有些接口有多个函数， 代理会判断事件接口是否存在， 如果存在只增加代理方法就够了， 避免重新设置监听事件接口。 public static void addEventMethod( ViewFinder finder, ViewInjectInfo info, Annotation eventAnnotation, Object handler, Method method) 代理监听事件 5.注解类2.2 Db模块2.2.1 总体设计流程和关系较少， 请看下面的详细分析 2.2.2 流程图 2.2.3 核心类功能介绍注解、反射和数据库操作知识这个模块的主要内容 1.DbUtils.java主要功能数据库的创建，数据库的增删改查。 private static HashMap&lt;String, DbUtils&gt; daoMap = new HashMap&lt;String, DbUtils&gt;();存放DbUtils实例对象的map，每个数据库对应一个实例， key为数据库的名称。 private synchronized static DbUtils getInstance(DaoConfig daoConfig)采取的是单例模式，根据DaoConfig创建数据库， 中间还涉及到数据库升级。 delete； findAll； findById； saveOrUpdate；// 当数据库没有时保存， 存在时修改。 update； 增删改查。 2.DaoConfig.java private String dbName = &quot;xUtils.db&quot;; // default db name数据库名称 private int dbVersion = 1; //数据库版本 private DbUpgradeListener dbUpgradeListener; //升级监听事件 数据库配置类。 3.FindTempCache.java在DbUtils的查询数据中 @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; List&lt;T&gt; findAll(Selector selector) throws DbException { .... String sql = selector.toString(); long seq = CursorUtils.FindCacheSequence.getSeq(); findTempCache.setSeq(seq); Object obj = findTempCache.get(sql);//优先从缓存读取 if (obj != null) { return (List&lt;T&gt;) obj; } ... } 数据库查询数据的缓存。在查询中会优先调用缓存中的数据 4.SqlInfoBuilder.javasql建表、增删改语句的组合。 public static SqlInfo buildCreateTableSqlInfo(DbUtils db, Class&lt;?&gt; entityType) public static SqlInfo buildDeleteSqlInfo(DbUtils db, Class&lt;?&gt; entityType, Object idValue) public static SqlInfo buildDeleteSqlInfo(DbUtils db, Class&lt;?&gt; entityType, WhereBuilder whereBuilder) public static SqlInfo buildDeleteSqlInfo(DbUtils db, Object entity) public static SqlInfo buildInsertSqlInfo(DbUtils db, Object entity) public static SqlInfo buildUpdateSqlInfo(DbUtils db, Object entity, String... updateColumnNames) public static SqlInfo buildUpdateSqlInfo(DbUtils db, Object entity, WhereBuilder whereBuilder, String... updateColumnNames) 5.SqlInfo.javasql语句和值包装对象。 6.Table.java表对象。 7.Column.java表中列对象。 8.Id.java表对应的主键对象。 9.Selector.javasql查询语句的组合。 10.WhereBuilder.javasql条件语句的组合。 2.3 Http模块2.3.1 总体设计 2.3.2 流程图 2.3.3 类图 1.HttpUtils.java支持异步同步访问网络数据， 断点下载文件。 //网络数据的缓存。 public final static HttpCache sHttpCache = new HttpCache(); //访问网络的HttpClient。 private final DefaultHttpClient httpClient; private final HttpContext httpContext = new BasicHttpContext(); //线程池。 private final static PriorityExecutor EXECUTOR = new PriorityExecutor(DEFAULT_POOL_SIZE); public HttpUtils(int connTimeout, String userAgent) { //配置超时时间，UserAgent， http版本信息协议等一些信息 ..... //将配置的参数统一放到httpClient中 httpClient = new DefaultHttpClient(new ThreadSafeClientConnManager(params, schemeRegistry), params); .... //下面这个关键，设置拦截器。 默认加上gizp压缩。 通过gizp压缩后的数据传输效率高很多。 httpClient.addRequestInterceptor(new HttpRequestInterceptor() { @Override public void process(org.apache.http.HttpRequest httpRequest, HttpContext httpContext) throws org.apache.http.HttpException, IOException { if (!httpRequest.containsHeader(HEADER_ACCEPT_ENCODING)) { httpRequest.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP); } } }); httpClient.addResponseInterceptor(new HttpResponseInterceptor() { @Override public void process(HttpResponse response, HttpContext httpContext) throws org.apache.http.HttpException, IOException { final HttpEntity entity = response.getEntity(); if (entity == null) { return; } final Header encoding = entity.getContentEncoding(); if (encoding != null) { for (HeaderElement element : encoding.getElements()) { if (element.getName().equalsIgnoreCase(&quot;gzip&quot;)) { //这里判断从服务器传输的数据是否需要通过gzip解压。 response.setEntity(new GZipDecompressingEntity(response.getEntity())); return; } } } } }); } //访问网络数据 private &lt;T&gt; HttpHandler&lt;T&gt; sendRequest(HttpRequest request, RequestParams params, RequestCallBack&lt;T&gt; callBack); //下载网络文件 public HttpHandler&lt;File&gt; download(HttpRequest.HttpMethod method, String url, String target, RequestParams params, boolean autoResume, boolean autoRename, RequestCallBack&lt;File&gt; callback); 2.HttpRequest.java网络请求的包装类。 包括url， 访问请求方法， 参数值等。 3.RequestCallBack.java完成数据请求回调接口。 4.HttpHandler.java获取网络数据逻辑的实现。这里可以理解为系统内部AsyncTask。 访问网络数据处理流程图 5.HttpCache.java网络数据的缓存，内部包含LruMemoryCache。在获取数据的时候会判断是否过期。 6.StringDownLoadHandler.javahandleEntity()将网络io流转化为String。 7.FileDownLoadHandler.javahandleEntity()将网络io流转化为File。 8.HttpException.java统一异常 2.4 Bitmap模块2.4.1 总体设计 2.4.2 流程图请查看http模块 2.4.3 类图 1.BitmapUtils.java图片的异步加载，支持本地和网络图片， 图片的压缩处理， 图片的内存缓存已经本地缓存。 private BitmapGlobalConfig globalConfig; // 线程池，缓存，和网络的配置 private BitmapDisplayConfig defaultDisplayConfig; //图片显示的配置 /** * @param container 表示需要显示图片的View * @param uri 图片的uri * @param displayConfig 图片显示的配置 * @param callBack 图片加载的回调接口 */ public &lt;T extends View&gt; void display(T container, String uri, BitmapDisplayConfig displayConfig, BitmapLoadCallBack&lt;T&gt; callBack) 设置图片流程图 详细流程图 2.BitmapLoadTask.java加载图片的异步任务。在doInBackground中读取图片资源 3.BitmapCache.java private LruDiskCache mDiskLruCache; //闪存缓存 private LruMemoryCache&lt;MemoryCacheKey, Bitmap&gt; mMemoryCache; //运存缓存 (1)主要函数 //下载网络图片， 然后根据配置压缩图片， 将图片缓存。 public Bitmap downloadBitmap(String uri, BitmapDisplayConfig config, final BitmapUtils.BitmapLoadTask&lt;?&gt; task) //从运存缓存中读取bitmap 在获取的时候会判断是否过期 public Bitmap getBitmapFromMemCache(String uri, BitmapDisplayConfig config) //从闪存缓存中读取bitmap public Bitmap getBitmapFromDiskCache(String uri, BitmapDisplayConfig config) 4.BitmapGlobalConfig.java配置， 包括线程池， 缓存的大小。 //闪存缓存的路径 private String diskCachePath; //运存缓存的最大值 private int memoryCacheSize = 1024 * 1024 * 4; // 4MB //闪存缓存的最大值 private int diskCacheSize = 1024 * 1024 * 50; // 50M //从网络加载数据的线程池 private final static PriorityExecutor BITMAP_LOAD_EXECUTOR = new PriorityExecutor(DEFAULT_POOL_SIZE); //从闪存读取数据的线程池 private final static PriorityExecutor DISK_CACHE_EXECUTOR = new PriorityExecutor(2); //bitmap缓存的的时间 private long defaultCacheExpiry = 1000L * 60 * 60 * 24 * 30; // 30 days //bitmap缓存 private BitmapCache bitmapCache; 5.BitmapDisplayConfig.java //图片显示的大小 private BitmapSize bitmapMaxSize; //图片的动画 private Animation animation; // 图片加载过程中的显示图片 private Drawable loadingDrawable; // 图片加载失败的显示图片 private Drawable loadFailedDrawable; // 图片显示的配置色彩 private Bitmap.Config bitmapConfig = Bitmap.Config.RGB_565; 6.DefaultDownloader.java获取bitmap， 支持三种获取路径， 本地文件，资产文件， 和网络图片。 7.DefaultBitmapLoadCallBack.java图片加载完成的的回调， 默认回调将获取的bitmap值传递给view。 3. 杂谈和Volley框架相比 相同点： 1.采用了网络数据缓存机制。 2.通过handler进行线程通信 不同点： Volley的Http请求在 android 2.3 版本之前是通过HttpClient ，在之后的版本是通过URLHttpConnection。xUtils都是通过HttpClient请求网络（bitmap模块图片下载是通过URLHttpConnection）。 URLHttpConnection默认支持GZIP压缩，api操作简单。 2.Volley将Http请求数据先缓存进byte[]， 然后是分配给不同的请求转化为需要的格式。xUtils是直接转化为想要的格式。 Volley：扩展性好， 但是不能存在大数据请求，否则就OOM。xUtils：不缓存入byte[] 支持大数据的请求， 速度比Volley稍快，但扩展性就低。 4.Volley访问网络数据时直接开启固定个数线程访问网络， 在run方法中执行死循环， 阻塞等待请求队列。 xUtils是开启线程池来管理线程。 缓存失效策略， volley的所有网络数据支持从http响应头中控制是否缓存和读取缓存失效时间，每个请求可以控制是否缓存和缓存失效时间。 Xutils网络数据请求是统一自定义缓存失效时间。","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"xUtils","slug":"xUtils","permalink":"https://okfood.vip/blog/tags/xUtils/"},{"name":"开源项目","slug":"开源项目","permalink":"https://okfood.vip/blog/tags/开源项目/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"DOM编程及实例","slug":"DOM编程及实例","date":"2014-07-22T05:35:40.000Z","updated":"2019-09-06T03:49:02.825Z","comments":true,"path":"2014/07/22/DOM编程及实例/","link":"","permalink":"https://okfood.vip/blog/2014/07/22/DOM编程及实例/","excerpt":"","text":"DOMDocument Object Model 文档对象模型 dom三层模型 dom1:将html文档封装成对象。 dom2:将xml文档封装成对象。 dom3:将xml文档封装成对象。 标签之间存在层次关系：（树形结构） window document html |--head |--title |--base |--mate |--link |--style |--script |--body |--table |--tbody |--tr |--td |--th |--div |--form |--a DOM树（标记性文档加载进内存后就有了一个对应的DOM树） 有个弊端：文档过大，相对耗费资源，而是使用SAX方式解析。 节点（文档中所有的标签和内容即为节点） html,xhtml,xml:都是标记性语言. DHTML叫做动态的html. 是html,css,dom,javascript四项技术的综合体。 html:将数据进行封装。 dom:将标签封装成对象。 css:负责标签中数据的样式。 javascript:将上面三个进行融合，通过程序设计方式来完成动态效果的操作。 xmlGttpRequest——&gt;AJAX 节点类型： 标签型节点：类型 1 属性节点：类型 2 文本型节点：类型 3 注释型节点：类型 8 document： 类型 9 注意：标签之间存在空行时，会出现一个空白的文本节点，在获取节点的时一定要注意！！！ 节点的关系： 父节点：parentNode 子节点:childNodes 直接子节点 兄弟节点 上一个兄弟节点：previousSibling 下一个兄弟节点：nextSibling 获取节点可以通过节点的层次关系完成，也可以通过document对象来完成 getElementById 获取对 ID 标签属性为指定值的第一个对象的引用。 （通过ID） getElementsByName 根据 NAME 标签属性的值获取对象的集合。 （通过name属性） getElementsByTagName 获取基于指定元素名称的对象集合。 （通过标签名） DOM编程实例table标签示例1.定义界面： 通过html的标签将数据进行封装 2.定义一些静态样式： 通过css 3.需要动态的完成和用户的交互： a.先明确事件源 b.明确事件将事件注册到事件源上 c.通过javascript的函数对象事件进行处理 d.在处理过程中需要明确被处理的区域一.在页面上通过按钮创建一个表格。思路： 1.创建一个table节点，document。createElement（“table”）； 2.通过table节点的insertRow（）方法创建表格的行对象并添加到rows集合中 3.通过行对象的insertCell（）方法创建单元格对象，并添加到cells集合中 4.给单元格添加数据 a.创建一个节点如文本节点，document。createTextNode(&quot;文本内容&quot;)，通过单元格对象appendChild方法将文本节点添加到单元格的尾部 b.可以通过单元格的innerHTML，添加单元格中的元素。e: tdNode.innerHTML = &quot;&lt;img src &#39;1.png&#39; alt=&#39;图片说明信息&#39;/&gt;&quot; 5.建立好表格节点，添加到DOM树中，也就是页面的指定位置二.如何删除表格中的行或列。思路： 1.删除行：获取表格对象，通过表格对象中deleteRow方法，将指定的行索引传入deleteRow方法中 2.删除列：表格没有直接删除列的方法，要通过删除每一行中指定的单元格来完成删除列的动作。获取所有行对象，并进行遍历，通过行对象的deleteCell方法将指定的单元格删除。三.对表格中的数据进行排序。思路： 1.获取表格中的所有对象 2.定义临时存储，将需要进行排序的行对象存入到数组中 3.对数组进行排序，通过比较每一行对象中指定单元格中的数据，如果是整数要通过parseInt转换 4.将排序后的数组通过遍历，将每一个行对象重新添加回表格，通过tbody节点的appendChild方法 5.其实排序就是每一个行对象的引用取出四.表格的行颜色间隔显示，并在鼠标指定的行上高亮。思路： 1.获取所有行对象，将需要间隔颜色显示的行对象进行动态className属性指定，那么前提是：先定义好类选择器 2.为了完成高亮，需要用到两个事件，onmouseover(鼠标进入)和onmouseout(鼠标移出) 3.为了方便可以在遍历行对象时，将每一个行对象都进行两个事件属性的指定，并通过匿名函数完成该事件的处理 4.高亮的原理就是将鼠标进入时的指定颜色改变，改变前先记录原来行对象的样式，这样在鼠标离开时可以将原样式还原 5.该样式需要在页面加载完后直接显示，所有使用window.onload事件来完成五.制作大小写切换界面通过DOM编程步骤实现. 六.表单中的组件单选框，复选框 这两个组件都一个属性来表示器选中与否的状态，checked 七.获取鼠标的坐标，让指定区域随着鼠标移动获取鼠标坐标：event.x,event.y 指定区域随鼠标移动其实就是改变了指定区域的left top属性的值 这里需要用到的时间：body对象onmouseover事件；css样式，直接定义页面，所以区域在同一层次，为了对某一区域进行定位，将该区域分离到另一个层次，用到css中的position属性","categories":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://okfood.vip/blog/tags/DOM/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}]},{"title":"JavaScript及基本语法","slug":"JavaScript及基本语法","date":"2014-07-13T05:32:53.000Z","updated":"2019-09-06T03:41:39.325Z","comments":true,"path":"2014/07/13/JavaScript及基本语法/","link":"","permalink":"https://okfood.vip/blog/2014/07/13/JavaScript及基本语法/","excerpt":"","text":"Javascript是Netscape公司语言，基于对象和事件驱动。和java的不同之处： 1. 所属公司不一样，java是sun公司的，现在Oracle公司 2. js是基于对象，java是面向对象 3. js是浏览器解释并执行，java是有jvm解释并执行 4. js是弱类型语言，java是强类型语言 5. js是非严谨的，java是严谨的javascript运行在客户端。 js需要被浏览器所解释并执行，就必须将代码和html相结合 1. 通过定义&lt;script&gt;标签将js代码存入其中，并指定type属性，方便与浏览器启动指定的解释引擎。 2. 也可通过&lt;script&gt;标签，使用src属性连接一个指定的js文件进来。javascript的基本语法变量通过var定义变量，该变量可以赋予不同类型的常量。 var x = 3; x = &quot;abc&quot;;特殊常量：undefined 语句if,switch,while,do while,for.使用逻辑运算符进行布尔表达式连接的时候，需要使用短路与&amp;&amp;和短路或||。 因为在js中，非0即为true,0为false;非null为true，null为false js特有语句：with，for in。 with(对象){} for(变量 in 对象)数组对于js的数组，数组的长度是可变的，相当于java中的集合；该数组中可以存放的元素类型是可以不同的。 定义格式： var arr = [2,4,true,3,&quot;asd&quot;]; var arr = new Array(); var arr = [[1,33,54],[4,2]];操作形式和java一样，for遍历，用了指针的思想。 函数通过function关键字定义函数。 a.一般函数 格式：function 函数名（形式参数…） { 执行语句； return 返回值； }b.动态函数 使用的Function对象。 var show = new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x+y;&quot;);动态函数的特点：可以将参数列表和方法体作为参数传递 c.匿名函数 一般函数的简写形式， function(){}匿名函数通常可以用于事件的处理。如： window.onload = function(){alert(&quot;onload over&quot;);}在函数使用时需要注意的部分： function show() { return &quot;show run&quot;; } var method = show(); var method = show;两句都是正确的， 第一句表示的是show方法运行后的结果赋值给method变量； 第二句表示将show指向的对象的地址赋给method，那么method也指向了该对象，那么就可以通过调用method();的形式来调用show方法。 js可以通过对象形式将数据进行封装。 首先对对象进行描述，通过函数完成。 function Person（name,age）{ this.name = name; this.age = age; } var p = new Person(&quot;lisi&quot;,20); alert(p[&quot;name&quot;]+&quot;..&quot;+p.age); p.show = function(){ alert(&quot;show run&quot;); }js中已经定义好的一些对象。 String,Math,Date等,这些对象都有一个属性交prototype原型，prototype可以获取指定对象类型的引用，可以通过该引用给已有的对象赋予一些新的功能，即可以自定义一些好的新功能。 常见的全局方法： parseInt(numstr,[radix]);//将数字格式按照radix进制进行转换 var num = parseInt(&quot;110&quot;,2); alert(&quot;num=&quot;+num);//num = 6 var x = 6; alert(x.toString(2));//x的二进制表现形式","categories":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://okfood.vip/blog/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}]},{"title":"CSS层叠样式表","slug":"CSS层叠样式表","date":"2014-06-25T05:30:58.000Z","updated":"2019-09-06T03:34:18.432Z","comments":true,"path":"2014/06/25/CSS层叠样式表/","link":"","permalink":"https://okfood.vip/blog/2014/06/25/CSS层叠样式表/","excerpt":"","text":"CSS层叠样式表将网页中的样式分离出来，完全由CSS来控制，增强样式的复用性及可扩展性。格式： 选择器{属性名：属性值;属性名：属性值… } css和html代码相结合的四种方式1.每个html标签都有一个style属性 2.当页面有多个标签有相同的样式时，可以进行复用 &lt;style&gt; css代码 &lt;/style&gt;3.当有多个页面中的标签的样式相同时，还可以将样式单独封装成一个CSS文件，通过在每个页面中定义 &lt;style&gt; @import url(&quot;1.css&quot;); &lt;/style&gt;4.通过html中head标签中的link标签连接一个CSS文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot; /&gt;技巧：为了提高相同样式的复用性以及可扩展性，可以将多个标签样式进行单独定义并封装成CSS p.css,div.css...在一个CSS文件中使用CSS的import将多个标签样式文件导入，然后在html页面上，使用link标签导入这个总的CSS文件即可 1.css @import url(&quot;p.css&quot;); @import url(&quot;div.css&quot;); &lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot; /&gt; 选择器其实就是样式要作用的标签容器。当样式分离后，html作用在于用标签封装数据，然后将CSS加载到指定标签上。 选择器分类1.标签选择器：就是html中的每一个标签名。 2.类选择器：就是每一个标签中的class属性。用 . 表示，只用来给CSS所使用，可以对不同标签进行相同样式设定 3.ID选择器：就是每一个标签中的ID属性。但是要保证ID唯一性，用#来标识，ID不仅可以被CSS所使用还可以被javascript所使用。 选择器优先级ID&gt;class&gt;标签 扩展选择器1.关联选择器：就是对标签中的标签镜像样式定义。选择器 选择器… 2.组合选择器：对多个选择器进行相同样式定义。将多个选择器通过，隔开的形式。 3.伪元素选择器：就是元素的一种状态。 a:link：超链接被点前状态 a:visited：超链接点击后状态 a:hover：悬停在超链接上 a:active：点击超链接时在定义这些状态时，有一个顺序：L V H A p:first-letter p:first-line :focus：IE6不支持，但FF支持。CSS滤镜通过一些代码完成丰富的样式 当使用到CSS的更多属性是还需要查阅CSS API 网页设计的时候。div+css div:行级区域 span:块级区域 p:行级区域，p中不能嵌套div","categories":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://okfood.vip/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://okfood.vip/blog/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}]},{"title":"Html标签","slug":"Html标签","date":"2014-06-05T02:18:24.000Z","updated":"2019-09-06T03:27:52.368Z","comments":true,"path":"2014/06/05/Html标签/","link":"","permalink":"https://okfood.vip/blog/2014/06/05/Html标签/","excerpt":"","text":"Html:超文本标记语言HTML中语言是由标签组成的；数据都会封装在标签中，因为可以通过标签的属性值的改变对封装内数据进行操作。 确定html代码范围：&lt;html&gt;&lt;/html&gt; 在该范围中可以定义两部分内容，一部分是头，一部分是体。 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; head:网页的一些属性信息，比如标题。 body:网页显示数据标签特点：对于数据进行封装，那么就有开始标签和结束标签，但是也有一些标签只体现单一功能，所以不需要结束标签，规范中要求标签必须要结束，所以这样的标签在内部结束。 如：&lt;br /&gt; &lt;hr /&gt; &lt;img /&gt; &lt;input /&gt;标签格式： &lt;标签名 属性名=&quot;属性值&quot;&gt;数据&lt;/标签名&gt; &lt;标签名 属性名=&quot;属性值&quot; /&gt;常见标签： 1.字体：&lt;font size=&quot;7&quot;color=&quot;red&quot;&gt;数据&lt;/font&gt; 特殊部分：如果要在页面显示一些特殊符号，需要用转义字符，如： &lt;:&amp;lt; &gt;:&amp;gt; &amp;:&amp;amp; 空格:&amp;nbsp; 标题：&lt;h1&gt;&lt;h2&gt;&lt;h3&gt;...&lt;h6&gt; 2.列表标签：&lt;dl&gt;&lt;/dl&gt; 上层项目：&lt;dt&gt; 下层项目：&lt;dd&gt; 项目符号标签：&lt;ul&gt;,&lt;ol&gt;这两个标签中的列表项均由&lt;li&gt;封装。 3.图像标签：&lt;img&gt; &lt;img src=&quot;&quot; alt=&quot;图像说明文字&quot; /&gt; 4.表格标签：&lt;table&gt; 表格由行所组成，行有单元格组成。 &lt;table border=&quot;1&quot; bordercolor=&quot;#000000&quot; width=&quot;70%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;10&quot; &gt; &lt;tr&gt; &lt;th&gt;内容数据(居中加粗)&lt;/th&gt; &lt;th&gt;内容数据(居中加粗)&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容数据&lt;/td&gt; &lt;td&gt;内容数据&lt;/td&gt; &lt;/tr&gt;表格是最常用的的标签，用于对数据进行格式化。 5.超链接：&lt;a&gt; &lt;a href=&quot;htttp://www.baidu.com&quot; target=&quot;_blank&quot; title=&quot;百度一下&quot;&gt;百度一下&lt;/a&gt; &lt;a href=&quot;http://www.sina.com.cn&quot;&gt;&lt;img src=&quot;1.png&quot; height=&quot;20&quot; width=&quot;70&quot; /&gt;&lt;/a&gt;&lt;!--将图片作为链接--&gt; &lt;a href=&quot;mailto:abc@sina.com.cn?subject=haha&amp;cc=qq@163.com&quot;&gt;联系我们&lt;/a&gt;超链接的另一个作用：定位标记，回到顶部 &lt;a name=&quot;top&quot;&gt;顶部位置&lt;/a&gt; &lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt; 6.表单标签： 该标签可以与服务端进行交互 &lt;form&gt; 表单标签中的元素： &lt;input&gt;:该标签因为type属性的值不同，所以对于的组件也不一样 type属性： 1.text：文本框，输入的文本可见 2.password:密码框，输入的文本不可见 3.radio：单选框，要被选择则必须定义name属性，当多个单选框时，只能一个被选中则name值相同 4.checkbox：复选框，当多个数据进行同时选中时 5.file:进行文件选择，通常用于附件或文件上传 6.hidden：隐藏组件，该组件不会再页面上显示，但是其定义的name可以提交到服务端 7.button：按钮组件，自定义一个按钮是默认没有效果，可以通过注册事件并加入自定义效果 8.reset：重置按钮，将组件中被操作的效果还原到初始状态 9.submit：提交按钮，将组件中添加的数据提交到目的地 10.image：图像组件，为了避免提交按钮的难看，可以通过一个图片作为按钮。 下拉菜单：&lt;select&gt; 每一个下拉菜单项都由option进行封装 &lt;select&gt; &lt;option&gt;&lt;/option&gt; &lt;/select&gt; 文本区域：&lt;textarea&gt; 表单组件通常都需要定义name和value属性，因为要将数据发送给服务端 服务端只有知道了该name的值才可以对提交的数据进行分别获取 form标签中的常见属性： action:指定数据提交到目的地，method：提交方式，get(默认)和postget和post的区别get: 会把提交的数据显示在地址栏上; 提交的数据的体积受到地址栏的限制; 对于敏感信息不安全; 会将提交的信息封装在请求行，也就是http消息头之前 post： 不会讲数据显示在地址栏; 可以提交大体积数据; 对于敏感信息安全; 会将提交信息封装在数据体中，也就是http消息头之后的空行后。 对于服务端而言： 表单提交尽量用post，因为涉及到编码问题。因为tomcat服务端默认的解码是ISO8859-1 对于post提交的中文，在服务端可以直接使用setChracterEncodeing(“GBK”)就可以解决。 对于get提交的中文，在服务端只能通过ISO8859-1将数据编码一次，再通过指定的码表如GBK解码。 使用表单的组件不一定要定义form标签，只有需要将数据进行服务端的提交的时候才用到form标签。","categories":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://okfood.vip/blog/tags/html/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://okfood.vip/blog/categories/前端/"}]},{"title":"Java代理","slug":"Java代理","date":"2014-05-27T01:47:59.000Z","updated":"2019-09-06T03:20:58.102Z","comments":true,"path":"2014/05/27/Java代理/","link":"","permalink":"https://okfood.vip/blog/2014/05/27/Java代理/","excerpt":"","text":"代理模式代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 代理模式一般涉及到的角色有： 抽象角色：声明真实对象和代理对象的共同接口； 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。 举例： //抽象角色： abstract public class Subject{ abstract public void request(); } //真实角色：实现了Subject的request()方法。 public class RealSubject extends Subject{ public RealSubject(){ } public void request(){ System.out.println(&quot;From real subject.&quot;); } } //代理角色： public class ProxySubject extends Subject{ private RealSubject realSubject; //以真实角色作为代理角色的属性 public ProxySubject(){ } public void request(){ //该方法封装了真实对象的request方法 preRequest(); if( realSubject == null ){ realSubject = new RealSubject(); } realSubject.request(); //此处执行真实对象的request方法 postRequest(); } private void preRequest(){ //something you want to do before requesting } private void postRequest(){ //something you want to do after requesting } } //客户端调用： Subject sub=new ProxySubject(); Sub.request(); 由以上代码可以看出，客户实际需要调用的是RealSubject类的request()方法，现在用ProxySubject来代理RealSubject类，同样达到目的，同时还封装了其他方法(preRequest(),postRequest())，可以处理一些其他问题。 另外，如果要按照上述的方法使用代理模式，那么真实角色必须是事先已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀；此外，如果事先并不知道真实角色，该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。 动态代理Java动态代理类位于Java.lang.reflect包下，一般主要涉及到以下两个类： (1). Interface InvocationHandler：该接口中仅定义了一个方法Object：invoke(Object obj,Method method, Object[] args)。在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，如上例中的request()，args为该方法的参数数组。这个抽象方法在代理类中动态实现。 (2).Proxy：该类即为动态代理类，作用类似于上例中的ProxySubject，其中主要包含以下内容： Protected Proxy(InvocationHandler h)：构造函数，估计用于给内部的h赋值。 Static Class getProxyClass (ClassLoader loader, Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。 Static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)。所谓Dynamic Proxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然啦，这个Dynamic Proxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。 在使用动态代理类时，我们必须实现InvocationHandler接口，以第一节中的示例为例： 代码： //抽象角色(之前是抽象类，此处应改为接口)： public interface Subject{ public void request(); } //具体角色RealSubject：实现了Subject接口的request()方法。 public class RealSubject implements Subject{ public RealSubject(){ } public void request(){ System.out.println(&quot;From real subject.&quot;); } } //代理角色： import java.lang.reflect.Method; import java.lang.reflect.InvocationHandler; public class DynamicSubject implements InvocationHandler{ private Object sub; public DynamicSubject(Object sub){ this.sub = sub; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;before calling &quot; + method); method.invoke(sub,args); System.out.println(&quot;after calling &quot; + method); return null; } }该代理类的内部属性为Object类，实际使用时通过该类的构造函数DynamicSubject(Object sub)对其赋值；此外，在该类还实现了invoke方法，该方法中的”method.invoke(sub,args)” 其实就是调用被代理对象的将要被执行的方法，方法参数sub是实际的被代理对象，args为执行被代理对象相应操作所需的参数。通过动态代理类，我们可以在调用之前或之后执行一些相关操作。 客户端： 代码： import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.lang.reflect.Constructor; import java.lang.reflect.Method; public class Client{ static public void main(String[] args) throws Throwable{ RealSubject rs = new RealSubject(); //在这里指定被代理类 InvocationHandler ds = new DynamicSubject(rs); //初始化代理类 Class cls = rs.getClass(); //以下是分解步骤 /* Class c = Proxy.getProxyClass(cls.getClassLoader(),cls.getInterfaces()); Constructor ct=c.getConstructor(new Class[]{InvocationHandler.class}); Subject subject =(Subject) ct.newInstance(new Object[]{ds}); */ //以下是一次性生成 Subject subject = (Subject) Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(),ds); subject.request(); }通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。 代理模式使用原因和应用方面（1）授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive论坛系统中,就使用Proxy进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive中就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限. （2）某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动. 举例两个具体情况: 如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处理完成,这时需要做个图片Proxy来代替真正的图片. 如果那个对象在Internet的某个远端服务器上,直接操作这个对象因为网络速度原因可能比较慢,那我们可以先用Proxy来代替那个对象. 总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝贵的Java内存. 所以,有些人认为Java耗费资源内存,我以为这和程序编制思路也有一定的关系. （3）现实中，Proxy应用范围很广,现在流行的分布计算方式RMI和Corba等都是Proxy模式的应用","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"},{"name":"代理","slug":"代理","permalink":"https://okfood.vip/blog/tags/代理/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"JavaBean内省、注解、类加载器","slug":"JavaBean内省、注解、类加载器","date":"2014-05-26T01:17:03.000Z","updated":"2019-09-06T03:21:08.925Z","comments":true,"path":"2014/05/26/JavaBean内省、注解、类加载器/","link":"","permalink":"https://okfood.vip/blog/2014/05/26/JavaBean内省、注解、类加载器/","excerpt":"","text":"Javabeans内省JavaBean是一种特殊的Java类，主要用于传递数据信息，这种Java类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。 应用情景如果要在两个模块之间传递多个信息，可以将这些信息封装到一个JavaBean中，这种JavaBean的实例对象通常称之为值对象（Value Object，简称VO）。这些信息在类中用私有字段来存储，如果读取或设置这些字段的值，则需要通过一些相应的方法来访问。 JavaBean的规则JavaBean的属性是根据其中的setter和getter方法来确定的，而不是根据其中的成员变量。如果方法名为setId，中文意思即为设置id，至于你把它存到哪个变量上，则不用管。如果方法名为getId，中文意思即为获取id，至于你从哪个变量上取，也不用管。去掉set前缀，剩余部分就是属性名，如果剩余部分的第二个字母是小写的，则把剩余部分的首字母改成小的。 例如： setId()的属性名：id isEmpty()的属性名：empty setCPU的属性名：CPU gettime的属性名：time 总之，一个类被当作JavaBean使用时，JavaBean的属性是根据方法名推断出来的，它根本看不到Java类内部的成员变量。 一个符合JavaBean特点的类可以当作普通类一样进行使用，但把它当JavaBean用肯定需要带来一些额外的好处，我们才会去了解和应用JavaBean！ JavaBean的好处好处如下： 1、在Java EE开发中，经常要使用到JavaBean。很多环境就要求按JavaBean方式进行操作，别人都这么用和要求这么做，那你就没什么挑选的余地！ 2、JDK中提供了对JavaBean进行操作的一些API，这套API就称为内省。如果要你自己去通过getX方法来访问私有的x，怎么做，有一定难度吧？用内省这套API操作JavaBean比用普通类的方式更方便。 对JavaBean的简单内省操作 通过内省的方式对Person对象中的成员变量进行读写操作。 并对生成的代码进行重构。 通过反射对某个属性进行读写操作的代码可以抽取为通用方法 步骤如下：选中需要重构的代码，右击–&gt;Refactor–&gt;Extract Method…。 给抽取后的方法取一个名字，然后点击OK。 注意：抽取方法之后，为了使抽取后的方法具备通用性，一定要把方法中某些参数设置为Object类型。 举例： package pack.leo; import java.beans.PropertyDescriptor; import java.lang.reflect.Method; public class JavaBeanDemo { public static void main(String[] args) throws Exception { Person p = new Person(); setProperty(p, &quot;age&quot;, 21); setProperty(p, &quot;name&quot;, &quot;lisi&quot;); Object obj1 = getProperty(p, &quot;age&quot;); Object obj2 = getProperty(p, &quot;name&quot;); System.out.println(obj1); System.out.println(obj2); } //获取属性方法，传入对象名和对象的属性名即返回属性值 private static Object getProperty(Object obj, String propertyName)throws Exception { PropertyDescriptor pd = new PropertyDescriptor(propertyName,obj.getClass()); Method methodGetAge = pd.getReadMethod(); Object retVal = methodGetAge.invoke(obj); return retVal; } //设置属性方法 private static void setProperty(Object obj, String propertyName, int value)throws Exception { PropertyDescriptor pd = new PropertyDescriptor(propertyName,obj.getClass()); Method methodSetAge = pd.getWriteMethod(); methodSetAge.invoke(obj, value); } //设置属性方法 ，重载 private static void setProperty(Object obj, String propertyName, String value)throws Exception { PropertyDescriptor pd = new PropertyDescriptor(propertyName,obj.getClass()); Method methodSetAge = pd.getWriteMethod(); methodSetAge.invoke(obj, value); } }注解@SuppressWarnings(“deprecation”)代码示例： package com.leo; public class AnnotationTest { public static void main(String[] args) { System.runFinalizersOnExit(true); } }由上面的示例可以看到当执行一切过时的方法时，MyEclipse会自动划线，提示开发人员调用的方法已经过时，建议不要调用。 通过命令行进行编译也可以看到过时的提示，如下： 如果要看哪个方法已经过期，直接在编译时期加上详细信息重新编译。 此时，在main方法上添加一个注解：@SuppressWarnings(“deprecation”)，此注解的作用就是告诉编译器，虽然我用的方法过时了，但是我还是坚持要用，你就不要再提示了。 Java 5.0代码示例： package com.leo; public class AnnotationTest { @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args) { System.runFinalizersOnExit(true); } }再在命令行窗口中进行编译，就不会出现过时提示了。 @Deprecated有时候我们写的方法被别人调用了，但是如果这个方法有一些Bug需要修改，可是如果我们修改了又会影响以前已经调用这个方法的程序。 这时候我们可以把这个方法设置为过时，然后重新写一个方法，这时候就需要用到@Deprecated注解。 Java 5.0代码示例： package com.leo; public class AnnotationTest { public static void main(String[] args) { sayHello(); } @Deprecated public static void sayHello(){ System.out.println(&quot;Hello 程序员&quot;); } }由上面的示例可以看到，我们的sayHello方法可以通过@Deprecated注解标记为过时，然后调用者调用该方法的地方就会被MyEclipse划上横线作为过时的提示。 @Override有时候我们写的某些方法需要覆盖父类的方法，但是可能方法名或者参数会出现不小心写错的情况。 这时候就可以为这个方法打上@Override注解，如果有任何差错，MyEclipse就会报错。 例如：equals方法的参数为Object obj，但是经常会被写错，这时候就可以通过@Override注解避免这种情况。 注意： 1、注解是JDK1.5的新特性。 2、一个注解就是一个类，使用注解，就相当于创建了一个类的实例对象。 3、注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记，没加，则等于没有某种标记。 以后，Javac编译器，开发工具和其他程序可以用反射来了解你的类及各种元素上有无何种标记，看 你有什么标记，就去干相应的事。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。 4、看Java.lang包，可看到JDK中提供的最基本的Annotation。 5、注解就相当于一个你的源程序中要调用的一个类，要在源程序中应用某个注解，得先准备好了这个注解类。 就像你要调用某个类，得先有开发好这个类 什么是注解的属性 一个注解相当于一个胸牌，如果你胸前贴了胸牌，就是学生，否则，就不是。如果还想区分出是 哪个班的学生，这时候可以为胸牌再增加一个属性来进行区分。 加了属性的标记效果为：@HeiMaAnnotation(color=”red”)。 定义基本类型的属性和应用属性：在注解类中增加String color(); 被添加的注解设置属性值：@HeiMaAnnotation(color=”red”)。 用反射方式获得注解对应的实例对象后，再通过该对象调用属性对应的方法 HeiMaAnnotation heimaannotation = AnnotationTest.class.getAnnotation(HeiMaAnnotation.class); System.out.println(heimaannotation.color()); 可以认为上面这个@HeiMaAnnotation是HeiMaAnnotaion类的一个实例对象。 为属性指定缺省值：String color() default “Yellow”; value属性：String value()default “程序员”; 如果注解中有一个名称为value的属性，且你只想设置value属性（即其他属性都采用默认值或者你只有一个value属性），那么可以省略value=部分，例如：@HeiMaAnnotation(“CSDN社区”)。 数组类型的属性 int [] arrayAttr() default{1,2,3}; 被添加的注解设置属性值：@HeiMaAnnotation(arrayAttr={2,3,4})。 如果数组属性中只有一个元素，这时候属性值部分可以省略大括号。 枚举类型的属性 Lamp lamp() ; 被添加的注解设置属性值：@HeiMaAnnotation(lamp=Lamp.GREEN)。 注解类型的属性 MetaAnnotation annotationAttr() default@MetaAnnotation(“程序员”); 被添加的注解设置属性值：@HeiMaAnnotation(annotationAttr = @MetaAnnotation(“社区”) ) 可以认为上面这个@HeiAnnotation是HeiMaAnnotaion类的一个实例对象，同样的道理，可以认为上面这 @MetaAnnotation是MetaAnnotation类的一个实例对象，调用代码如下： MetaAnnotation ma = HeiMaAnnotation.annotationAttr(); System.out.println(ma.value()); 类加载器Java虚拟机中可以安装多个类加载器，系统默认有三个主要的类加载器，每个类加载器负责加载特定位置的类： BootStrap,ExtClassLoader,AppClassLoader。类加载器也是Java类，因此Java类的类加载器本身也要被其他的类加载器加载，显然必须有第一个类加载器不是Java类，它就是BootStrap类加载器。 注意： JVM内核启动的时候，BootStrap就已经被加载了，它是内嵌在JVM内核中的，是用C++语言编写的二进制代码，因此不需要其他类加载器加载。 Java虚拟机中的所有类装载器采用了具有父子关系的树形结构进行组织。 在实例化每个类加载器对象时，需要为其指定一个父级类加载器对象或者默认采用系统类加载器为其父级类加载。 类加载器的委托机制当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢？ 首先当前线程的类加载器去加载线程中的第一个类。 如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器来加载类B。 还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类。 每个类加载器加载类时，又先委托给其上级类加载器。 当所有祖宗类加载器没有加载到类，回到发起者类加载器，还加载不了，则抛ClassNotFoundException，不是再去找发起者类加载器的儿子，因为没有getChild方法，即使有，那有多个儿子，找哪一个呢？ 注意： 每个ClassLoader本身只能分别加载特定位置和目录中的类，但它们可以委托其他的类装载器去加载类，这就是类加载器的委托模式。类加载器一级级委托到BootStrap类加载器，当BootStrap无法加载当前所要加载的类时，然后才一级级回退到子孙类装载器去进行真正的加载。当回退到最初的类装载器时，如果它自己也不能完成类的装加载，那就会告ClassNotFoundException异常。 有一道面试题，能不能自己写个类叫java.lang.System？ 答案是不能，即使写了也不会被类加载器加载。为了不让我们写System类，类加载机制采用委托机制，这样可以保证父级类加载器优先，也就是总是使用父级类加载器能找到的类，结果就是总是使用Java系统自身提供的System类，而不会使用我们自己所写的System类。 自定义类加载器的编写原理分析类加载器中的loadClass方法内部实现了父类委托机制，因此我们没有必要自己覆盖loadClass，否则需要自己去实现父类委托机制。我们只需要覆盖findClass法。loadClass方法中调用了findClass方法，使用的是模板设计模式。我们得到了Class文件后，就可以通过defineClass方法将二进制数据转换成字节码。这就是自定义类加载器的编写原理。","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"Java内省","slug":"Java内省","permalink":"https://okfood.vip/blog/tags/Java内省/"},{"name":"注解","slug":"注解","permalink":"https://okfood.vip/blog/tags/注解/"},{"name":"类加载器","slug":"类加载器","permalink":"https://okfood.vip/blog/tags/类加载器/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java正则表达式","slug":"Java正则表达式","date":"2014-05-24T07:53:55.000Z","updated":"2019-09-06T03:02:14.600Z","comments":true,"path":"2014/05/24/Java正则表达式/","link":"","permalink":"https://okfood.vip/blog/2014/05/24/Java正则表达式/","excerpt":"","text":"正则表达式其实是用来操作字符串的一些规则。 好处：正则的出现，对字符串的复杂操作变得更为简单。 特点：将对字符串操作的代码用一些符号来表示。只要使用了指定符号，就可以调用底层的代码对字符串进行操作。符号的出现，简化了代码的书写。 弊端：符号的出现虽然简化了书写，但是却降低了阅读性。 其实更多是用正则解决字符串操作的问题。 组：用小括号标示，每定义一个小括号，就是一个组，而且有自动编号，从1开始。 只要使用组，对应的数字就是使用该组的内容。别忘了，数组要加\\。 (aaa(wwww(ccc))(eee))技巧，从左括号开始数即可。有几个左括号就是几组。 常见操作1，匹配：其实用的就是String类中的matches方法。 String reg = &quot;[1-9][0-9]{4,14}&quot;; boolean b = qq.matches(reg);//将正则和字符串关联对字符串进行匹配。2，切割：其实用的就是String类中的split方法。 3，替换：其实用的就是String类中的replaceAll(); 4，获取： 1），先要将正则表达式编译成正则对象。使用的是Pattern中静态方法 compile(regex); 2），通过Pattern对象获取Matcher对象。 Pattern用于描述正则表达式，可以对正则表达式进行解析。 而将规则操作字符串，需要从新封装到匹配器对象Matcher中。 然后使用Matcher对象的方法来操作字符串。 如何获取匹配器对象呢？ 通过Pattern对象中的matcher方法。该方法可以正则规则和字符串想关联。并返回匹配器对象。 3），使用Matcher对象中的方法即可对字符串进行各种正则操作。 举例1： package pack.leo; public class RegexDemo { public static void main(String... args) { oldCheckQQ(&quot;123456&quot;); checkQQ(&quot;619827587&quot;); split(&quot;192.168.9.101&quot;); replaceAll(&quot;heima#163.com&quot;); } public static void replaceAll(String E_mail) { String regex = &quot;[#]&quot;; String newStr = E_mail.replaceAll(regex, &quot;@&quot;); System.out.println(newStr); } public static void split(String ip) { String regex = &quot;\\\\.&quot;; String[] arr = ip.split(regex); for (String subString : arr) { System.out.println(subString); } } public static void checkQQ(String qq) { String regex = &quot;[1-9]\\\\d{4,9}&quot;; boolean flag = qq.matches(regex); if (flag) System.out.println(qq + &quot;is ok&quot;); else System.out.println(&quot;I don&#39;t know&quot;); } public static void oldCheckQQ(String qq) { int len = qq.length(); if (len &gt;= 5 &amp;&amp; len &lt;= 10) { if (!(qq.startsWith(&quot;0&quot;))) { try { long l = Long.parseLong(qq); System.out.println(&quot;登录成功&quot;); } catch (Exception e) { System.out.println(&quot;登录失败&quot;); } } else { System.out.println(&quot;不能0开头&quot;); } } else { System.out.println(&quot;长度错误&quot;); } } }举例2： package com.leo; public class Test9 { public static void main(String[] args) { matchPhoneNumber(&quot;18601088888&quot;); matchPhoneNumber(&quot;13912366666&quot;); matchPhoneNumber(&quot;13912366646&quot;); } public static void matchPhoneNumber (String str) { //1.定义正则表达式 String regex = &quot;1[3458]\\\\d{4}(\\\\d)\\\\1{4}&quot;; //2.匹配手机号是否符合规则 返回true或false boolean flag = str.matches(regex); if(flag) System.out.println(&quot;手机号码与规则相符!&quot;); else System.out.println(&quot;手机号码与规则不相符!&quot;); } }常用正则表达式 匹配中文字符的正则表达式：[u4e00-u9fa5] 评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 匹配双字节字符(包括汉字在内)：[^x00-xff] 评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 匹配空白行的正则表达式：ns*r 评注：可以用来删除空白行 匹配HTML标记的正则表达式：&lt;(S?)[^&gt;]&gt;.?&lt;/1&gt;|&lt;.? /&gt; 评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 匹配首尾空白字符的正则表达式：^s|s$ 评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 匹配Email地址的正则表达式：w+([-+.]w+)@w+([-.]w+).w+([-.]w+)* 评注：表单验证时很实用 匹配网址URL的正则表达式：[a-zA-z]+://[^s]* 评注：网上流传的版本功能很有限，上面这个基本可以满足需求 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 评注：表单验证时很实用 匹配国内电话号码：d{3}-d{8}|d{4}-d{7} 评注：匹配形式如 0511-4405222 或 021-87888822 匹配腾讯QQ号：[1-9][0-9]{4,} 评注：腾讯QQ号从10000开始 匹配中国邮政编码：[1-9]d{5}(?!d) 评注：中国邮政编码为6位数字 匹配身份证：d{15}|d{18} 评注：中国的身份证为15位或18位 匹配ip地址：d+.d+.d+.d+ 评注：提取ip地址时有用 匹配特定数字： ^[1-9]d*$ //匹配正整数 ^-[1-9]d*$ //匹配负整数 ^-?[1-9]d*$ //匹配整数 ^[1-9]d*|0$ //匹配非负整数（正整数 + 0） ^-[1-9]d*|0$ //匹配非正整数（负整数 + 0） ^[1-9]d*.d*|0.d*[1-9]d*$ //匹配正浮点数 ^-([1-9]d*.d*|0.d*[1-9]d*)$ //匹配负浮点数 ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$ //匹配浮点数 ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0） ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0） 评注：处理大量数据时有用，具体应用时注意修正 匹配特定字符串： ^[A-Za-z]+$ //匹配由26个英文字母组成的字符串 ^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串 ^[a-z]+$ //匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串 ^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"},{"name":"正则","slug":"正则","permalink":"https://okfood.vip/blog/tags/正则/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java反射技术","slug":"Java反射技术","date":"2014-05-23T01:35:14.000Z","updated":"2019-09-06T02:21:51.376Z","comments":true,"path":"2014/05/23/Java反射技术/","link":"","permalink":"https://okfood.vip/blog/2014/05/23/Java反射技术/","excerpt":"","text":"反射技术其实就是动态加载一个指定的类，并获取该类中的所有的内容。而且将字节码文件封装成对象，并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。 反射的好处：大大的增强了程序的扩展性。 反射的基本步骤1、获得Class对象，就是获取到指定的名称的字节码文件对象。 2、实例化对象，获得类的属性、方法或构造函数。 3、访问属性、调用方法、调用构造函数创建对象。 获取这个Class对象，有三种方式1：通过每个对象都具备的方法getClass来获取。弊端：必须要创建该类对象，才可以调用getClass方法。 2：每一个数据类型(基本数据类型和引用数据类型)都有一个静态的属性class。弊端：必须要先明确该类。 前两种方式不利于程序的扩展，因为都需要在程序使用具体的类来完成。 3：使用的Class类中的方法，静态的forName方法。 指定什么类名，就获取什么类字节码文件对象，这种方式的扩展性最强，只要将类名的字符串传入即可。 反射的用法1）、需要获得java类的各个组成部分，首先需要获得类的Class对象，获得Class对象的三种方式： Class.forName(classname) 用于做类加载 obj.getClass() 用于获得对象的类型 类名.class 用于获得指定的类型，传参用 // 1. 根据给定的类名来获得 用于类加载 String classname = &quot;com.leo.reflect.Person&quot;;// 来自配置文件 Class clazz = Class.forName(classname);// 此对象代表Person.class // 2. 如果拿到了对象，不知道是什么类型 用于获得对象的类型 Object obj = new Person(); Class clazz1 = obj.getClass();// 获得对象具体的类型 // 3. 如果是明确地获得某个类的Class对象 主要用于传参 Class clazz2 = Person.class;2)、反射类的成员方法： Class clazz = Person.class; Method method = clazz.getMethod(methodName, new Class[]{paramClazz1, paramClazz2}); method.invoke();3)、反射类的构造函数： Constructor con = clazz.getConstructor(new Class[]{paramClazz1, paramClazz2,...}) con.newInstance(params...)4)、反射类的属性： Field field = clazz.getField(fieldName); field.setAccessible(true); field.setObject(value);获取了字节码文件对象后，最终都需要创建指定类的对象： 创建对象的两种方式(其实就是对象在进行实例化时的初始化方式)： 1，调用空参数的构造函数：使用了Class类中的newInstance()方法。 2，调用带参数的构造函数：先要获取指定参数列表的构造函数对象，然后通过该构造函数的对象的newInstance(实际参数) 进行对象的初始化。 综上所述，第二种方式，必须要先明确具体的构造函数的参数类型，不便于扩展。所以一般情况下，被反射的类，内部通常都会提供一个公有的空参数的构造函数。 // 如何生成获取到字节码文件对象的实例对象。 Class clazz = Class.forName(&quot;cn.leo.bean.Person&quot;);//类加载 // 直接获得指定的类型 clazz = Person.class; // 根据对象获得类型 Object obj = new Person(&quot;zhangsan&quot;, 19); clazz = obj.getClass(); Object obj = clazz.newInstance();//该实例化对象的方法调用就是指定类中的空参数构造函数，给创建对象进行初始化。当指定类中没有空参数构造函数时，该如何创建该类对象呢？请看method_2(); public static void method_2() throws Exception { Class clazz = Class.forName(&quot;cn.leo.bean.Person&quot;); //既然类中没有空参数的构造函数,那么只有获取指定参数的构造函数,用该函数来进行实例化。 //获取一个带参数的构造器。 Constructor constructor = clazz.getConstructor(String.class,int.class); //想要对对象进行初始化，使用构造器的方法newInstance(); Object obj = constructor.newInstance(&quot;zhagnsan&quot;,30); //获取所有构造器。 Constructor[] constructors = clazz.getConstructors();//只包含公共的 constructors = clazz.getDeclaredConstructors();//包含私有的 for(Constructor con : constructors) { System.out.println(con); } }反射指定类中的方法： //获取类中所有的方法。 public static void method_1() throws Exception { Class clazz = Class.forName(&quot;cn.leo.bean.Person&quot;); Method[] methods = clazz.getMethods();//获取的是该类中的公有方法和父类中的公有方法。 methods = clazz.getDeclaredMethods();//获取本类中的方法，包含私有方法。 for(Method method : methods) { System.out.println(method); } } //获取指定方法； public static void method_2() throws Exception { Class clazz = Class.forName(&quot;cn.leo.bean.Person&quot;); //获取指定名称的方法。 Method method = clazz.getMethod(&quot;show&quot;, int.class,String.class); //想要运行指定方法，当然是方法对象最清楚，为了让方法运行，调用方法对象的invoke方法即可，但是方法运行必须要明确所属的对象和具体的实际参数。 Object obj = clazz.newInstance(); method.invoke(obj, 39,&quot;hehehe&quot;);//执行一个方法 } //想要运行私有方法。 public static void method_3() throws Exception { Class clazz = Class.forName(&quot;cn.leo.bean.Person&quot;); //想要获取私有方法。必须用getDeclearMethod(); Method method = clazz.getDeclaredMethod(&quot;method&quot;, null); // 私有方法不能直接访问，因为权限不够。非要访问，可以通过暴力的方式。 method.setAccessible(true);//一般很少用，因为私有就是隐藏起来，所以尽量不要访问。 } //反射静态方法。 public static void method_4() throws Exception { Class clazz = Class.forName(&quot;cn.leo.bean.Person&quot;); Method method = clazz.getMethod(&quot;function&quot;,null); method.invoke(null,null); }","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java网络编程","slug":"Java网络编程","date":"2014-05-23T01:24:28.000Z","updated":"2019-09-06T02:05:45.008Z","comments":true,"path":"2014/05/23/Java网络编程/","link":"","permalink":"https://okfood.vip/blog/2014/05/23/Java网络编程/","excerpt":"","text":"端口物理端口： 逻辑端口：用于标识进程的逻辑地址，不同进程的标识；有效端口：065535，其中01024系统使用或保留端口。 java 中ip对象：InetAddress. import java.net.*; class IPDemo{ public static void main(String[] args) throws UnknownHostException{ //通过名称(ip字符串or主机名)来获取一个ip对象。 InetAddress ip = InetAddress.getByName(&quot;www.baidu.com&quot;);//java.net.UnknownHostException System.out.println(&quot;addr:&quot;+ip.getHostAddress()); System.out.println(&quot;name:&quot;+ip.getHostName()); } }Socket：套接字，通信的端点。 就是为网络服务提供的一种机制，通信的两端都有Socket，网络通信其实就是Socket间的通信，数据在两个Socket间通过IO传输。 UDP传输1，只要是网络传输，必须有socket 。 2，数据一定要封装到数据包中，数据包中包括目的地址、端口、数据等信息。 直接操作udp不可能，对于java语言应该将udp封装成对象，易于我们的使用，这个对象就是DatagramSocket. 封装了udp传输协议的socket对象。 因为数据包中包含的信息较多，为了操作这些信息方便，也一样会将其封装成对象。这个数据包对象就是：DatagramPacket.通过这个对象中的方法，就可以获取到数据包中的各种信息。 DatagramSocket具备发送和接受功能，在进行udp传输时，需要明确一个是发送端，一个是接收端。 udp的发送端1，建立udp的socket服务，创建对象时如果没有明确端口，系统会自动分配一个未被使用的端口。 2，明确要发送的具体数据。 3，将数据封装成了数据包。 4，用socket服务的send方法将数据包发送出去。 5，关闭资源。 import java.net.*; class UdpSend{ public static void main(String[] args)throws Exception { // 1，建立udp的socket服务。 DatagramSocket ds = new DatagramSocket(9999);//指定发送端口，不指定系统会随机分配。 // 2，明确要发送的具体数据。 String text = &quot;udp传输演示 哥们来了&quot;; byte[] buf = text.getBytes(); // 3，将数据封装成了数据包。 DatagramPacket dp = new DatagramPacket(buf, buf.length,InetAddress.getByName(&quot;172.23.13.5&quot;),10000); // 4，用socket服务的send方法将数据包发送出去。 ds.send(dp); // 5，关闭资源。 ds.close(); } }udp的接收端1，创建udp的socket服务，必须要明确一个端口，作用在于，只有发送到这个端口的数据才是这个接收端可以处理的数据。 2，定义数据包，用于存储接收到数据。 3，通过socket服务的接收方法将收到的数据存储到数据包中。 4，通过数据包的方法获取数据包中的具体数据内容，比如ip、端口、数据等等。 5，关闭资源。 class UdpRece { public static void main(String[] args) throws Exception{ // 1，创建udp的socket服务。 DatagramSocket ds = new DatagramSocket(9999); // 2，定义数据包，用于存储接收到数据。先定义字节数组，数据包会把数据存储到字节数组中。 byte[] buf = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf,buf.length); // 3，通过socket服务的接收方法将收到的数据存储到数据包中。 ds.receive(dp);//该方法是阻塞式方法。 // 4，通过数据包的方法获取数据包中的具体数据内容，比如ip，端口，数据等等。 String ip = dp.getAddress().getHostAddress(); int port = dp.getPort(); String text = new String(dp.getData(),0,dp.getLength());//将字节数组中的有效部分转成字符串。 System.out.println(ip+&quot;:&quot;+port+&quot;--&quot;+text); // 5，关闭资源。 ds.close(); } }TCP传输两个端点的建立连接后会有一个传输数据的通道，这通道称为流，而且是建立在网络基础上的流，称之为socket流。该流中既有读取，也有写入。 tcp的两个端点：一个是客户端，一个是服务端。 客户端：对应的对象，Socket 服务端：对应的对象，ServerSocket TCP客户端1，建立tcp的socket服务，最好明确具体的地址和端口。这个对象在创建时，就已经可以对指定ip和端口进行连接(三次握手)。 2，如果连接成功，就意味着通道建立了，socket流就已经产生了。只要获取到socket流中的读取流和写入流即可，只要通过getInputStream和getOutputStream就可以获取两个流对象。 3，关闭资源。 import java.net.*; import java.io.*; //需求：客户端给服务器端发送一个数据。 class TcpClient{ public static void main(String[] args) throws Exception{ Socket s = new Socket(&quot;172.23.13.5&quot;,8888); OutputStream out = s.getOutputStream();//获取了socket流中的输出流对象。 out.write(&quot;tcp演示，哥们又来了!&quot;.getBytes()); s.close(); } }TCP服务端1，创建服务端socket服务，并监听一个端口。 2，服务端为了给客户端提供服务，获取客户端的内容，可以通过accept方法获取连接过来的客户端对象。 3，可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。 4，如果通讯结束，关闭资源。注意：要先关客户端，再关服务端。 class TcpServer{ public static void main(String[] args) throws Exception{ ServerSocket ss = new ServerSocket(8888);//建立服务端的socket服务 Socket s = ss.accept();//获取客户端对象 String ip = s.getInetAddress().getHostAddress(); System.out.println(ip+&quot;.....connected&quot;); // 可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。 InputStream in = s.getInputStream();//读取客户端的数据，使用客户端对象的socket读取流 byte[] buf = new byte[1024]; int len = in.read(buf); String text = new String(buf,0,len); System.out.println(text); // 如果通讯结束，关闭资源。注意：要先关客户端，在关服务端。 s.close(); ss.close(); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"},{"name":"网络编程","slug":"网络编程","permalink":"https://okfood.vip/blog/tags/网络编程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java IO流","slug":"Java IO流","date":"2014-05-20T08:08:04.000Z","updated":"2019-09-05T10:33:56.179Z","comments":true,"path":"2014/05/20/Java IO流/","link":"","permalink":"https://okfood.vip/blog/2014/05/20/Java IO流/","excerpt":"","text":"IO流用于处理设备上数据。 流：可以理解数据的流动，就是一个数据流。IO流最终要以对象来体现，对象都存在IO包中。 流也进行分类： 1：输入流（读）和输出流（写）。 2：因为处理的数据不同，分为字节流和字符流。 字节流：处理字节数据的流对象。设备上的数据无论是图片或者dvd，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。 那么为什么要有字符流呢？因为字符每个国家都不一样，所以涉及到了字符编码问题，那么GBK编码的中文用unicode编码解析是有问题的，所以需要获取中文字节数据的同时+ 指定的编码表才可以解析正确数据。为了方便于文字的解析，所以将字节流和编码表封装成对象，这个对象就是字符流。只要操作字符数据，优先考虑使用字符流体系。 注意：流的操作只有两种：读和写。 流的体系因为功能不同，但是有共性内容，不断抽取，形成继承体系。该体系一共有四个基类，而且都是抽象类。 字节流：InputStream OutputStream 字符流：Reader Writer 在这四个系统中，它们的子类，都有一个共性特点：子类名后缀都是父类名，前缀名都是这个子类的功能名称。 public static void main(String[] args) throws IOException { //读、写都会发生IO异常 /* 1：创建一个字符输出流对象，用于操作文件。该对象一建立，就必须明确数据存储位置，是一个文件。 2：对象产生后，会在堆内存中有一个实体，同时也调用了系统底层资源，在指定的位置创建了一个存储数据的文件。 3：如果指定位置，出现了同名文件，文件会被覆盖。 */ FileWriter fw = new FileWriter(&quot;demo.txt&quot;); // FileNotFoundException /* 调用Writer类中的write方法写入字符串。字符串并未直接写入到目的地中，而是写入到了流中，(其实是写入到内存缓冲区中)。怎么把数据弄到文件中？ */ fw.write(&quot;abcde&quot;); fw.flush(); // 刷新缓冲区，将缓冲区中的数据刷到目的地文件中。 fw.close(); // 关闭流，其实关闭的就是java调用的系统底层资源。在关闭前，会先刷新该流。 }close()和flush()的区别： flush()：将缓冲区的数据刷到目的地中后，流可以使用。 close()：将缓冲区的数据刷到目的地中后，流就关闭了，该方法主要用于结束调用的底层资源。这个动作一定做。 io异常的处理方式： io一定要写finally； FileWriter写入数据的细节： 1：window中的换行符：\\r\\n两个符号组成。 linux：\\n。 2：续写数据，只要在构造函数中传入新的参数true。 3：目录分割符：window \\ public static void main(String[] args) { FileWriter fw = null; try { fw = new FileWriter(&quot;demo.txt&quot;,true); fw.write(&quot;abcde&quot;); } catch (IOException e ){ System.out.println(e.toString()+&quot;....&quot;); } finally{ if(fw!=null) try{ fw.close(); } catch (IOException e){ System.out.println(&quot;close:&quot;+e.toString()); } } }FileReader：使用Reader体系，读取一个文本文件中的数据。返回 -1 ，标志读到结尾。 import java.io.*; class FileReaderDemo { public static void main(String[] args) throws IOException { /* 创建可以读取文本文件的流对象，FileReader让创建好的流对象和指定的文件相关联。 */ FileReader fr = new FileReader(&quot;demo.txt&quot;); int ch = 0; while((ch = fr.read())!= -1) { //条件是没有读到结尾 System.out.println((char)ch); //调用读取流的read方法，读取一个字符。 } fr.close(); } }读取数据的第二种方式：第二种方式较为高效，自定义缓冲区。 import java.io.*; class FileReaderDemo2 { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(&quot;demo.txt&quot;); //创建读取流对象和指定文件关联。 //因为要使用read(char[])方法，将读取到字符存入数组。所以要创建一个字符数组，一般数组的长度都是1024的整数倍。 char[] buf = new char[1024]; int len = 0; while(( len=fr.read(buf)) != -1) { System.out.println(new String(buf,0,len)); } fr.close(); } }IO中的使用到了一个设计模式：装饰设计模式。 装饰设计模式解决：对一组类进行功能的增强。 包装：写一个类(包装类)对被包装对象进行包装； 1、包装类和被包装对象要实现同样的接口； 2、包装类要持有一个被包装对象； 3、包装类在实现接口时，大部分方法是靠调用被包装对象来实现的，对于需要修改的方法我们自己实现； 字符流Reader：用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。 |—BufferedReader：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。 |—LineNumberReader：跟踪行号的缓冲字符输入流。此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号。 |—InputStreamReader：是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 |—FileReader：用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。 |—CharArrayReader： |—StringReader： Writer：写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。 |—BufferedWriter：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 |—OutputStreamWriter：是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 |—FileWriter：用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。 |—PrintWriter： |—CharArrayWriter： |—StringWriter： 字节流InputStream：是表示字节输入流的所有类的超类。 |— FileInputStream：从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。 |— FilterInputStream：包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。 |— BufferedInputStream：该类实现缓冲的输入流。 |— Stream： |— ObjectInputStream： |— PipedInputStream： OutputStream：此抽象类是表示输出字节流的所有类的超类。 |— FileOutputStream：文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。 |— FilterOutputStream：此类是过滤输出流的所有类的超类。 |— BufferedOutputStream：该类实现缓冲的输出流。 |— PrintStream： |— DataOutputStream： |— ObjectOutputStream： |— PipedOutputStream： 缓冲区是提高效率用的，给谁提高呢？ BufferedWriter：是给字符输出流提高效率用的，那就意味着，缓冲区对象建立时，必须要先有流对象。明确要提高具体的流对象的效率。 FileWriter fw = new FileWriter(&quot;bufdemo.txt&quot;); BufferedWriter bufw = new BufferedWriter(fw);//让缓冲区和指定流相关联。 for(int x=0; x&lt;4; x++){ bufw.write(x+&quot;abc&quot;); bufw.newLine(); //写入一个换行符，这个换行符可以依据平台的不同写入不同的换行符。 bufw.flush();//对缓冲区进行刷新，可以让数据到目的地中。 } bufw.close();//关闭缓冲区，其实就是在关闭具体的流。BufferedReader： FileReader fr = new FileReader(&quot;bufdemo.txt&quot;); BufferedReader bufr = new BufferedReader(fr); String line = null; while((line=bufr.readLine())!=null){ //readLine方法返回的时候是不带换行符的。 System.out.println(line); } bufr.close(); //记住，只要一读取键盘录入，就用这句话。 BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));//输出到控制台 String line = null; while((line=bufr.readLine())!=null){ if(&quot;over&quot;.equals(line)) break; bufw.write(line.toUpperCase());//将输入的字符转成大写字符输出 bufw.newLine(); bufw.flush(); } bufw.close(); bufr.close();流对象：其实很简单，就是读取和写入。但是因为功能的不同，流的体系中提供N多的对象。那么开始时，到底该用哪个对象更为合适呢？这就需要明确流的操作规律。 流的操作规律： 1，明确源和目的。 数据源：就是需要读取，可以使用两个体系：InputStream、Reader； 数据汇：就是需要写入，可以使用两个体系：OutputStream、Writer； 2，操作的数据是否是纯文本数据？ 如果是：数据源：Reader 数据汇：Writer 如果不是：数据源：InputStream 数据汇：OutputStream 3，虽然确定了一个体系，但是该体系中有太多的对象，到底用哪个呢？ 明确操作的数据设备。 数据源对应的设备：硬盘(File)，内存(数组)，键盘(System.in) 数据汇对应的设备：硬盘(File)，内存(数组)，控制台(System.out)。 4，需要在基本操作上附加其他功能吗？比如缓冲。 如果需要就进行装饰。 转换流特有功能：转换流可以将字节转成字符，原因在于，将获取到的字节通过查编码表获取到指定对应字符。 转换流的最强功能就是基于 字节流 + 编码表 。没有转换，没有字符流。 发现转换流有一个子类就是操作文件的字符流对象： InputStreamReader |–FileReader OutputStreamWriter |–FileWrier 想要操作文本文件，必须要进行编码转换，而编码转换动作转换流都完成了。所以操作文件的流对象只要继承自转换流就可以读取一个字符了。 但是子类有一个局限性，就是子类中使用的编码是固定的，是本机默认的编码表，对于简体中文版的系统默认码表是GBK。 FileReader fr = new FileReader(&quot;a.txt&quot;); InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;gbk&quot;);以上两句代码功能一致， 如果仅仅使用平台默认码表，就使用FileReader fr = new FileReader(“a.txt”); //因为简化。 如果需要制定码表，必须用转换流。 转换流 = 字节流+编码表。 转换流的子类File = 字节流 + 默认编码表。 凡是操作设备上的文本数据，涉及编码转换，必须使用转换流。 File类将文件系统中的文件和文件夹封装成了对象。提供了更多的属性和行为可以对这些文件和文件夹进行操作。这些是流对象办不到的，因为流只操作数据。 File类常见方法： 1：创建。 boolean createNewFile()：在指定目录下创建文件，如果该文件已存在，则不创建。而对操作文件的输出流而言，输出流对象已建立，就会创建文件，如果文件已存在，会覆盖。除非续写。 boolean mkdir()：创建此抽象路径名指定的目录。 boolean mkdirs()：创建多级目录。 2：删除。 boolean delete()：删除此抽象路径名表示的文件或目录。 void deleteOnExit()：在虚拟机退出时删除。 注意：在删除文件夹时，必须保证这个文件夹中没有任何内容，才可以将该文件夹用delete删除。 window的删除动作，是从里往外删。注意：java删除文件不走回收站。要慎用。 3：获取. long length()：获取文件大小。 String getName()：返回由此抽象路径名表示的文件或目录的名称。 String getPath()：将此抽象路径名转换为一个路径名字符串。 String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串。 String getParent()：返回此抽象路径名父目录的抽象路径名，如果此路径名没有指定父目录，则返回 null。 long lastModified()：返回此抽象路径名表示的文件最后一次被修改的时间。 File.pathSeparator：返回当前系统默认的路径分隔符，windows默认为 “；”。 File.Separator：返回当前系统默认的目录分隔符，windows默认为 “\\”。 4：判断： boolean exists()：判断文件或者文件夹是否存在。 boolean isDirectory()：测试此抽象路径名表示的文件是否是一个目录。 boolean isFile()：测试此抽象路径名表示的文件是否是一个标准文件。 boolean isHidden()：测试此抽象路径名指定的文件是否是一个隐藏文件。 boolean isAbsolute()：测试此抽象路径名是否为绝对路径名。 5：重命名。 boolean renameTo(File dest)：可以实现移动的效果。剪切+重命名。 String[] list()：列出指定目录下的当前的文件和文件夹的名称。包含隐藏文件。 如果调用list方法的File 对象中封装的是一个文件，那么list方法返回数组为null。如果封装的对象不存在也会返回null。只有封装的对象存在并且是文件夹时，这个方法才有效。 递归就是函数自身调用自身。 什么时候用递归呢？ 当一个功能被重复使用，而每一次使用该功能时的参数不确定，都由上次的功能元素结果来确定。 简单说：功能内部又用到该功能，但是传递的参数值不确定。(每次功能参与运算的未知内容不确定)。 递归的注意事项： 1：一定要定义递归的条件。 2：递归的次数不要过多。容易出现 StackOverflowError 栈内存溢出错误。 其实递归就是在栈内存中不断的加载同一个函数。 Java.util.Properties：一个可以将键值进行持久化存储的对象。Map–Hashtable的子类。 Map|–Hashtable |–Properties：用于属性配置文件，键和值都是字符串类型。 特点：1：可以持久化存储数据。2：键值都是字符串。3：一般用于配置文件。 |– load()：将流中的数据加载进集合。 原理：其实就是将读取流和指定文件相关联，并读取一行数据，因为数据是规则的key=value，所以获取一行后，通过 = 对该行数据进行切割，左边就是键，右边就是值，将键、值存储到properties集合中。 |– store()：写入各个项后，刷新输出流。 |– list()：将集合的键值数据列出到指定的目的地。 以下介绍IO包中扩展功能的流对象：基本都是装饰设计模式。 Java.io.outputstream.PrintStream：打印流 1：提供了更多的功能，比如打印方法。可以直接打印任意类型的数据。 2：它有一个自动刷新机制，创建该对象，指定参数，对于指定方法可以自动刷新。 3：它使用的本机默认的字符编码. 4：该流的print方法不抛出IOException。 该对象的构造函数。 PrintStream(File file) ：创建具有指定文件且不带自动行刷新的新打印流。 PrintStream(File file, String csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 PrintStream(OutputStream out) ：创建新的打印流。 PrintStream(OutputStream out, boolean autoFlush) ：创建新的打印流。 PrintStream(OutputStream out, boolean autoFlush, String encoding) ：创建新的打印流。 PrintStream(String fileName) ：创建具有指定文件名称且不带自动行刷新的新打印流。 PrintStream(String fileName, String csn) PrintStream可以操作目的：1：File对象。2：字符串路径。3：字节输出流。 前两个都JDK1.5版本才出现。而且在操作文本文件时，可指定字符编码了。 当目的是一个字节输出流时，如果使用的println方法，可以在printStream对象上加入一个true参数。这样对于println方法可以进行自动的刷新，而不是等待缓冲区满了再刷新。最终print方法都将具体的数据转成字符串，而且都对IO异常进行了内部处理。 既然操作的数据都转成了字符串，那么使用PrintWriter更好一些。因为PrintWrite是字符流的子类，可以直接操作字符数据，同时也可以指定具体的编码。 PrintWriter：具备了PrintStream的特点同时，还有自身特点： 该对象的目的地有四个：1：File对象。2：字符串路径。3：字节输出流。4：字符输出流。 开发时尽量使用PrintWriter。 方法中直接操作文件的第二参数是编码表。 直接操作输出流的，第二参数是自动刷新。 //读取键盘录入将数据转成大写显示在控制台. BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));//源：键盘输入 //目的：把数据写到文件中，还想自动刷新。 PrintWriter out = new PrintWriter(new FileWriter(&quot;out.txt&quot;),true);//设置true后自动刷新 String line = null; while((line=bufr.readLine())!=null){ if(&quot;over&quot;.equals(line)) break; out.println(line.toUpperCase());//转大写输出 } //注意：System.in，System.out这两个标准的输入输出流，在jvm启动时已经存在了。随时可以使用。当jvm结束了，这两个流就结束了。但是，当使用了显示的close方法关闭时，这两个流在提前结束了。 out.close(); bufr.close();SequenceInputStream：序列流，作用就是将多个读取流合并成一个读取流。实现数据合并。 表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。 这样做，可以更方便的操作多个读取流，其实这个序列流内部会有一个有序的集合容器，用于存储多个读取流对象。 该对象的构造函数参数是枚举，想要获取枚举，需要有Vector集合，但不高效。需用ArrayList，但ArrayList中没有枚举，只有自己去创建枚举对象。 但是方法怎么实现呢？因为枚举操作的是具体集合中的元素，所以无法具体实现，但是枚举和迭代器是功能一样的，所以，可以用迭代替代枚举。 合并原理：多个读取流对应一个输出流。 切割原理：一个读取流对应多个输出流。 import java.io.*; import java.util.*; class SplitFileDemo{ private static final String CFG = &quot;.properties&quot;; private static final String SP = &quot;.part&quot;; public static void main(String[] args) throws IOException{ File file = new File(&quot;c:\\\\0.bmp&quot;); File dir = new File(&quot;c:\\\\partfiles&quot;); meger(dir); } //数据的合并。 public static void meger(File dir)throws IOException{ if(!(dir.exists() &amp;&amp; dir.isDirectory())) throw new RuntimeException(&quot;指定的目录不存在，或者不是正确的目录&quot;); File[] files = dir.listFiles(new SuffixFilter(CFG)); if(files.length==0) throw new RuntimeException(&quot;扩展名.proerpties的文件不存在&quot;); //获取到配置文件 File config = files[0]; //获取配置文件的信息。 Properties prop = new Properties(); FileInputStream fis = new FileInputStream(config); prop.load(fis); String fileName = prop.getProperty(&quot;filename&quot;); int partcount = Integer.parseInt(prop.getProperty(&quot;partcount&quot;)); //-------------------------- File[] partFiles = dir.listFiles(new SuffixFilter(SP)); if(partFiles.length!=partcount) throw new RuntimeException(&quot;缺少碎片文件&quot;); //--------------------- ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;(); for(int x=0; x&lt;partcount; x++){ al.add(new FileInputStream(new File(dir,x+SP))); } Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al); SequenceInputStream sis = new SequenceInputStream(en); File file = new File(dir,fileName); FileOutputStream fos = new FileOutputStream(file); byte[] buf = new byte[1024]; int len = 0; while((len=sis.read(buf))!=-1){ fos.write(buf,0,len); } fos.close(); sis.close(); } //带有配置信息的数据切割。 public static void splitFile(File file)throws IOException{ //用一个读取流和文件关联。 FileInputStream fis = new FileInputStream(file); //创建目的地。因为有多个。所以先创建引用。 FileOutputStream fos = null; //指定碎片的位置。 File dir = new File(&quot;c:\\\\partfiles&quot;); if(!dir.exists()) dir.mkdir(); //碎片文件大小引用。 File f = null; byte[] buf = new byte[1024*1024]; //因为切割完的文件通常都有规律的。为了简单标记规律使用计数器。 int count = 0; int len = 0; while((len=fis.read(buf))!=-1){ f = new File(dir,(count++)+&quot;.part&quot;); fos = new FileOutputStream(f); fos.write(buf,0,len); fos.close(); } //碎片文件生成后，还需要定义配置文件记录生成的碎片文件个数。以及被切割文件的名称。 //定义简单的键值信息，可是用Properties。 String filename = file.getName(); Properties prop = new Properties(); prop.setProperty(&quot;filename&quot;,filename); prop.setProperty(&quot;partcount&quot;,count+&quot;&quot;); File config = new File(dir,count+&quot;.properties&quot;); fos = new FileOutputStream(config); prop.store(fos,&quot;&quot;); fos.close(); fis.close(); } } class SuffixFilter implements FileFilter{ private String suffix; SuffixFilter(String suffix){ this.suffix = suffix; } public boolean accept(File file){ return file.getName().endsWith(suffix); } }RandomAccessFile 特点： 1：该对象即可读取，又可写入。 2：该对象中的定义了一个大型的byte数组，通过定义指针来操作这个数组。 3：可以通过该对象的getFilePointer()获取指针的位置，通过seek()方法设置指针的位置。 4：该对象操作的源和目的必须是文件。 5：其实该对象内部封装了字节读取流和字节写入流。 注意：实现随机访问，最好是数据有规律。 class RandomAccessFileDemo{ public static void main(String[] args) throws IOException{ write(); read(); randomWrite(); } //随机写入数据，可以实现已有数据的修改。 public static void randomWrite()throws IOException{ RandomAccessFile raf = new RandomAccessFile(&quot;random.txt&quot;,&quot;rw&quot;); raf.seek(8*4); System.out.println(&quot;pos :&quot;+raf.getFilePointer()); raf.write(&quot;王武&quot;.getBytes()); raf.writeInt(102); raf.close(); } public static void read()throws IOException{ RandomAccessFile raf = new RandomAccessFile(&quot;random.txt&quot;,&quot;r&quot;);//只读模式。 //指定指针的位置。 raf.seek(8*1);//实现随机读取文件中的数据。注意：数据最好有规律。 System.out.println(&quot;pos1 :&quot;+raf.getFilePointer()); byte[] buf = new byte[4]; raf.read(buf); String name = new String(buf); int age = raf.readInt(); System.out.println(name+&quot;::&quot;+age); System.out.println(&quot;pos2 :&quot;+raf.getFilePointer()); raf.close(); } public static void write()throws IOException{ //rw：当这个文件不存在，会创建该文件。当文件已存在，不会创建。所以不会像输出流一样覆盖。 RandomAccessFile raf = new RandomAccessFile(&quot;random.txt&quot;,&quot;rw&quot;);//rw读写模式 //往文件中写入人的基本信息，姓名，年龄。 raf.write(&quot;张三&quot;.getBytes()); raf.writeInt(97); raf.close(); } }管道流：管道读取流和管道写入流可以像管道一样对接上，管道读取流就可以读取管道写入流写入的数据。 注意：需要加入多线程技术，因为单线程，先执行read，会发生死锁，因为read方法是阻塞式的，没有数据的read方法会让线程等待。 public static void main(String[] args) throws IOException{ PipedInputStream pipin = new PipedInputStream(); PipedOutputStream pipout = new PipedOutputStream(); pipin.connect(pipout); new Thread(new Input(pipin)).start(); new Thread(new Output(pipout)).start(); }对象的序列化：目的：将一个具体的对象进行持久化，写入到硬盘上。 注意：静态数据不能被序列化，因为静态数据不在堆内存中，是存储在静态方法区中。 如何将非静态的数据不进行序列化？用transient 关键字修饰此变量即可。 Serializable：用于启动对象的序列化功能，可以强制让指定类具备序列化功能，该接口中没有成员，这是一个标记接口。这个标记接口用于给序列化类提供UID。这个uid是依据类中的成员的数字签名进行运行获取的。如果不需要自动获取一个uid，可以在类中，手动指定一个名称为serialVersionUID id号。依据编译器的不同，或者对信息的高度敏感性。最好每一个序列化的类都进行手动显示的UID的指定。 import java.io.*; class ObjectStreamDemo { public static void main(String[] args) throws Exception{ writeObj(); readObj(); } public static void readObj()throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;obj.txt&quot;)); Object obj = ois.readObject();//读取一个对象。 System.out.println(obj.toString()); } public static void writeObj()throws IOException{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;obj.txt&quot;)); oos.writeObject(new Person(&quot;lisi&quot;,25)); //写入一个对象。 oos.close(); } } class Person implements Serializable{ private static final long serialVersionUID = 42L; private transient String name;//用transient修饰后name将不会进行序列化 public int age; Person(String name,int age){ this.name = name; this.age = age; } public String toString(){ return name+&quot;::&quot;+age; } }DataOutputStream、DataInputStream：专门用于操作基本数据类型数据的对象。 DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;data.txt&quot;)); dos.writeInt(256); dos.close(); DataInputStream dis = new DataInputStream(new FileInputStream(&quot;data.txt&quot;)); int num = dis.readInt(); System.out.println(num); dis.close();ByteArrayInputStream：源：内存 ByteArrayOutputStream：目的：内存。 这两个流对象不涉及底层资源调用，操作的都是内存中数组，所以不需要关闭。 直接操作字节数组就可以了，为什么还要把数组封装到流对象中呢？因为数组本身没有方法，只有一个length属性。为了便于数组的操作，将数组进行封装，对外提供方法操作数组中的元素。 对于数组元素操作无非两种操作：设置（写）和获取（读），而这两操作正好对应流的读写操作。这两个对象就是使用了流的读写思想来操作数组。 //创建源： ByteArrayInputStream bis = new ByteArrayInputStream(&quot;abcdef&quot;.getBytes()); //创建目的： ByteArrayOutputStream bos = new ByteArrayOutputStream(); int ch = 0; while((ch=bis.read())!=-1){ bos.write(ch); } System.out.println(bos.toString());","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java集合框架","slug":"Java集合框架","date":"2014-05-14T04:30:38.000Z","updated":"2019-09-05T09:34:19.368Z","comments":true,"path":"2014/05/14/Java集合框架/","link":"","permalink":"https://okfood.vip/blog/2014/05/14/Java集合框架/","excerpt":"","text":"集合框架用于存储数据的容器。 特点： 1：对象封装数据，对象多了也需要存储。集合用于存储对象。 2：对象的个数确定可以使用数组，但是不确定怎么办？可以用集合。因为集合是可变长度的。 集合和数组的区别： 1：数组是固定长度的；集合可变长度的。 2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。 3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。 数据结构：就是容器中存储数据的方式。 对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。 集合容器在不断向上抽取过程中。出现了集合体系。 在使用一个体系时，原则：参阅顶层内容。建立底层对象。 Collection接口Collection|–List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。 |–Set：无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。 1，添加： add(object)：添加一个元素 addAll(Collection) ：添加一个集合中的所有元素。 2，删除： clear()：将集合中的元素全删除，清空集合。 remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。 removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。 3，判断： boolean contains(obj) ：集合中是否包含指定元素 。 boolean containsAll(Collection) ：集合中是否包含指定的多个元素。 boolean isEmpty()：集合中是否有元素。 4，获取： int size()：集合中有几个元素。 5，取交集： boolean retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。 6，获取集合中所有元素： Iterator iterator()：迭代器 7，将集合变成数组： toArray(); Iterator接口迭代器：是一个接口。作用：用于取集合中的元素。 每一个集合都有自己的数据结构，都有特定的取出自己内部元素的方式。为了便于操作所有的容器，取出元素。将容器内部的取出方式按照一个统一的规则向外提供，这个规则就是Iterator接口。 也就说，只要通过该接口就可以取出Collection集合中的元素，至于每一个具体的容器依据自己的数据结构，如何实现的具体取出细节，这个不用关心，这样就降低了取出元素和具体集合的耦合性。 Iterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是是什么不重要。这对象肯定符合一个规则Iterator接口。 List接口List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。 List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。 |–ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。 |–LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。 |–Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。 1，添加： add(index,element) ：在指定的索引位插入元素。 addAll(index,collection) ：在指定的索引位插入一堆元素。 2，删除： remove(index) ：删除指定索引位的元素。 返回被删的元素。 3，获取： Object get(index) ：通过索引获取指定元素。 int indexOf(obj) ：获取指定元素第一次出现的索引位，如果该元素不存在返回-1； 所以，通过-1，可以判断一个元素是否存在。 int lastIndexOf(Object o) ：反向索引指定元素的位置。 List subList(start,end) ：获取子列表。 4，修改： Object set(index,element) ：对指定索引位进行元素的修改。 5，获取所有元素： ListIterator listIterator()：list集合特有的迭代器。 List集合支持对元素的增、删、改、查。 List集合因为角标有了自己的获取元素的方式： 遍历。 for(int x=0; x&lt;list.size(); x++){ sop(“get:”+list.get(x)); } 在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。会发生.ConcurrentModificationException并发修改异常。 导致的原因是： 集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。 如何解决呢？ 既然是在迭代中对元素进行操作,找迭代器的方法最为合适.可是Iterator中只有hasNext,next,remove方法.通过查阅的它的子接口,ListIterator,发现该列表迭代器接口具备了对元素的增、删、改、查的动作。 ListIterator是List集合特有的迭代器。 ListIterator it = list.listIterator;//取代Iterator it = list.iterator; 可变长度数组的原理： 当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。 ArrayList：是按照原数组的50%延长。构造一个初始容量为 10 的空列表。 Vector：是按照原数组的100%延长。 注意：对于list集合，底层判断元素是否相同，其实用的是元素自身的equals方法完成的。所以建议元素都要复写equals方法，建立元素对象自己的比较相同的条件依据。 LinkedList：的特有方法。 addFirst(); addLast(); 在jdk1.6以后。 offerFirst(); offerLast(); getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException; getLast(); 在jdk1.6以后。 peekFirst();获取链表中的第一个元素。如果链表为空，返回null。 peekLast(); removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementException removeLast(); 在jdk1.6以后。 pollFirst();获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。 pollLast(); Set接口Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一种，迭代器。 |–HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效； HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。 当元素的hashCode值相同时，才继续判断元素的equals是否为true。 如果为true，那么视为相同元素，不存。如果为false，那么存储。 如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。 |–LinkedHashSet：有序，hashset的子类。 |–TreeSet：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。 哈希表的原理1，对对象元素中的关键字(对象中的特有数据)，进行哈希算法的运算，并得出一个具体的算法值，这个值 称为哈希值。 2，哈希值就是这个元素的位置。 3，如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础 +1顺延。 4，存储哈希值的结构，我们称为哈希表。 5，既然哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。 这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。 对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。 对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。 TreeSet用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。 如果元素不具备比较性，在运行时会发生ClassCastException异常。 所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。 依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。 TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。 注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。 在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。 TreeSet集合排序有两种方式，Comparable和Comparator区别： 1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。 2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。 第二种方式较为灵活。 Map集合|–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。 |–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable. |–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。 Map集合存储和Collection有着很大不同： Collection一次存一个元素；Map一次存一对元素。 Collection是单列集合；Map是双列集合。 Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。 特点：要保证map集合中键的唯一性。 1，添加。 put(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。 void putAll(Map); 2，删除。 void clear()：清空 value remove(key) ：删除指定键。 3，判断。 boolean isEmpty()： boolean containsKey(key)：是否包含key boolean containsValue(value) ：是否包含value 4，取出。 int size()：返回长度 value get(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。 Collection values()：获取map集合中的所有的值。 5，想要获取map中的所有元素： 原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。 把map集合转成set的方法： Set keySet(); Set entrySet();//取的是键和值的映射关系。 Entry就是Map接口中的内部接口； 为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。 取出map集合中所有元素的方式一：keySet()方法。 可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。 取出map集合中所有元素的方式二：entrySet()方法。 举例： //第一种取出方式 Set&lt;Student&gt; keySet = hm.keySet(); Iterator&lt;Student&gt; it = keySet.iterator(); while(it.hasNext()) { Student stu = it.next(); String addr = hm.get(stu); System.out.println(stu+&quot;...&quot;+addr); } //第二种取出方式 Set&lt;Map.Entry&lt;Student,String&gt;&gt; entrySet = hm.entrySet(); Iterator&lt;Map.Entry&lt;Student,String&gt;&gt; iter = entrySet.iterator(); while(iter.hasNext()) { Map.Entry&lt;Student,String&gt; me = iter.next(); Student stu = me.getKey(); String addr = me.getValue(); System.out.println(stu+&quot;-----&quot;+addr); }使用集合的技巧： 看到Array就是数组结构，有角标，查询速度很快。 看到link就是链表结构：增删速度快，而且有特有方法。addFirst； addLast； removeFirst()； removeLast()； getFirst()；getLast()； 看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。 看到tree就是二叉树，就要想到排序，就想要用到比较。 比较的两种方式： 一个是Comparable：覆盖compareTo方法； 一个是Comparator：覆盖compare方法。 LinkedHashSet，LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序。 集合什么时候用？ 当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。 保证唯一，就用Set。不保证唯一，就用List。 Collections它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。 静态方法： Collections.sort(list);//list集合进行元素的自然顺序排序。 Collections.sort(list,new ComparatorByLen());//按指定的比较器方法排序。 Collections.max(list); //返回list中字典顺序最大的元素。 int index = Collections.binarySearch(list,”zz”);//二分查找，返回角标。 Collections.reverseOrder();//逆向反转排序。 Collections.shuffle(list);//随机对list中的元素进行位置的置换。 将非同步集合转成同步集合的方法：Collections中的 XXX synchronizedXXX(XXX); List synchronizedList(list); Map synchronizedMap(map); 原理：定义一个类，将集合所有的方法加同一把锁后返回。 Collection 和 Collections的区别： Collections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。 Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。 Arrays用于操作数组对象的工具类，里面都是静态方法。 asList方法：将数组转换成list集合。 String[] arr = {“abc”,”kk”,”qq”}; List list = Arrays.asList(arr);//将arr数组转成list集合。 将数组转换成集合，有什么好处呢？用aslist方法，将数组变成集合； 可以通过list集合中的方法来操作数组中的元素：isEmpty()、contains、indexOf、set； 注意（局限性）：数组是固定长度，不可以使用集合对象增加或者删除等，会改变数组长度的功能方法。比如add、remove、clear。（会报不支持操作异常UnsupportedOperationException）； 如果数组中存储的引用数据类型，直接作为集合的元素可以直接用集合方法操作。 如果数组中存储的是基本数据类型，asList会将数组实体作为集合元素存在。 集合变数组：用的是Collection接口中的方法：toArray(); 如果给toArray传递的指定类型的数据长度小于了集合的size，那么toArray方法，会自定再创建一个该类型的数据，长度为集合的size。 如果传递的指定的类型的数组的长度大于了集合的size，那么toArray方法，就不会创建新数组，直接使用该数组即可，并将集合中的元素存储到数组中，其他为存储元素的位置默认值null。 所以，在传递指定类型数组时，最好的方式就是指定的长度和size相等的数组。 将集合变成数组后有什么好处？限定了对集合中的元素进行增删操作，只要获取这些元素即可。 Jdk5.0新特性Collection在jdk1.5以后，有了一个父接口Iterable，这个接口的出现的将iterator方法进行抽取，提高了扩展性。 增强for循环：foreach语句，foreach简化了迭代器。 格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器 for( 元素类型 变量名 : Collection集合 &amp; 数组 ) { … } 高级for循环和传统for循环的区别： 高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是Collection集合或者数组，如果遍历Collection集合，在遍历过程中还需要对元素进行操作，比如删除，需要使用迭代器。 如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。 高级for循环可以遍历map集合吗？不可以。但是可以将map转成set后再使用foreach语句。 1)、作用：对存储对象的容器进行迭代： 数组 collection map 2)、增强for循环迭代数组： String [] arr = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};//数组的静态定义方式，只试用于数组首次定义的时候 for(String s : arr) { System.out.println(s); }3)、单列集合 Collection： List list = new ArrayList(); list.add(&quot;aaa&quot;); // 增强for循环, 没有使用泛型的集合能不能使用增强for循环迭代？能 for(Object obj : list) { String s = (String) obj; System.out.println(s); }4)、双列集合 Map： Map map = new HashMap(); map.put(&quot;a&quot;, &quot;aaa&quot;); // 传统方式：必须掌握这种方式 Set entrys = map.entrySet(); // 1.获得所有的键值对Entry对象 iter = entrys.iterator(); // 2.迭代出所有的entry while(iter.hasNext()) { Map.Entry entry = (Entry) iter.next(); String key = (String) entry.getKey(); // 分别获得key和value String value = (String) entry.getValue(); System.out.println(key + &quot;=&quot; + value); } // 增强for循环迭代：原则上map集合是无法使用增强for循环来迭代的，因为增强for循环只能针对实现了Iterable接口的集合进行迭代；Iterable是jdk5中新定义的接口，就一个方法iterator方法，只有实现了Iterable接口的类，才能保证一定有iterator方法，java有这样的限定是因为增强for循环内部还是用迭代器实现的，而实际上，我们可以通过某种方式来使用增强for循环。 for(Object obj : map.entrySet()) { Map.Entry entry = (Entry) obj; // obj 依次表示Entry System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue()); }5）、集合迭代注意问题：在迭代集合的过程中，不能对集合进行增删操作（会报并发访问异常）；可以用迭代器的方法进行操作（子类listIterator：有增删的方法）。 6)、增强for循环注意问题：在使用增强for循环时，不能对元素进行赋值； int[] arr = {1,2,3}; for(int num : arr) { num = 0; //不能改变数组的值 } System.out.println(arr[1]); //2可变参数（…）：用到函数的参数上，当要操作的同一个类型元素个数不确定的时候，可是用这个方式，这个参数可以接受任意个数的同一类型的数据。 和以前接收数组不一样的是： 以前定义数组类型，需要先创建一个数组对象，再将这个数组对象作为参数传递给函数。现在，直接将数组中的元素作为参数传递即可。底层其实是将这些元素进行数组的封装，而这个封装动作，是在底层完成的，被隐藏了。所以简化了用户的书写，少了调用者定义数组的动作。 如果在参数列表中使用了可变参数，可变参数必须定义在参数列表结尾(也就是必须是最后一个参数，否则编译会失败。)。 如果要获取多个int数的和呢？可以使用将多个int数封装到数组中，直接对数组求和即可。 静态导入：导入了类中的所有静态成员，简化静态成员的书写。 import static java.util.Collections.*; //导入了Collections类中的所有静态成员枚举：关键字 enum问题：对象的某个属性的值不能是任意的，必须为固定的一组取值其中的某一个； 解决办法： 1）、在setGrade方法中做判断，不符合格式要求就抛出异常； 2）、直接限定用户的选择，通过自定义类模拟枚举的方式来限定用户的输入，写一个Grade类，私有构造函数，对外提供5个静态的常量表示类的实例； 3)、jdk5中新定义了枚举类型，专门用于解决此类问题； 4)、枚举就是一个特殊的java类，可以定义属性、方法、构造函数、实现接口、继承类； 自动拆装箱：java中数据类型分为两种 ： 基本数据类型 引用数据类型(对象) 在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下： int –&gt; Integer byte –&gt; Byte short –&gt; Short long –&gt; Long char –&gt; Character double –&gt; Double float –&gt; Float boolean –&gt; Boolean jdk5以前基本数据类型和包装类之间需要互转： 基本—引用 Integer x = new Integer(x); 引用—基本 int num = x.intValue(); 1)、Integer x = 1; x = x + 1; 经历了什么过程？装箱 à 拆箱 à 装箱； 2)、为了优化，虚拟机为包装类提供了缓冲池，Integer池的大小 -128~127 一个字节的大小； 3)、String池：Java为了优化字符串操作 提供了一个缓冲池； 泛型：jdk1.5版本以后出现的一个安全机制。表现格式：&lt; &gt; 好处： 1：将运行时期的问题ClassCastException问题转换成了编译失败，体现在编译时期，程序员就可以解决问题。 2：避免了强制转换的麻烦。 只要带有&lt;&gt;的类或者接口，都属于带有类型参数的类或者接口，在使用这些类或者接口时，必须给&lt;&gt;中传递一个具体的引用数据类型。 泛型技术：其实应用在编译时期，是给编译器使用的技术，到了运行时期，泛型就不存在了。 为什么? 因为泛型的擦除：也就是说，编辑器检查了泛型的类型正确后，在生成的类文件中是没有泛型的。 在运行时，如何知道获取的元素类型而不用强转呢？ 泛型的补偿：因为存储的时候，类型已经确定了是同一个类型的元素，所以在运行时，只要获取到该元素的类型，在内部进行一次转换即可，所以使用者不用再做转换动作了。 什么时候用泛型类呢？ 当类中的操作的引用数据类型不确定的时候，以前用的Object来进行扩展的，现在可以用泛型来表示。这样可以避免强转的麻烦，而且将运行问题转移到的编译时期。 泛型在程序定义上的体现： //泛型类：将泛型定义在类上。 class Tool&lt;Q&gt; { private Q obj; public void setObject(Q obj) { this.obj = obj; } public Q getObject() { return obj; } } //当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上。 public &lt;W&gt; void method(W w) { System.out.println(&quot;method:&quot;+w); } //静态方法上的泛型：静态方法无法访问类上定义的泛型。如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 public static &lt;Q&gt; void function(Q t) { System.out.println(&quot;function:&quot;+t); } //泛型接口. interface Inter&lt;T&gt; { void show(T t); } class InterImpl&lt;R&gt; implements Inter&lt;R&gt; { public void show(R r) { System.out.println(&quot;show:&quot;+r); } }泛型中的通配符：可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。 泛型限定： 上限：？extends E：可以接收E类型或者E的子类型对象。 下限：？super E：可以接收E类型或者E的父类型对象。 上限什么时候用：往集合中添加元素时，既可以添加E类型对象，又可以添加E的子类型对象。为什么？因为取的时候，E类型既可以接收E类对象，又可以接收E的子类型对象。 下限什么时候用：当从集合中获取元素进行操作的时候，可以用当前元素的类型接收，也可以用当前元素的父类型接收。 泛型的细节： 1）、泛型到底代表什么类型取决于调用者传入的类型，如果没传，默认是Object类型； 2）、使用带泛型的类创建对象时，等式两边指定的泛型必须一致； 原因：编译器检查对象调用方法时只看变量，然而程序运行期间调用方法时就要考虑对象具体类型了； 3）、等式两边可以在任意一边使用泛型，在另一边不使用(考虑向后兼容)； ArrayList&lt;String&gt; al = new ArrayList&lt;Object&gt;(); //错 //要保证左右两边的泛型具体类型一致就可以了，这样不容易出错。 ArrayList&lt;? extends Object&gt; al = new ArrayList&lt;String&gt;(); al.add(&quot;aa&quot;); //错 //因为集合具体对象中既可存储String，也可以存储Object的其他子类，所以添加具体的类型对象不合适，类型检查会出现安全问题。 ？extends Object 代表Object的子类型不确定，怎么能添加具体类型的对象呢？ public static void method(ArrayList&lt;? extends Object&gt; al) { al.add(&quot;abc&quot;); //错 //只能对al集合中的元素调用Object类中的方法，具体子类型的方法都不能用，因为子类型不确定。 }","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java String、StringBuffer、StringBuilder","slug":"Java String、StringBuffer、StringBuilder","date":"2014-05-11T06:44:23.000Z","updated":"2019-09-05T09:19:21.232Z","comments":true,"path":"2014/05/11/Java String、StringBuffer、StringBuilder/","link":"","permalink":"https://okfood.vip/blog/2014/05/11/Java String、StringBuffer、StringBuilder/","excerpt":"","text":"Stringjava中用String类进行描述。对字符串进行了对象的封装。这样的好处是可以对字符串这种常见数据进行方便的操作。对象封装后，可以定义N多属性和行为。 如何定义字符串对象呢？String s = “abc”;只要是双引号引起的数据都是字符串对象。 特点：字符串一旦被初始化，就不可以被改变，存放在方法区中的常量池中。 举例如下： class StringDemo { public static void main(String[] args) { String s1 = &quot;abc&quot;;//s1是一个类类型变量，&quot;abc&quot;是一个对象 //字符串最大一个特点：一旦被初始化就不可以被改变 String s2 = new String(&quot;abc&quot;); String s3 = &quot;abc&quot;; //s1和s2有什么区别？ //s1在内存中有一个对象；s2在内存中有两个对象。 System.out.println(s1==s2); System.out.println(s1.equals(s2)); System.out.println(s1==s3); } }字符串的方法： 1.获取 1.1字符串中包含的字符数，也就是字符串的长度 int length();获取长度1.2根据位置获取位置上某个字符 char charAt(int Index);1.3根据字符获取该字符在字符串中的位置 int indexOf(int ch);返回的是ch在字符串中第一次出现的位置 int indexOf(int ch,int fromIdex);从fromIndex指定位置开始，获取ch在字符串中出现的位置 int indexOf(String str);返回的是str在字符串中第一次出现的位置 int indexOf(String str,int fromIdex);从fromIndex指定位置开始，获取str在字符串中出现的位置 lastIndexOf(int ch);2.判断 2.1字符串中是否包含一个字符串 boolean contains(str);特殊之处：indexOf(str)亦可实现此功能。 2.2字符串中是否有内容 boolean isEmpty();原理是判断长度师傅哦为02.3字符串是否以指定内容开头 boolean startsWith(str);2.4字符串是否以指定内容结尾 boolean endsWith(str);2.5判断字符串的内容是否相同.复写了Object类中的equals方法 boolean equals(str)2.6判断内容是否相同，并回忽略大小写 boolean equalsIgnoreCase();3.转换 3.1将字符数组转成字符串 构造函数：String(char[]); String(char[],offset,count);//将字符数组中的一部分转成字符串，offset起始位置，count个数静态方法：static String copyValueOf(char[]); static String copyValueOf(char[],int offset,int count); static String valueOf(cahr[]);3.2将字符串转成字符数组 char[] toCharArray();3.3将字节数组转成字符串 String(byte[]); String(byte[],offset,count);将字节数组中的一部分转成字符串3.4将字符串转成字节数组 byte[] getBytes();3.5将基本数据类型转成字符串 static String valueOf(int); static String valueOf(double);特殊：字符串和字节数组在转换过程中，是可以指定编码表的 4.替换 String replace(oldchar,newchar);5.切割 String[] split(regex);6.子串。获取字符串中的一部分 String substring(begin); String substring(begin,end);7.转换。去除空格，比较 7.1将字符串转成大写或者小写 String toUpperCase(); String toLowerCase();7.2将字符串两端的多个空格去除 String trim();7.3对两个字符串进行自然顺序的比较 int compareTo(string);综合举例如下： class StringMethodDemo { //7 public static void method_tra() { String str = &quot; Hello Java!3 &quot;; //1.大小写互换 sop(str.toUpperCase()); sop(str.toLowerCase()); //2.去除空格 sop(str.trim()); //3.比较 String str1 = &quot; Hello Java!5 &quot;; sop(str.compareTo(str1)); } //6 public static void method_substring() { String str = &quot;abcdefgh&quot;; sop(str.substring(2));//从指定位置开始至结尾.如果角标不存在，会出现角标越界异常 sop(str.substring(1,4));//包含头，不包含尾。s.substring(0,s.length()) } //5 public static void method_split() { String s = &quot;lisi,zhangsan,wangwu&quot;; String[] arr = s.split(&quot;,&quot;); for(int x=0;x&lt;arr.length;x++) sop(arr[x]); } //4 public static void method_replace() { String s = &quot;hello java&quot;; String s1 = s.replace(&#39;a&#39;,&#39;n&#39;); String s2 = s.replace(&quot;java&quot;,&quot;world&quot;); sop(&quot;s=&quot;+s); sop(&quot;s1=&quot;+s1); sop(&quot;s2=&quot;+s2); } //3 public static void methid_trans() { //1.字符数组-&gt;字符串 char[] arr = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;}; String s1 = new String(arr); String s2 = new String(arr,1,2); String s3 = String.copyValueOf(arr); String s4 = String.copyValueOf(arr); sop(&quot;s1=&quot;+s1); sop(&quot;s2=&quot;+s2); sop(&quot;s3=&quot;+s3); sop(&quot;s4=&quot;+s3); //2.字符串-&gt;字符数组 String str = &quot;abcd&quot;; char[] chArr = str.toCharArray(); // sopArray(chArr); //3.字节数组-&gt;字符串 byte[] arr1 = {53,55,47,57};//ASCII值 String s5 = new String(arr1); sop(&quot;s5=&quot;+s5); //4.字符串-&gt;字节数组 byte[] byt = str.getBytes(); sopArray(byt); //5.基本数据类型-&gt;字符串 int x = 5; String s6 = String.valueOf(x); sop(&quot;s6=&quot;+s6); } //2 public static void method_is() { String str = &quot;ArrayDemo.java&quot;; //判断文件名是否以Array开头 sop(str.startsWith(&quot;Array&quot;)); //判断文件名是否以Array开头 sop(str.endsWith(&quot;java&quot;)); //判断文件名是否包含Demo sop(str.contains(&quot;Demo&quot;)); } //1 public static void method_get() { String str = &quot;abcdsdf&quot;; //长度 sop(str.length()); //根据索引获取字符 sop(str.charAt(4)); //根据字符获取索引 sop(str.indexOf(&quot;ds&quot;,2));//如果没有找到，返回-1 //反向索引一个字符出现的位置 sop(str.lastIndexOf(&quot;d&quot;)); } public static void main(String[] args) { method_tra(); // method_substring(); // method_split(); // method_replace(); // methid_trans(); // method_is(); // method_get(); } public static void sop(Object obj) { System.out.println(obj); } public static void sopArray(byte[] arr) { System.out.print(&quot;[&quot;); for(int x=0;x&lt;arr.length;x++) { if(x!=arr.length-1) System.out.print(arr[x]+&quot;,&quot;); else System.out.println(arr[x]+&quot;]&quot;); } } }StringBuffer构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。 特点： 可以对字符串内容进行修改。 是一个容器。 是可变长度的。 缓冲区中可以存储任意类型的数据。 最终需要变成字符串。 容器通常具备一些固定的方法： 1，添加。 StringBuffer append(data):在缓冲区中追加数据。追加到尾部。 StringBuffer insert(index,data):在指定位置插入数据。2，删除。 StringBuffer delete(start,end);删除从start至end-1范围的元素 StringBuffer deleteCharAt(index);删除指定位置的元素 //sb.delete(0,sb.length());//清空缓冲区。3，修改。 StringBuffer replace(start,end,string);将start至end-1替换成string void setCharAt(index,char);替换指定位置的字符 void setLength(len);将原字符串置为指定长度的字符串4，查找。（查不到返回-1） int indexOf(string); 返回指定子字符串在此字符串中第一次出现处的索引。 int indexOf(string,int fromIndex);从指定位置开始查找字符串 int lastIndexOf(string); 返回指定子字符串在此字符串中最右边出现处的索引。 int lastIndexOf(string,int fromIndex); 从指定的索引开始反向搜索 string substring(start); 返回start到结尾的子串 string substring(start,end); 返回start至end-1的子串5，反转 StringBuffer reverse();字符串反转6，void getChars(int srcBegin,int srcEnd,cahr[] dat,int dstBegin) 举例如下： class StringBufferDemo { //6 public static void method_6() { StringBuilder sb = new StringBuilder(&quot;abcdefg&quot;); char[] chs = new char[8]; sb.getChars(1,4,chs,1); for(int x=0;x&lt;chs.length;x++) sop(&quot;chs[&quot;+x+&quot;]=&quot;+chs[x]); } //5 public static void method_reverse() { StringBuffer sb = new StringBuffer(&quot;abcdefg&quot;); //反转 sb.reverse(); sop(sb.toString()); } //3 public static void method_update() { StringBuffer sb = new StringBuffer(&quot;abcdefg&quot;); //替换 sb.replace(1,4,&quot;java&quot;); sop(sb.toString()); //改变指定位置字符 sb.setCharAt(2,&#39;E&#39;); sop(sb.toString()); } //2 public static void method_delete() { StringBuffer sb = new StringBuffer(&quot;abcdefg&quot;); //删除指定部分 sb.delete(1,3); sop(sb.toString()); //删除指定位置字符 sb.deleteCharAt(2); sop(sb.toString()); //清空缓冲区 sb.delete(0,sb.length()); sop(sb.toString()); } //1 public static void method_add() { StringBuffer sb = new StringBuffer(); //添加 sb.append(&quot;abc&quot;).append(true).append(23); sop(sb.toString()); //插入 sb.insert(2,&quot;QQ&quot;); sop(sb.toString()); } public static void main(String[] args) { method_6(); // method_reverse(); // method_update(); // method_delete(); // method_add(); } public static void sop(String str) { System.out.println(str); } }StringBuilderJDK1.5出现StringBuiler；构造一个其中不带字符的字符串生成器，初始容量为 16 个字符。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。 方法和StringBuffer一样； StringBuffer 和 StringBuilder 的区别： StringBuffer线程安全。 StringBuilder线程不安全。 单线程操作，使用StringBuilder 效率高。 多线程操作，使用StringBuffer 安全。 开发中建议使用StringBuilder 基本数据类型对象包装类基本数据类型对象包装类：是按照面向对象思想将基本数据类型封装成了对象。 好处： 可以通过对象中的属性和行为操作基本数据。 可以实现基本数据类型和字符串之间的转换。 关键字 对应的类名 byte Byte short Short paserShort(numstring); int Integer 静态方法：parseInt(numstring) long Long float Float double Double char Character Boolean Boolean 基本数据类型对象包装类：都有 XXX parseXXX 方法 只有一个类型没有parse方法：Character ； Integer对象： 数字格式的字符串转成基本数据类型的方法： 将该字符串封装成了Integer对象，并调用对象的方法intValue(); 使用Integer.parseInt(numstring):不用建立对象，直接类名调用； 将基本类型转成字符串： Integer中的静态方法 String toString(int); int+” “; 将一个十进制整数转成其他进制： 转成二进制：toBinaryString 转成八进制：toOctalString 转成十六进制：toHexString toString(int num,int radix); 将其他进制转换十进制： parseInt(string,radix); //将给定的数转成指定的基数进制； 举例如下： class IntegerDemo { public static void main(String[] args) { sop(&quot;int max:&quot;+Integer.MAX_VALUE); int a = Integer.parseInt(&quot;123&quot;); sop(a); sop(Integer.toBinaryString(a)); int num = Integer.parseInt(&quot;3c&quot;,16); sop(num); } public static void sop(Object obj) { System.out.println(obj); } }在jdk1.5版本后，对基本数据类型对象包装类进行升级。在升级中，使用基本数据类型对象包装类可以像使用基本数据类型一样，进行运算。 Integer i = new Integer(4); //1.5版本之前的写法； Integer i = 4; //自动装箱，1.5版本后的写法； i = i + 5; //i对象是不能直接和5相加的，其实底层先将i转成int类型，在和5相加。而转成int类型的操作是隐式的。自动拆箱：拆箱的原理就是i.intValue();i+5运算完是一个int整数。如何赋值给引用类型i呢？其实有对结果进行装箱。 Integer c = 127; Integer d = 127; System.out.println(c = = d); //true //在装箱时，如果数值在byte范围之内，那么数值相同，不会产生新的对象，也就是说多个数值相同的引用指向的是同一个对象。","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java多线程基础","slug":"Java多线程基础","date":"2014-05-10T11:20:43.000Z","updated":"2019-09-05T09:07:58.803Z","comments":true,"path":"2014/05/10/Java多线程基础/","link":"","permalink":"https://okfood.vip/blog/2014/05/10/Java多线程基础/","excerpt":"","text":"多线程进程：正在进行中的程序。其实进程就是一个应用程序运行时的内存分配空间。 线程：其实就是进程中一个程序执行控制单元，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。 一个进程至少有一个线程在运行，当一个进程中出现多个线程时，就称这个应用程序是多线程应用程序，每个线程在栈区中都有自己的执行空间，自己的方法区、自己的变量。 jvm在启动的时，首先有一个主线程，负责程序的执行，调用的是main函数。主线程执行的代码都在main方法中。 当产生垃圾时，收垃圾的动作，是不需要主线程来完成，因为这样，会出现主线程中的代码执行会停止，会去运行垃圾回收器代码，效率较低，所以由单独一个线程来负责垃圾回收。 随机性的原理：因为cpu的快速切换造成，哪个线程获取到了cpu的执行权，哪个线程就执行。 返回当前线程的名称：Thread.currentThread().getName() 线程的名称是由：Thread-编号定义的。编号从0开始。 线程要运行的代码都统一存放在了run方法中。 线程要运行必须要通过类中指定的方法开启。start方法。（启动后，就多了一条执行路径） start方法：1）、启动了线程；2）、让jvm调用了run方法。 创建线程的第一种方式继承Thread ，由子类复写run方法。 步骤： 定义类继承Thread类； 目的是复写run方法，将要让线程运行的代码都存储到run方法中； 通过创建Thread类的子类对象，创建线程对象； 调用线程的start方法，开启线程，并执行run方法。 例如： class Demo extends Thread//定义类继承Thread类 { public void run()//复写run方法 { for(int x=0;x&lt;60;x++) System.out.println(&quot;demo run---&quot;+x); } } class ThreadDemo { public static void main(String[] args) { Demo d = new Demo();//创建线程对象 d.start();//调用线程的start方法，开启线程 //以下是主函数线程执行程序 for(int x=0;x&lt;50;x++) System.out.println(&quot;Hello World!---&quot;+x); } }线程状态： 被创建：start() 运行：具备执行资格，同时具备执行权； 冻结：sleep(time),wait()—notify()唤醒；线程释放了执行权，同时释放执行资格； 临时阻塞状态：线程具备cpu的执行资格，没有cpu的执行权； 消亡：stop() 创建线程的第二种方式实现一个接口Runnable。 步骤： 定义类实现Runnable接口。 覆盖接口中的run方法（用于封装线程要运行的代码）。 通过Thread类创建线程对象； 将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。 调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。 例如： class Ticket implements Runnable //定义类实现Runnable接口 { private int tick = 50; public void run()//覆盖接口中的run方法 { while(true) { if(tick&gt;0) System.out.println(Thread.currentThread().getName()+&quot;..sale:&quot;+tick--); } } } class TicketDemo { public static void main(String[] args) { /* 通过Thread类创建线程对象, 并将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数 */ Thread t1 = new Thread(new Ticket()); Thread t2 = new Thread(new Ticket()); Thread t3 = new Thread(new Ticket()); Thread t4 = new Thread(new Ticket()); t1.start();//开启线程 t2.start(); t3.start(); t4.start(); } } Ticket t = new Ticket(); /* 直接创建Ticket对象，并不是创建线程对象。 因为创建对象只能通过new Thread类，或者new Thread类的子类才可以。 所以最终想要创建线程。既然没有了Thread类的子类，就只能用Thread类。 */ Thread t1 = new Thread(t); //创建线程。 /* 只要将t作为Thread类的构造函数的实际参数传入即可完成线程对象和t之间的关联 为什么要将t传给Thread类的构造函数呢？其实就是为了明确线程要运行的代码run方法。 */ t1.start();为什么要有Runnable接口的出现？1：通过继承Thread类的方式，可以完成多线程的建立。但是这种方式有一个局限性，如果一个类已经有了自己的父类，就不可以继承Thread类，因为java单继承的局限性。 可是该类中的还有部分代码需要被多个线程同时执行。这时怎么办呢？ 只有对该类进行额外的功能扩展，java就提供了一个接口Runnable。这个接口中定义了run方法，其实run方法的定义就是为了存储多线程要运行的代码。 所以，通常创建线程都用第二种方式。 因为实现Runnable接口可以避免单继承的局限性。 2：其实是将不同类中需要被多线程执行的代码进行抽取。将多线程要运行的代码的位置单独定义到接口中。为其他类进行功能扩展提供了前提。 所以Thread类在描述线程时，内部定义的run方法，也来自于Runnable接口。 实现Runnable接口可以避免单继承的局限性。而且，继承Thread，是可以对Thread类中的方法，进行子类复写的。但是不需要做这个复写动作的话，只为定义线程代码存放位置，实现Runnable接口更方便一些。所以Runnable接口将线程要执行的任务封装成了对象。 Try { Thread.sleep(10); }catch(InterruptedException e){}// 当刻意让线程稍微停一下，模拟cpu切换情况。多线程安全问题的原因通过图解：发现一个线程在执行多条语句时，并运算同一个数据时，在执行过程中，其他线程参与进来，并操作了这个数据。导致到了错误数据的产生。 涉及到两个因素： 多个线程在操作共享数据。 有多条语句对共享数据进行运算。 原因：这多条语句，在某一个时刻被一个线程执行时，还没有执行完，就被其他线程执行了。 解决安全问题的原理只要将操作共享数据的语句在某一时段让一个线程执行完，在执行过程中，其他线程不能进来执行就可以解决这个问题。 如何进行多句操作共享数据代码的封装呢？ java中提供了一个解决方式：就是同步代码块。 格式： synchronized(对象) { // 任意对象都可以。这个对象就是锁。 需要被同步的代码； }同步： 好处：解决了线程安全问题。 弊端：相对降低性能，因为判断锁需要消耗资源，产生了死锁。 定义同步是有前提的： 必须要有两个或者两个以上的线程，才需要同步。 多个线程必须保证使用的是同一个锁。 同步的第二种表现形式同步函数：其实就是将同步关键字定义在函数上，让函数具备了同步性。 同步函数是用的哪个锁呢？ 通过验证，函数都有自己所属的对象this，所以同步函数所使用的锁就是this锁。 当同步函数被static修饰时，这时的同步用的是哪个锁呢？ 静态函数在加载时所属于类，这时有可能还没有该类产生的对象，但是该类的字节码文件加载进内存就已经被封装成了对象，这个对象就是该类的字节码文件对象。 所以静态加载时，只有一个对象存在，那么静态同步函数就使用的这个对象。 这个对象就是 类名.class 同步代码块和同步函数的区别同步代码块使用的锁可以是任意对象。 同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。 在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。 ★考点问题：请写一个延迟加载的单例模式？写懒汉式；当出现多线程访问时怎么解决？加同步，解决安全问题；效率高吗？不高；怎样解决？通过双重判断的形式解决。 //懒汉式：延迟加载方式。 当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。 为了效率问题，通过双重判断的形式解决。 /* 单例设计模式 //饿汉式： class Single { private static final Single s = new Single(); private Single(){} public static Single getInstance() { return s; } } */ //懒汉式： class Single { private static Single s = null; private Single(){} public static Single Instance()//锁是谁？字节码文件对象； { if(s==null) { synchronized(Single.class) { if(s==null) s = new Single(); return s; } } } } class SingleDemo { public static void main(String[] args) { System.out.println(&quot;Hello World!&quot;); } }同步死锁：通常只要将同步进行嵌套，就可以看到现象。同步函数中有同步代码块，同步代码块中还有同步函数。 举例如下： class Test implements Runnable { private boolean flag; Test(boolean flag) { this.flag = flag; } public void run() { while(true) { if(flag) { synchronized(MyLock.lockb) { System.out.println(&quot;if lock b&quot;); synchronized(MyLock.locka) { System.out.println(&quot;if lock a&quot;); } } } else { synchronized(MyLock.locka) { System.out.println(&quot;else lock a&quot;); synchronized(MyLock.lockb) { System.out.println(&quot;else lock b&quot;); } } } } } } class MyLock { static Object locka = new Object(); static Object lockb = new Object(); } class DeadLockTest { public static void main(String[] args) { Thread t1 = new Thread(new Test(true)); Thread t2 = new Thread(new Test(false)); t1.start(); t2.start(); } }线程间通信：思路：多个线程在操作同一个资源，但是操作的动作却不一样。 将资源封装成对象。 将线程执行的任务(任务其实就是run方法。)也封装成对象。 等待唤醒机制：涉及的方法： wait:将同步中的线程处于冻结状态。释放了执行权，释放了资格。同时将线程对象存储到线程池中。 notify：唤醒线程池中某一个等待线程。 notifyAll:唤醒的是线程池中的所有线程。 注意： 这些方法都需要定义在同步中。 因为这些方法必须要标示所属的锁。你要知道 A锁上的线程被wait了,那这个线程就相当于处于A锁的线程池中，只能A锁的notify唤醒。 这三个方法都定义在Object类中。为什么操作线程的方法定义在Object类中？ 因为这三个方法都需要定义同步内，并标示所属的同步锁，既然被锁调用，而锁又可以是任意对象，那么能被任意对象调用的方法一定定义在Object类中。 wait和sleep区别： 分析这两个方法：从执行权和锁上来分析： wait：可以指定时间也可以不指定时间。不指定时间，只能由对应的notify或者notifyAll来唤醒。 sleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。 wait：线程会释放执行权，而且线程会释放锁。 Sleep：线程会释放执行权，但不是不释放锁。 举例如下： /* 线程间通信： 其实就是多个线程操作同一个资源，但是操作的动作不同 */ class Res { private String name; private String sex; private boolean flag = false; public synchronized void set(String name,String sex) { if(flag) try{this.wait();}catch(Exception e){} this.name = name; this.sex = sex; flag = true; this.notify(); } public synchronized void out() { if(!flag) try{this.wait();}catch(Exception e){} System.out.println(this.name+&quot;...&quot;+this.sex); flag = false; this.notify(); } } class Input implements Runnable { private Res r; Input(Res r) { this.r = r; } public void run() { int x = 0; while(true) { if(x==0) r.set(&quot;mike&quot;,&quot;man&quot;); else r.set(&quot;丽丽&quot;,&quot;女女女&quot;); x = (x+1)%2; } } } class Output implements Runnable { private Res r ; Output(Res r) { this.r = r; } public void run() { while(true) { r.out(); } } } class InputOutputDemo1 { public static void main(String[] args) { Res r = new Res();//建立资源 new Thread(new Input(r)).start(); new Thread(new Output(r)).start(); } }线程的停止：通过stop方法就可以停止线程。但是这个方式过时了。 停止线程：原理就是：让线程运行的代码结束，也就是结束run方法。 怎么结束run方法？一般run方法里肯定定义循环。所以只要结束循环即可。 第一种方式：定义循环的结束标记。 第二种方式：如果线程处于了冻结状态，是不可能读到标记的，这时就需要通过Thread类中的interrupt方法，将其冻结状态强制清除。让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。 举例如下： /* stop方法已经过时 如何停止线程？ 只有一种，run方法结束 开启多线程运行，运行代码通常是循环结构 只要控制住循环，就可以让run方法结束，也就是线程结束 特殊情况： 当线程处于冻结状态 就不会读取到标记，那么线程就不会结束 当没有指定的方式让冻结的线程恢复带运行状态时，这时需要对冻结进行清除 强制让线程恢复到运行状态中来，这样就可以操作标记让线程结束 Thread类提供该方法 interrupt(); */ class StopThread implements Runnable { private boolean flag = true; public synchronized void run() { while(flag) { try { wait(); } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName()+&quot;.....Exception&quot;); flag = false; } System.out.println(Thread.currentThread().getName()+&quot;.....run&quot;); } } public void changeFlag() { flag = false; } } class StopThreadDemo { public static void main(String[] args) { StopThread st = new StopThread(); Thread t1 = new Thread(st); Thread t2 = new Thread(st); t1.setDaemon(true); t2.setDaemon(true); t1.start(); t2.start(); int num = 0; while(true) { if(num++ == 60) { // st.changeFlag(); // t1.interrupt(); // t2.interrupt(); break; } System.out.println(Thread.currentThread().getName()+&quot;............main&quot;+num); } System.out.println(&quot;over&quot;); } }———&lt; java.lang.Thread &gt;———- interrupt()：中断线程。 setPriority(int newPriority)：更改线程的优先级。 getPriority()：返回线程的优先级。 toString()：返回该线程的字符串表示形式，包括线程名称、优先级和线程组。 Thread.yield()：暂停当前正在执行的线程对象，并执行其他线程。 setDaemon(true)：将该线程标记为守护线程或用户线程。将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。该方法必须在启动线程前调用。 join：临时加入一个线程的时候可以使用join方法。 当A线程执行到了B线程的join方式。A线程处于冻结状态，释放了执行权，B开始执行。A什么时候执行呢？只有当B线程运行结束后，A才从冻结状态恢复运行状态执行。 举例： /* join： 当A线程执行到了B线程的join（）方法时，A就会等待，等B线程执行完，A才会执行 join可以用来临时加入线程执行 */ class Demo implements Runnable { public void run() { for(int x=0;x&lt;70;x++) { System.out.println(Thread.currentThread().getName()+&quot;.....&quot;+x); Thread.yield(); } } } class JoinDemo { public static void main(String[] args) throws InterruptedException { Demo d = new Demo(); Thread t1 = new Thread(d); Thread t2 = new Thread(d); t1.start(); // t1.join(); t2.start(); for(int x=0;x&lt;80;x++) { //System.out.println(&quot;main.....&quot;+x); } System.out.println(&quot;over&quot;); } }Lock接口：多线程在JDK1.5版本升级时，推出一个接口Lock接口。 解决线程安全问题使用同步的形式，(同步代码块，要么同步函数)其实最终使用的都是锁机制。 到了后期版本，直接将锁封装成了对象。线程进入同步就是具备了锁，执行完，离开同步，就是释放了锁。 在后期对锁的分析过程中，发现，获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。 所以同步是隐示的锁操作，而Lock对象是显示的锁操作，它的出现就替代了同步。 在之前的版本中使用Object类中wait、notify、notifyAll的方式来完成的。那是因为同步中的锁是任意对象，所以操作锁的等待唤醒的方法都定义在Object类中。 而现在锁是指定对象Lock。所以查找等待唤醒机制方式需要通过Lock接口来完成。而Lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到了一个对象中。这个对象就是Condition，将Object中的三个方法进行单独的封装。并提供了功能一致的方法 await()、signal()、signalAll()体现新版本对象的好处。 举例：比较下面两个程序 /* 对于多个生产者和消费者 为什么定义while判断标记？ 原因：让被唤醒的线程再一次判断标记 为什么定义notifyAll？ 因为需要唤醒对方线程。 只用notify，容易出现只唤醒本方线程的情况，导致程序中的所有线程都等待 */ class Res { private String name; private int count; private boolean flag = false; public synchronized void produce(String name) { while(flag) try{this.wait();}catch(Exception e){} this.name = name+&quot;---&quot;+count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag = true; this.notifyAll(); } public synchronized void consume() { while(!flag) try{this.wait();}catch(Exception e){} System.out.println(Thread.currentThread().getName()+&quot;.....消费者.....&quot;+this.name); flag = false; this.notifyAll(); } } class Producer implements Runnable { private Res r; Producer(Res r) { this.r = r; } public void run() { while(true) { r.produce(&quot;商品&quot;); } } } class Consumer implements Runnable { private Res r ; Consumer(Res r) { this.r = r; } public void run() { while(true) { r.consume(); } } } class ProducerConsumerDemo { public static void main(String[] args) { Res r = new Res();//建立资源 Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t1 = new Thread(pro); Thread t2 = new Thread(pro); Thread t3 = new Thread(con); Thread t4 = new Thread(con); t1.start(); t2.start(); t3.start(); t4.start(); } } /* JDK1.5中提供了多线程升级解决方案 将同步Synchronized替换成实现Lock操作 将Object中的wait,notify,notifyAll替换成了condition对象 该对象可以Lock锁，进行获取 在该示例中，实现了本方只唤醒对方的操作 */ import java.util.concurrent.locks.*; class Res { private String name; private int count = 1; private boolean flag = false; private Lock lock = new ReentrantLock(); private Condition condition_pro = lock.newCondition();//一个锁可对应多个condition private Condition condition_con = lock.newCondition(); public void produce(String name)throws InterruptedException { lock.lock();//获取锁 try { if(flag) condition_pro.await();//本方等待，需要抛出异常 this.name = name+&quot;---&quot;+count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag = true; condition_con.signal();//唤醒对方 } finally { lock.unlock();//解锁，一定执行 } } public synchronized void consume()throws InterruptedException { lock.lock(); try { if(!flag) condition_con.await(); System.out.println(Thread.currentThread().getName()+&quot;.....消费者.....&quot;+this.name); flag = false; condition_pro.signal(); } finally { lock.unlock(); } } } class Producer implements Runnable { private Res r; Producer(Res r) { this.r = r; } public void run() { while(true) { try { r.produce(&quot;商品&quot;); } catch (Exception e) { } } } } class Consumer implements Runnable { private Res r ; Consumer(Res r) { this.r = r; } public void run() { while(true) { try { r.consume(); } catch (Exception e) { } } } } class ProducerConsumerDemo1 { public static void main(String[] args) { Res r = new Res();//建立资源 Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t1 = new Thread(pro); Thread t2 = new Thread(pro); Thread t3 = new Thread(con); Thread t4 = new Thread(con); t1.start(); t2.start(); t3.start(); t4.start(); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java异常、package","slug":"Java异常、package","date":"2014-05-09T13:25:20.000Z","updated":"2019-09-05T07:03:05.823Z","comments":true,"path":"2014/05/09/Java异常、package/","link":"","permalink":"https://okfood.vip/blog/2014/05/09/Java异常、package/","excerpt":"","text":"异常认识异常在java编程中，异常是指当程序出错时创建的一种特殊的运行是错误对象。注意这个错误不是编译时的语法错误。 java创建异常对象后，就发送给java程序，即抛出异常（Throwing an exception），程序捕捉到这个异常后，可以编写相应的异常处理代码进行处理，而不是让程序中断。使用异常处理提高程序的健壮性，有助于调试和后期维护。在执行程序中，任何中断正常程序流程的异常条件就是错误或异常。例如，发生下列情况时会出现异常： 想打开的文件不存在 网络连接中断 受控操作数超出预定范围 正在装在的类文件丢失 错误类定义被认为是不能恢复的严重错误条件，在大多数情况下，当遇到这样的错误时，建议让程序中断。 出现的问题有很多种，比如角标越界，空指针等都是。就对这些问题进行分类。而且这些问题都有共性内容比如：每一个问题都有名称，同时还有问题描述的信息，问题出现的位置，所以可以不断的向上抽取。形成了异常体系。 ——–java.lang.Throwable： Throwable：可抛出的。 |–Error：错误，一般情况下，不编写针对性的代码进行处理，通常是jvm发生的，需要对程序进行修正。 |–Exception：异常，可以有针对性的处理方式 对于问题的划分：两种一种是严重的问题：Java通过Error类进行描述。对于Error一般不编写针对性的代码对其进行处理 一种是非严重问题：Java通过Exception类进行描述。对于Exception可以使用针对性的处理方式进行处理 异常分两种1）编译时被检查的异常，只要是Exception及其子类都是编译时被检测的异常。 2）运行时异常，其中Exception有一个特殊的子类RuntimeException，以及RuntimeException的子类是运行异常，也就说这个异常是编译时不被检查的异常。 两者区别： 编译被检查的异常：在函数内被抛出，函数必须要声明，否编译失败。 声明的原因：是需要调用者对该异常进行处理。 运行时异常：如果在函数内被抛出，在函数上不需要声明。 不声明的原因：不需要调用者处理，运行时异常发生，已经无法再让程序继续运行，所以，不让调用处理的，直接让程序停止，由调用者对代码进行修正。 throw 和throws关键字的区别：throw用于抛出异常对象，后面跟的是异常对象；throw用在函数内。 throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开；throws用在函数上。 通常情况：函数内容如果有throw，抛出异常对象，并没有进行处理，那么函数上一定要声明，否则编译失败。但是也有特殊情况。 异常处理处理方式有两种：1、捕捉；2、抛出。 对于捕捉：java有针对性的语句块进行处理。 try{ 需要被检测的代码； }catch(异常类 变量名){ 异常处理代码； }fianlly{ 一定会执行的代码； } catch (Exception e) { //e用于接收try检测到的异常对象。 System.out.println(&quot;message:&quot;+e.getMessage());//获取的是异常的信息。 System.out.println(&quot;toString:&quot;+e.toString());//获取的是异常的名字+异常的信息。 e.printStackTrace();//打印异常在堆栈中信息；异常名称+异常信息+异常的位置。 }异常处理原则： 1）声明异常时，建议声明更为具体的异常，这样处理的可以更具体.如Exception改为ArithmeticException 2）对方声明几个异常，就对应有几个catch块，如果多个catch块中的异常出血继承关系，父类异常catch块放在最下面，建立在进行catch处理时，catch中一定要定义具体处理方式，不要简单定义一句 e.printStackTrace();也不要简单的就写一条输出语句 定义异常定义异常处理时，什么时候定义try，什么时候定义throws呢？ 功能内部如果出现异常，如果内部可以处理，就用try；如果功能内部处理不了，就必须声明出来，让调用者处理。 自定义异常：当开发时，项目中出现了java中没有定义过的问题时，这时就需要我们按照java异常建立思想，将项目的中的特有问题也进行对象的封装。这个异常，称为自定义异常。 对于除法运算，0作为除数是不可以的。java中对这种问题用ArithmeticException类进行描述。对于这个功能，在我们项目中，除数除了不可以为0外，还不可以为负数。可是负数的部分java并没有针对描述。所以我们就需要自定义这个异常。 自定义异常的步骤： 1）定义一个子类继承Exception或RuntimeException，让该类具备可抛性。 2）通过throw 或者throws进行操作。 异常的转换思想：当出现的异常是调用者处理不了的，就需要将此异常转换为一个调用者可以处理的异常抛出。 try catch finally的3种结合方式： 1） try catch finally 2） try catch 3） try finally最后这种情况，如果出现异常，并不处理，但是资源一定关闭，所以try finally集合只为关闭资源。 记住：finally很有用，主要用户关闭资源。无论是否发生异常，资源都必须进行关闭。 System.exit(0); //退出jvm，只有这种情况finally不执行。当异常出现后，在子父类进行覆盖时，有了一些新的特点： 1）子类在覆盖父类时，如果父类的方法抛出异常，那么子类的覆盖方法只能抛出父类的异常或者该异常的子类。 2）如果父类方法抛出多个异常，那么子类在覆盖方法时，只能抛出父类异常的子集。 3）如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常；如果子类方法发生了异常，就必须进行try处理，绝对不能抛。 注意： 如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，如果子类的覆盖的方法中出现了异常，只能try不能throws。 如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，这样，子类的方法上是不需要throws声明的。 常见异常： 脚标越界异常（IndexOutOfBoundsException）包括数组、字符串； 空指针异常（NullPointerException） 类型转换异常：ClassCastException 没有这个元素异常：NullPointerException 不支持操作异常； 异常要尽量避免，如果避免不了，需要预先给出处理方式。 异常举例： class Demo { int div(int a,int b)throws ArithmeticException,ArrayIndexOutOfBoundsException //在功能上通过throws的关键字声明该功能有可能会出现问题 { int[] arr = new int[a]; System.out.println(arr[4]); return a/b;//除0，封装对象new AritchmeticException() } } class ExceptionDemo { public static void main(String[] args) { Demo d = new Demo(); try { int x = d.div(4,1);//new AritchmeticException() System.out.println(&quot;x=&quot;+x); } catch (ArithmeticException e)//Exception e = new AritchmeticException(); { System.out.println(&quot;被零除啦！&quot;); // System.out.println(e.getMessage());// /by zero // System.out.println(e.toString());// 异常名称，异常信息 // e.printStackTrace();//异常名称，异常信息，异常出血的位置 } catch (ArrayIndexOutOfBoundsException e) { System.out.println(e.toString()); System.out.println(&quot;角标越界啦！&quot;); } catch (Exception e) { System.out.println(&quot;异常：&quot;+e.toString()); } System.out.println(&quot;over&quot;); } }异常案例： /* 有一个圆形和长方形 都可以获取面积，对于面积如果出现非法的数值，视为是获取面积出现问题 问题通过异常来表示。 */ class NoValueException extends RuntimeException //自定义异常并继承RuntimeException { NoValueException(String message) { super(message); } } interface Shape { void getArea(); } class Rec implements Shape { private int len,wid; Rec(int len,int wid)//throws NoValueException { if(len&lt;=0 || wid&lt;=0) throw new NoValueException(&quot;出现非法值！&quot;); this.len = len; this.wid = wid; } public void getArea() { System.out.println(len*wid); } } class Circle implements Shape { private int radius; public static final double PI = 3.14; Circle(int radius) { if(radius&lt;=0) throw new NoValueException(&quot;非法值&quot;); this.radius = radius; } public void getArea() { System.out.println(radius*radius*PI); } } class ExceptionTest { public static void main(String[] args) { try { Rec r = new Rec(-3,4); r.getArea(); Circle c = new Circle(-8); c.getArea(); } catch (NoValueException e) { System.out.println(e.toString()); } System.out.println(&quot;over&quot;); } }包package定义包用package关键字1）对类文件进行分类管理。 2）给类文件提供多层名称空间。 如果生成的包不在当前目录下，需要最好执行classpath，将包所在父目录定义到classpath变量中即可。 一般在定义包名时，因为包的出现是为了区分重名的类。所以包名要尽量唯一。怎么保证唯一性呢？可以使用url域名来进行包名称的定义。 package pack;//定义了一个包，名称为pack。 注意：包名的写法规范：所有字母都小写。 //package com.leo.pack.demo;类的全名称是 包名.类名 编译命令：javac –d 位置（.当前路径） java源文件 （就可以自动生成包） 例如：javac -d D:\\myclass Demo.java 包是一种封装形式，用于封装类，想要被包以外的程序访问，该类必须public； 类中的成员，如果被包以外访问，也必须public； 包与包之间访问可以使用的权限有两种： public protected：只能是不同包中的子类可以使用的权限。 总结java中的四种权限 Import - 导入：类名称变长，写起来很麻烦。为了简化，使用了一个关键字：import，可以使用这个关键字导入指定包中的类。记住：实际开发时,到的哪个类就导入哪个类，不建议使用*. import packa.*;//这个仅仅是导入了packa当前目录下的所有的类。不包含子包。 import packa.abc.*;//导入了packa包中的子包abc下的当前的所有类。 如果导入的两个包中存在着相同名称的类。这时如果用到该类，必须在代码中指定包名。 常见的软件包 java.lang : language java的核心包，Object System String Throwable jdk1.2版本后，该包中的类自动被导入。 java.awt : 定义的都是用于java图形界面开发的对象。 javax.swing: 提供所有的windows桌面应用程序包括的控件,比如：Frame , Dialog, Table, List 等等,就是java的图形界面库。 java.net : 用于java网络编程方面的对象都在该包中。 java.io : input output 用于操作设备上数据的对象都在该包中。比如：读取硬盘数据，往硬盘写入数据。 java.util : java的工具包，时间对象，集合框架。 java.applet: application+let 客户端java小程序。server+let –&gt; servlet 服务端java小程序。 jar ：java的压缩包，主要用于存储类文件，或者配置文件等。 命令格式：jar –cf 包名.jar 包目录 解压缩：jar –xvf 包名.jar 将jar包目录列表重定向到一个文件中：jar –tf 包名.jar &gt;c:\\1.txt 包举例： package pack;//包名所有均小写 import packb.*; //把packb中的所有类导入 import packa.*; class PackageDemo { public static void main(String[] args) { packa.DemoA d = new packa.DemoA(); d.show(); // packb.DemoB d = new packb.DemoB(); // d.methodB();//加入protected后，此处不能访问该方法，编译失败 // DemoC d = new DemoC(); // d.methodC();//编译失败 } } package packa; public class DemoA extends packb.DemoB { public void show() { System.out.println(&quot;DemoA show Run&quot;); methodB(); } } package packb; public class DemoB extends DemoC { protected/*保护权限*/ void methodB() { System.out.println(&quot;DemoB show Run&quot;); methodC(); } } package packb; public class DemoC { protected/*保护权限*/ void methodC() { System.out.println(&quot;DemoC show Run&quot;); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java面向对象之多态、内部类","slug":"Java面向对象之多态、内部类","date":"2014-05-09T10:57:39.000Z","updated":"2019-09-05T06:46:33.288Z","comments":true,"path":"2014/05/09/Java面向对象之多态、内部类/","link":"","permalink":"https://okfood.vip/blog/2014/05/09/Java面向对象之多态、内部类/","excerpt":"","text":"多态多态的概念多态是同一个行为具有多个不同表现形式或形态的能力。 比如我们说的“宠物”这个对象，它就有很多不同的表达或实现，比如有小猫、小狗等等，那我们到宠物店说“请给我一只宠物”，服务员给我小猫、小狗都可以，我们就说“宠物”这个对象具备多态性。 多态的体现父类的引用指向了自己的子类对象 父类的引用也可以接受自己的子类对象 多态的前提必须是类与类之间有关系，要么继承，要么实现 多态的好处多态的出现大大的提高程序的扩展性 通常还有一个前提，存在覆盖 多态的弊端提高了扩展性，但是只能使用父类的引用访问父类的成员 多态在子父类中的成员上的体现的特点：（多态的使用注意事项）成员变量在多态中，子父类成员变量同名。 在编译时期：参考的是引用型变量所属的类中是否有调用的成员。（编译时不产生对象，只检查语法错误） 运行时期：也是参考引用型变量所属的类中是否有调用的成员。 简单一句话：无论编译和运行，成员变量参考的都是引用变量所属的类中的成员变量。 再说的更容易记忆一些：成员变量 — 编译运行都看 = 左边。 成员函数编译时期：参考引用型变量所属的类中是否有调用的方法。 运行事情：参考的是对象所属的类中是否有调用的方法。 为什么是这样的呢？因为在子父类中，对于一模一样的成员函数，有一个特性：覆盖。 简单一句：成员函数，编译看引用型变量所属的类，运行看对象所属的类。 更简单：成员函数 — 编译看 = 左边，运行看 = 右边。 静态函数编译时期：参考的是引用型变量所属的类中是否有调用的成员。 运行时期：也是参考引用型变量所属的类中是否有调用的成员。 为什么是这样的呢？因为静态方法，其实不所属于对象，而是所属于该方法所在的类。 调用静态的方法引用是哪个类的引用调用的就是哪个类中的静态方法。 简单说：静态函数 — 编译运行都看 = 左边。 instanceof运算符多态性带来了一个问题：如何判断一耳光变量所属引用的对象类型，java使用instanceof操作符。 功能：用来判断某个实例变量是否属于某种类的类型，一旦确定了变量所引用的对象的类型后，可以将对象恢复给对应的子类变量，以获取对象的完整功能。 举例： //定义一个抽象类 abstract class Animal{ abstract void eat(); } class Cat extends Animal{ public void eat(){ System.out.println(&quot;吃鱼&quot;); } public void catchMouse(){ System.out.println(&quot;抓老鼠&quot;); } } class Dog extends Animal{ public void eat(){ System.out.println(&quot;吃骨头&quot;); } public void kanJia(){ System.out.println(&quot;看家&quot;); } } class Pig extends Animal{ public void eat(){ System.out.println(&quot;饲料&quot;); } public void gongDi(){ System.out.println(&quot;拱地&quot;); } } class Test { public static void main(String[] args) { Cat c = new Cat(); c.eat(); c.catchMouse(); System.out.println(&quot;---------------&quot;); Dog d = new Dog(); d.eat(); d.kanJia(); System.out.println(&quot;---------------&quot;); Pig p = new Pig(); p.eat(); p.gongDi(); System.out.println(&quot;---------------&quot;); Animal a = new Cat();//类型提升，向上转型 a.eat(); //a.catchMouse();//编译不通过，成员变量编译运行都看左边，Animal中无catchMouse方法 Cat cc = (Cat)a;//强制将父类的引用转成子类类型，向下转型 cc.catchMouse();//此时可以调用子类 的特有方法 System.out.println(&quot;---------------&quot;); function(new Cat()); System.out.println(&quot;---------------&quot;); function(new Dog()); System.out.println(&quot;---------------&quot;); function(new Pig()); } //Animal a = new Cat(); public static void function(Animal a) { a.eat(); if(a instanceof Cat){ Cat c = (Cat)a; c.catchMouse(); } else if (a instanceof Dog){ Dog d = (Dog)a; d.kanJia(); }else{ Pig p = (Pig)a; p.gongDi(); } } }内部类概念如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。 内部类的访问规则1）内部类可以直接访问外部类中的成员，包括私有之所以可以直接访问外部类的成员，是因为内部类中持有了一个外部类的引用，格式：外部类名.this 2）外部类要访问内部类，必须建立内部类对象 内部类的访问格式1）当内部类定义在外部类的成员位置上，而且非私有，可以再外部其他类中直接建立内部对象格式： 外部类名.内部类名 变量名 = 外部类对象.内部类对象 Outer.Inner in = new Outer().new Inner();2）当内部类在成员位置上，就可以被成员修饰符所修饰 比如，private:将内部类在外部类中进行封装 static：内部类就具备static的特性，当内部类被static修饰后，只能直接访问外部类中的static成员，出现了访问权限 在外部其他类中，如何直接访问static内部类的非静态成员？ new Outer.Inner().function();在外部其他类中，如何直接访问static内部类的静态成员？ Outer.Inner.function();注意： 当内部类中定义了静态成员，该内部类必须是static；当外部类中的静态方法访问内部类时，内部类也必须是static的。 当描述事物时，事物的内部还有事物，该事物用内部类来描述，因为内部事物在使用外部事物的内容 内部类编译后的文件名为：“外部类名$内部类名.java”； 试题举例： //1 new Object(){ void show(){ System.out.println(&quot;show run&quot;); } }.show(); //2 Object obj = new Object(){ void show(){ System.out.println(&quot;show run&quot;); } }; obj.show();1和2的写法正确吗？有区别吗？说出原因。 写法是正确，1和2都是在通过匿名内部类建立一个Object类的子类对象。 区别： 第一个可是编译通过，并运行。 第二个编译失败，因为匿名内部类是一个子类对象，当用Object的obj引用指向时，就被提升为了Object类型，而编译时检查Object类中是否有show方法，所以编译失败。 内部类举例： class Outer{ int x =3; //内部类 class Inner{ int x = 4; void function(){ int x = 6; System.out.println(&quot;inner:&quot;+x); System.out.println(&quot;inner:&quot;+Outer.this.x); } } void method(){ Inner in = new Inner(); in.function(); } } class Test{ public static void main(String[] args) { Outer out = new Outer(); out.method(); System.out.println(&quot;-------------------&quot;); //直接访问内部类中的成员 Outer.Inner in = new Outer().new Inner(); in.function(); System.out.println(&quot;-------------------&quot;); new Outer().new Inner().function(); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java面向对象之继承","slug":"Java面向对象之继承","date":"2014-04-29T15:10:25.000Z","updated":"2019-09-05T06:38:53.672Z","comments":true,"path":"2014/04/29/Java面向对象之继承/","link":"","permalink":"https://okfood.vip/blog/2014/04/29/Java面向对象之继承/","excerpt":"","text":"继承好处： 提高了代码的复用性。 让类与类之间产生了关系，提供了另一个特征多态的前提。 父类的由来：其实是由多个类不断向上抽取共性内容而来的。 java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良（接口 多实现）。 单继承：一个类只能有一个父类。 多继承：一个类可以有多个父类。 为什么不支持多继承呢？ 因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。 但是java支持多重继承。A继承B B继承C C继承D。 多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。 所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。 简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。 子父类出现后，类中的成员都有了哪些特点： 成员变量 当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。 如果想要调用父类中的属性值，需要使用一个关键字：super This：代表是本类类型的对象引用。 Super：代表是子类所属的父类中的内存空间引用。 注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。 成员函数 当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写) 什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。 构造函数 发现子类构造函数运行时，先运行了父类的构造函数。为什么呢? 原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super(); super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。 Q:为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?) 因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。 注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super(); 如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。 如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。 举例： class Fu{ Fu(){ System.out.println(&quot;我是爸&quot;); } Fu(int x){ System.out.println(&quot;我是二爸&quot;); } } class Son extends Fu{ Son(){ System.out.println(&quot;我是儿子&quot;); } Son(int x){ this(); System.out.println(&quot;我是二儿子&quot;); } public static void show(){ System.out.println(&quot;我们是一家人&quot;); } } class Test{ public static void main(String[] args){ System.out.println(&quot;----------0----------&quot;); new Son(); System.out.println(&quot;----------1----------&quot;); new Fu(); System.out.println(&quot;----------2----------&quot;); Son s = new Son(); System.out.println(&quot;----------3----------&quot;); Fu f1 = new Fu(); System.out.println(&quot;----------4----------&quot;); Fu f = new Son(2); System.out.println(&quot;----------5----------&quot;); //f.show();//此句错误，Fu中没有show方法 //Son s1 = new Fu();//此句错误，Fu无法转换成Son new Son().show(); System.out.println(&quot;----------6----------&quot;); } }打印结果如下： 加this();之前 加this();之后 问题： super()和this()是否可以同时出现的构造函数中？ 两个语句只能有一个定义在第一行，所以只能出现其中一个。 super()或者this():为什么一定要定义在第一行？ 因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。 函数的细节 细节一： 什么时候使用继承呢？ 当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。 英文书中，所属关系：” is a “ 注意：不要仅仅为了获取其他类中的已有成员进行继承。 所以判断所属关系，可以简单看，如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。 细节二： 在方法覆盖时，注意两点： 子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。 覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖) 继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。 这时如何解决问题呢？介绍一个关键字，final:最终。 final特点： 这个关键字是一个修饰符，可以修饰类，方法，变量。 被final修饰的类是一个最终类，不可以被继承。 被final修饰的方法是一个最终方法，不可以被覆盖。 被final修饰的变量是一个常量，只能赋值一次。 其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。 不加final修饰不是也可以使用吗？ 那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。 抽象类抽象：不具体，看不明白。抽象类表象体现。 在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。 抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。 抽象类的特点： 抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。 抽象方法只定义方法声明，并不定义方法实现。 抽象类不可以被创建对象(实例化)。 只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。 抽象类的细节： 抽象类中是否有构造函数？ 有，用于给子类对象进行初始化。 抽象类中是否可以定义非抽象方法？ 可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。 抽象关键字abstract和哪些不可以共存？ final ,private , static 抽象类中可不可以不定义抽象方法？ 可以。抽象方法目的仅仅为了不让该类创建对象。 举例： abstract class Student{ abstract void study();//抽象函数 void sleep(){ System.out.println(&quot;sleep...&quot;); } } class BaseStudent extends Student{ void study(){ System.out.println(&quot;base study&quot;); } } class AdvStudent extends Student{ void study(){ System.out.println(&quot;adv study&quot;); } } class Test{ public static void main(String[] args){ new BaseStudent().study(); new BaseStudent().sleep(); //new Student().study();//编译不通过,抽象类无法实例化 } }接口 是用关键字interface定义的。 接口中包含的成员，最常见的有全局常量、抽象方法。 注意：接口中的成员都有固定的修饰符。 成员变量：public static final 成员方法：public abstract 例如： interface Inter{ //写为简单的 int x=3这样也可以，系统自动添加前面关键词 public static final int x = 3; public abstract void show(); } 接口中有抽象方法，说明接口不可以实例化。 接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。 类与类之间存在着继承关系，类与接口中间存在的是实现关系。 继承用extends ；实现用implements ； 接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。 一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。 其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。 举例： interface A{ void methodA(); } interface B { void methodB(); } //接口多继承 interface C extends B,A{ void methodC(); } interface Demo{ void demoMethod(); } //类多实现 class D implements C，Demo { public void methodA(){} public void methodB(){} public void methodC(){} } 接口都用于设计上，设计上的特点：（可以理解主板上提供的接口） 接口是对外提供的规则。 接口是功能的扩展。 接口的出现降低了耦合性。 抽象类与接口： 抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。 接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。 抽象类和接口的共性： 都是不断向上抽取的结果。 抽象类和接口的区别： 1)： 抽象类只能被继承，而且只能单继承。 接口需要被实现，而且可以多实现。 2)： 抽象类中可以定义非抽象方法，子类可以直接继承使用。 接口中都有抽象方法，需要子类去实现。 3)： 抽象类使用的是 is a 关系。 接口使用的 like a 关系。 4)： 抽象类的成员修饰符可以自定义。 接口中的成员修饰符是固定的。全都是public的。 在开发之前，先定义规则，A和B分别开发，A负责实现这个规则，B负责使用这个规则。至于A是如何对规则具体实现的，B是不需要知道的。这样这个接口的出现就降低了A和B直接耦合性。 接口举例： interface Inter{ public static int NUM = 3; public abstract void show(); } interface InterA{ public abstract void show(); } class Demo{ public void function(){} } class TestDi extends Demo implements Inter,InterA{ public void show(){} } class Test { public static void main(String[] args) { TestDi t = new TestDi(); System.out.println(t.NUM);//3 System.out.println(TestDi.NUM);//3 System.out.println(Inter.NUM);//3 } }","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java面向对象之封装","slug":"Java面向对象之封装","date":"2014-04-29T12:32:32.000Z","updated":"2019-09-05T06:18:50.529Z","comments":true,"path":"2014/04/29/Java面向对象之封装/","link":"","permalink":"https://okfood.vip/blog/2014/04/29/Java面向对象之封装/","excerpt":"","text":"面向对象概念是基于面向过程的一种思想。 强调的是功能行为。 将功能封装进对象，强调具备了功能的对象。 它有三个特征：封装、继承、多态。 特点面向对象就是一种常见的思想。符合人们的思考习惯。 面向对象的出现，将复杂的问题简单化。 面向对象的出现，让曾经在过程中的执行者，变成了对象中的指挥者。 对象和类的关系1)、java中的类把抽象出来的对象使用java表达出来，那就是类。类是对具有相似性质的一类事物的抽象，类封装了一类对象的属性和方法。实例化一个类，可以获得属于该类的一个实例（即对象）。比如“人”、“汽车”使用java表达出来就是一个类。 2)、java中的对象java中的对象是在java中一个类的实例，也称实例对象。实例就是实际例子。类可被认为是一个模板——你正在描述的一个对象模型，一个对象就是你每次使用的时候创建的一个类的实例的结果。 匿名对象new Person();//匿名对象。其实就是对象的简写格式。1)、当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。 2)、匿名对象可以作为实际参数进行传递。 注意：调用匿名对象的属性是没有意义。 创建一个对象内存中做些什么事Person p = new Person(); 先将硬盘上指定位置的Person.class文件加载进内存。 执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。 在堆内存中开辟一个实体空间，分配了一个内存首地址值。new 在该实体空间中进行属性的空间分配，并进行了默认初始化。 对空间中的属性进行显示初始化。 进行实体的构造代码块初始化。 调用该实体对应的构造函数，进行构造函数初始化。（） 将首地址赋值给p ，p变量就引用了该实体。(指向了该对象) 成员变量和局部变量的区别：定义位置成员变量直接定义在类中。 局部变量定义在方法中，参数上，语句中。 作用域成员变量在这个类中有效。 局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。 存放位置成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。 局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。 所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。 封装封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。 封装好处： 将变化隔离。 便于使用。 提高重用性。 提高安全性。 封装迫使用户通过方法访问数据能保护对象的数据不被误修改，还能使对象的重用变得更简单。数据隐藏通常指的就是封装，它将对象的外部界面与对象的实现区分开来，隐藏实现细节。迫使用户去使用外部界面，即使实现细节改变，还可以通过界面承担其功能而保留原样，确保调用啊的代码还继续工作，使得代码维护更简单。 封装原则：将不需要对外提供的内容都隐藏起来；把属性都隐藏，提供公共方法对其访问。 private：关键字 A:用于修饰成员变量和成员方法。 B:被修饰的内容在其他类中是不可以被访问的。 注意：私有仅仅是封装的一种体现形式而已。 总结： 开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。 这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX()，getXXX()对其进行操作。 举例： /* private:私有，权限修饰符：用于修饰类中的成员（成员变量，成员函数） 私有只在本类中有效. 将age私有化以后，类以外即使建立了对象也不能直接访问 但是人应该有年龄，就需要在Person类中提供对于访问age的方式 注意:私有仅仅是封装的一种表现形式。 之所以对外提供访问方式，就是因为可以在访问方式中加入逻辑判断等语句 对访问的数据进行操作，提高代码的健壮性。 */ class Person{ private int age;//定义一个私有属性 //一个属性两个方法 public void setAge(int a){ if(a&gt;0 &amp;&amp; a&lt;130){ age = a; } else{ System.out.println(&quot;非法年龄&quot;); } } public int getAge(int a){ return age; } void speak(){ System.out.println(&quot;age=&quot;+age); } } class PersonDemo{ public static void main(String[] args){ Person p = new Person(); //p.age = 24; p.setAge(-20); p.speak(); } }构造方法、构造代码块、静态代码块、this构造方法概念类有一个特殊的成员方法叫做构造方法，它的作用是创建对象并初始化成员变量，在创建对象时，会自动调用类的构造方法。 构造方法定义规则 必须与类具有相同的名字； 没有方法的返回类型（包括没有void）； 一般都用public类型来说明； 一个类中可以以重载的形式定义多个构造方法。 注意：每个类至少有一个构造方法，如果不写一个构造方法，java编程语言将提供一个默认的，该构造方法没有参数，而且方法体为空。如果已经定义了构造方法则系统不再提供默认的构造方法。 一般方法和构造方法的区别一般方法：对象创建后，需要方法功能时才调用，而且可以被调用多次。 构造方法：对象创建时，就会调用与之对应的构造方法，给对象进行默认初始化，只调用一次。 构造代码块1).作用：给对象进行初始化。 对象一建立就运行，而且优先于构造方法执行。 2).和构造方法的区别： 构造代码块是给所有对象进行统一初始化； 构造方法是给对应的对象初始化； 注意：构造代码块中定义的是不同对象共性的初始化内容。 例如： class Person { private String name; private int age; //构造代码块，对象已建立就运行，优先于构造方法 { System.out.println(&quot;1234&quot;); } // else code }静态代码块就是一个有静态关键字标示的一个代码块区域。定义在类中。 作用：可以完成类的初始化。 静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。 例如： static { System.out.println(&quot;a&quot;); } 静态代码块、构造代码块、构造方法同时存在时的执行顺序：静态代码块——》构造代码块——》构造方法 举例： class Test { //静态代码块 类一加载就运行，仅一次 static { System.out.println(&quot;我是静态代码块&quot;); } //构造代码块 对象一建立就运行，建立一次运行一次 { System.out.println(&quot;我是构造代码块&quot;); } //构造函数 对象一建立就运行，建立一次运行一次 Test() { System.out.println(&quot;我是构造函数&quot;); } //静态主函数 public static void main(String[] args) { System.out.println(&quot;主函数来了&quot;); new Test(); System.out.println(&quot;---------------------&quot;); new Test(); System.out.println(&quot;---------------------&quot;); Test t = new Test(); } } /* 打印结果如下： 我是静态代码块 主函数来了 我是构造代码块 我是构造函数 --------------------- 我是构造代码块 我是构造函数 --------------------- 我是构造代码块 我是构造函数 */this关键字this是用来指向当前对象或类实例的，功能说明如下： 1)、点取成员 this.day指的是调用当前对象的day字段，示例如下： public class Mydate{ private int day,month,year; public void tomorrow(){ this.day = this.day + 1; //else code } }java编程语言自动将所有实例变量和方法引用与this关键字联系在一起，因此使用关键字在某些情况下是多余的，下面的代码与前面的代码等同。 public class Mydate{ private int day,month,year; public void tomorrow(){ day = tday + 1;//在day前面没用this //else code } }2)、区分同名变量 在类属性上定义的变量和方法内部定义的变量相同的时候，”this.变量”调用的是当前属性饿变量值，直接使用变量名称调用的是相对距离最近的变量的值。简单的说，哪个对象在调用this所在的函数，this就代表哪个对象。 public class Test{ int i = 2; public void t(){ int i = 5;//跟属性的变量名称是相同的 System.out.println(&quot;实例变量 i=&quot;+this.i); System.out.println(&quot;方法内部的变量 i=&quot;+i); } }3)、作为方法名来初始化对象 也就是相当于调用本类的其他构造方法，它必须作为构造方法的第一句。 public class Test{ public Test(){ this(3);//在这里调用本类的另外的构造方法 } public Test(int a){ } public static void main(String[] args){ Test t = new Test(); } }4)、作为参数传递 需要在某些完全分离的类中调用一个方法，并将当前对象的一个引用作为参数传递。例如： Birthday bDay = new Birthday(this);综合举例： class Person { private String name; private int age; //构造代码块，对象已建立就运行，优先于构造方法 { System.out.println(&quot;1234&quot;); } //1构造方法(此处默认的被修改) Person(){ System.out.println(&quot;A:name=&quot;+name+&quot;,age=&quot;+age); } //2重载 Person(String name){ this.name = name; } //3重载 Person(String name,int age){ this.name = name; this.age = age; } //打印姓名和年龄 public void speak(){ System.out.println(&quot;name=&quot;+this.name+&quot;...age=&quot;+this.age); } //设置姓名 public void setName(String name){ this.name = name; } //获取姓名 public String getName(){ return name; } /* 需求：给人定义一个用于比较年龄是否相同的功能，是否是同龄人 */ public boolean compare(Person p){ return this.age==p.age; } } class Test{ public static void main(String[] args) { Person p1 = new Person(); Person p2 = new Person(&quot;LiSi&quot;); Person p3 = new Person(&quot;Zhangsan&quot;,20); p3.speak(); p3.setName(&quot;Wangwu&quot;); p3.speak(); Person p4 = new Person(&quot;Chengliu&quot;,10); System.out.println(p4.getName()); p4.speak(); Person p5 = new Person(&quot;Lisi&quot;,30); Person p6 = new Person(&quot;Zhangsan&quot;,40); boolean b = p5.compare(p6); System.out.println(b); } } //打印结果如下： /* 1234 A:name=null,age=0 1234 1234 name=Zhangsan...age=20 name=Wangwu...age=20 1234 Chengliu name=Chengliu...age=10 1234 1234 false */","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"构造函数详解","slug":"构造函数详解","date":"2014-04-27T11:19:49.000Z","updated":"2019-09-05T06:03:15.829Z","comments":true,"path":"2014/04/27/构造函数详解/","link":"","permalink":"https://okfood.vip/blog/2014/04/27/构造函数详解/","excerpt":"","text":"Java构造函数的定义 一个构造函数是对象被创建时初始对象的成员函数。它具有和它所在的类完全一样的名字。一旦定义好一个构造函数，创建对象时就会自动调用它。构造函数没 有返回类型，即使是void类型也没有。这是因为一个类的构造函数的返回值的类型就是这个类本身。构造函数的任务是初始化一个对象的内部状态，所以用 new操作符创建一个实例后，立刻就会得到一个清楚、可用的对象。 构造函数（方法）注意几个特点： 函数名与类名相同 没返回、没有方法类型、也不能定义成void 程序自动调用、一个类可以定义多个构造函数，构造函数可以重载、以参数的个数，类型，或排列顺序区分 构造函数继承解析现有以下几个类: public class Grandfather { public Grandfather(){ System.out.println(&quot;This is Grandfather!&quot;); } public Grandfather(String s){ System.out.println(&quot;This is Grandfather&quot;+s); } } public class Father extends Grandfather { public Father(){ System.out.println(&quot;This is Father!&quot;); } public Father(String s){ System.out.println(&quot;This is Father!&quot;+s); } } public class Son extends Father { public Son(){ System.out.println(&quot;This is Son!&quot;); } public Son(String s){ System.out.println(&quot;This is Son&quot;+s); } } public class Construct { public static void main(String[] args) { Son son = new Son(); System.out.println(&quot;++++++++++++++++++++++&quot;); Son son1 = new Son(&quot;++==++&quot;); } } 执行结果： This is Grandfather! This is Father! This is Son! ++++++++++++++++++++++ This is Grandfather! This is Father! This is Son++==++从控制台打印的结果可以看出，当执行子类时，都是去找它的父类的缺省的构造函数，先执行父类的构造函数，再执行子类的本身。 针对以上情况，我们现在做个修改,改其中的一个类的代码如下：把Grandfather类显式写出的缺省构造函数注释掉 public class Grandfather { // public Grandfather(){ // System.out.println(&quot;This is Grandfather!&quot;); // } public Grandfather(String s){ System.out.println(&quot;This is Grandfather&quot;+s); } }如果你用的是IDE开发工具，可以很快的就发现，继承这个Grandfather类的Father类，就已经报错了 我们就得出结论： 如果不指定的情况下，子类有多个构造函数的时候，父类要嘛没有构造函数，要嘛最少有一个显式写出的缺省构造函数供子类构造函数调用. 如果要指定子类调用父类的某个构造函数，则要把代码改写如下： public class Father extends Grandfather { public Father(){ super(&quot;++ss++&quot;); System.out.println(&quot;This is Father!&quot;); } public Father(String s){ super(s); System.out.println(&quot;This is Father!&quot;+s); } }这样就指定了，作为子类的Father类，指定了调用父类Grandfather类的Grandfather(String s)构造函数 执行Construct.java 控制台输出为： This is Grandfather++ss++ This is Father! This is Son! ++++++++++++++++++++++ This is Grandfather++ss++ This is Father! This is Son++==++","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java基础：下","slug":"Java基础：下","date":"2014-04-27T09:14:34.000Z","updated":"2019-09-05T03:24:56.641Z","comments":true,"path":"2014/04/27/Java基础：下/","link":"","permalink":"https://okfood.vip/blog/2014/04/27/Java基础：下/","excerpt":"","text":"语句控制语句（1）、if(表达式)……else…….条件语句； （2）、for（表达式）……. 循环语句； （3）、while（表达式）……. 循环语句； （4）、do…..while(表达式）……循环语句； （5）、switch 多分支选择结构； （6）、continue 结束本次循环语句； （7）、break 终止执行switch或循环语句； （8）、return 从方法返回语句。 1)、 条件语句 分为四种： 单分支条件语句 语法格式为： if(条件表达式) { 语句或语句块； }二分支条件语句 语法格式为： if(条件表达式) { 语句或语句块1； } else { 语句或语句块2； }嵌套条件语句 语法格式为： if(条件表达式){ if(条件表达式){ 语句或语句块1； } } else { 语句或语句块2； }多分支条件语句 语法格式为： if(条件表达式1){ 语句或语句块1； } else if(条件表达式2){ 语句或语句块2； } …… …… }else if(条件表达式n){ 语句或语句块n； }else{ 语句0； }2)、 for循环语句 语法格式为： for(变量初始化表达式；循环条件表达式；迭代部分){ 语句或语句块；//循环体 ｝for循环有一个特殊的循环，叫死循环。表现形式为： boolean isOk = true; 或 for(;;){} for(;isOk;){} for循环可以再嵌套for循环。 注意：在for循环的初始化或迭代部分，可以有多个表达式，表达式之间用逗号隔开。例如： int count =0; for(int a= 1,b=10;a&lt;b;a++,b－－){ count++; } 共循环多少次？ 3)、 while循环语句 语法格式为： while(循环条件 表达式)｛ 语句或语句块； ｝4)、 do—–while循环语句 语法格式为： do{ 语句或语句块； ｝while(表达式)；（注意分号绝对不能省略） 5)、 switch—–case多分支选择语句 语法格式为： switch(条件表达式){ case 常量1: 语句1； break; case 常量2: 语句2； break; …… case 常量N: 语句N; break; default: 语句; }注意： 条件表达式的返回值类型必须是以下类型之一：int、byte、char、short。 case子句中的值常量N必须是常量，而且所有case子句中的值应是不同的。 default子句是可选的。 break语句用来在执行完一个case分支后，是程序跳出switch语句，即终止switch语句的执行。 在一些特殊情况下，多个不同的case值要执行一组相同的操作，这时可以不用break。 6)、 continue结束本次循环语句 使用continue语句可以立刻重新开始下一轮的循环，而不再执行循环后面的语句。 7)、 break终止执行switch和循环语句 使用break语句可以立刻终止循环，开始执行循环后面的语句。 8)、 return从方法返回语句 return语句主要作用是退出当前方法，将程序控制转移到方法的调用者。 一般格式为： return [值或表达式]；方法调用语句方法调用语句是执行对象的某个方法。 一个完整的方法调用语句由某个方法调用加上一个分号构成。 调用语法格式为：类对象名称.方法名（参数）; 例如： System.out.println(“This is a statement call a method!”);调用对象System.out的println方法。 表达式语句表达式语句就是由一个表达式加一个分号构成的语句。 例如： 常见的赋值语句： i=i+1;而i=i+1只是一个表达式。空语句空语句就是只有一个分号构成的语句。例如： ;复合语句复合语句又叫块，由{}将一些语句括起来就构成一个复合语句。例如： { a=b+c; t=a*100; }函数1、函数的定义1).函数就是定义在类中的具有特定功能的一段独立小程序。函数也称为方法。 2).函数的格式： 修饰符 返回值类型 函数名(参数类型 形式参数1,参数类型 形式参数2...) { 执行语句; return 返回值; }2、函数的特点1).定义函数可以将功能代码进行封装，便于对该功能进行复写。 2).函数只有被调用才会被执行。 3).函数的出现提高了代码的复用性。 4).对于函数没有具体返回值的情况，返回值类型用关键字void表示，那么该函数中的 return语句如果在最后一行可以省略不写。 5).函数中只能调用函数，不可以在函数内部定义函数。 6).定义函数时，函数的结果应该返回给调用者，交由调用者处理。 7).可以自定义一个访问权限。 定义函数时需要注意 1).功能中只定义所需内容，不是该功能所需的内容不要定义。 2).如果非要定义，也是单独定义一个功能来体现。以后开发时，尽量都将功能以不同的函数来体现。 3).不要将代码都定义在主函数中。 4).主函数的作用是：对已有的功能的进行调用，可以理解为用于功能的测试。 5).函数名就是一个自己定义的标示符。函数名的定义，要尽量体现出这个函数的功能。是为了增强该函数的阅读性，方便于调用者使用，所以函数名一定要有起的有意义。 6).静态方法只能调用静态方法。主函数是静态的。 7).返回值类型和参数类型没有直接关系。 定义函数时候需要有两个明确 1）这个函数会得到什么结果，也就是返回值是什么。 2）有没有未知内数据参与运算。 3、函数的重载（Overload）1).重载的概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数和参数类型不同即可。 2).重载的特点：与返回值类型无关，只看参数列表。 3).重载的好处：方便于阅读，优化了程序设计。 注:Java是严谨性语言，如果函数出现的调用不确定性，会编译失败。 4、函数重载什么时候使用？重载：当定义的功能相同，但参与运算的未知内容不同，那么，这时就定义一个函数名称以表示其功能，方便阅读，而通过参数列表的不同来区分多个同名函数。 5、主函数/* public static void main(String[] args) 主函数：是一个特殊的函数，作为程序的入口，可以被jvm调用 主函数的定义： public：代表着该函数访问权限是最大的 static：代表主函数随着类的加载就已经存在了 void：主函数没有具体的返回值 main：不是关键字，但是是一个特殊的单词，可以被jvm识别 （String[] arr）：函数的参数，参数类型是一个数组，该数组中的元素是字符串。字符串类型的数组 主函数是固定格式的，jvm识别 JVM在调用主函数时，传入的是new String[0]; 主函数传值：执行时 java MainDemo haha hehe heihei */ class MainDemo { public static void main(String[] args) { System.out.println(&quot;Hello World!&quot;); System.out.println(args.length);//0 for(int x=0;x&lt;args.length;x++) System.out.println(args[x]); } }数组（1）定义：是用来存储一组或多组相同类型数据的数据类型。 （2）数据类型：可以是基本数据类型（例如：数字型、字符型、布尔型），也可以是复合数据类型（例如：数组、类、字符串和接口）。 ※数组本身就是一种复合数据类型，因此，数组的元素也可以是数组，这样就构成了二维数组和多维数组。 （3）数组作为复合数据类型，与基本数据类型最大的区别： 数组是通过引用来控制的，而基本数据类型是通过值来控制的。 1、一维数组的声明 格式： 类型 数组名[ ]; 或 类型[ ] 数组名; 举例： int a[ ]; String[ ] b;数组的初始化有两种方法：一种是直接初始化，另一种是动态初始化。 直接初始化： 格式： 类型 数组名[ ] = { 值1，值2，…，值n}; 举例： int[ ] a= {1,2,3}; int[ ] b; b = {1,2,3};动态初始化： 格式： （1）声明时初始化： 类型 数组名[ ] = new 类型[ 数组长度];举例： int[ ] a = new int[5];（2）声明后初始化： 类型 数组名[ ]; 数组名 = new 类型[数组长度];举例： int[ ] a; a = new int[5];2、访问数组元素数组元素是通过数组名和下标来访问。未被初始化的数组，不能进行访问。 格式：数组名[下标] Java中，数组的下标从0开始，直到 &lt;数组长度-1&gt;结束。 获得数组的长度，通过length属性来获得。 举例： System.out.println(arr.length);//打印输出数组arr的长度3、数组的复制方法： System.arraycopy（源数组，源数组起始位置，目标数组，目标数组起始位置，长度）； 注：不管是要复制的数组，还是被复制的数组，都必须先初始化。 举例： int a[ ] = {1,2,3}, b[ ] = new int[3]; System.arraycopy(a,0,b,0,3); //将数组a复制到b4、对象数组 举例： //定义一个对象数组，StringBuffer是一个字符串缓存类 StringBuffer a[ ] = new StringBuffer[2]; //给对象赋值 a[0] = new StringBuffer(“Array[0]”); a[1] = new StringBuffer(“Array[1]”); System.out.println(“a[0]=” + a[0] + “ a[1]=” + a[1] ); a[0].append(“ is Modified”); //追加字符串 System.out.println(“a[0]=” + a[0]);5、二维数组和多维数组前面提到过，数组的元素也可以是数组，如果一个数组的每一个元素都是一个一维数组，这样就构成一个二维数组。 定义格式：类型 数组名[ ][ ]; 或 类型[ ][ ] 数组名; 举例： int a[ ][ ]; double[ ][ ] b;这几种定义不合法：int a[2][ ]; int b[ ][2]; int c[2][2]; 二维数组的初始化：二维数组的初始化也有直接和动态初始化两种方式。 直接初始化格式： 类型 数组名[][]= {{ 值1，值2，…，值n} ,{ 值1，值2，…，值n}....}; 举例： int a[ ][ ] = {{1,2,3},{4,5,6},{7,8,9}}; 动态初始化格式 1类型 数组名=new 类型[长度1][长度2]； 长度1表示行，长度2表示列。 举例： int a[][]=new[3][5];2类型 数组名=new 类型[长度1][]； 数组名[0]=new 类型[长度20]; 数组名[1]=new 类型[长度21]; …… 数组名[长度1-1]=new 类型[长度2n]; 举例： int a[ ][ ]; a=new int[3][ ]; a[0]=new int[5]; a[1]=new int[8]; a[2]=new int[6];6、内存区域划分（1）寄存器；（2）本地方法区；（3）方法区； （4）栈内存；（5）堆内存。 为什么划分这么区域？因为每一个内存区域对数据的处理方式不同。 1）栈内存的特点：存储都是局部变量 (函数参数,函数内定义的变量,语句中定义的变量)变量一旦使用完(作用域结束)，就会在栈内存中自动释放。 2）堆内存特点：存储的是实体 (1).堆内存中的实体都有首内存地址值. (2).堆内存中的变量都有默认初始化值. (3).对于没有任何引用变量指向的实体，会视为垃圾，会被垃圾回收机制所回收。 (数组和对象，只要是new的，都在堆内存中) 7、操作数组时常见问题1).数组角标越界异常(ArrayIndexOutOfBoundsException):操作数组时，访问到了数组中不存在的角标。 2).空指针异常(NullPointerException)：当引用没有任何指向值为null的情况，该引用还在用于操作实体。 8、对数组的常见操作1).获取数组中的元素 举例： class Test { public static void main(String[] args) { int[] x = new int[3]; int[] y = {2,5,7,9}; System.out.println(x[1]);//打印结果：0 System.out.println(y[1]);//打印结果：5 } }2).获取最值 举例： /* 给定一个数组{5,1,6,4,2,8,9}，获取其中最大值、最小值 */ class Test { //获取最大值 public static int getMax(int[] arr){ int max = arr[0]; for(int x=0;x&lt;arr.length;x++){ if(arr[x]&gt;max) max = arr[x]; } return max; } //获取最小值 public static int getMin(int[] arr){ int min = arr[0]; for(int x=0;x&lt;arr.length;x++){ if(arr[x]&lt;min) min = arr[x]; } return min; } public static void main(String[] args) { int[] arr = {5,1,6,4,2,8,9}; int max = getMax(arr); int min = getMin(arr); System.out.println(&quot;max=&quot;+max);//打印结果：max=9 System.out.println(&quot;min=&quot;+min);//打印结果：min=1 } }3).排序（选择排序、冒泡排序 ） 举例： class Sort { //选择排序法:一次用一个数与其他数挨着比较，符合条件就换位 public static void SelectSort(int[] arr){ for(int x=0;x&lt;arr.length-1;x++){ for(int y=x+1;y&lt;arr.length;y++){ if(arr[x]&gt;arr[y]){ int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; } } } } //冒泡排序法：相邻两个数进行比较，符合条件就换位 public static void BubbleSort(int[] arr){ for(int x=0;x&lt;arr.length-1;x++){ //-x:让每一次比较的数减少；-1：避免角标越界 for(int y=0;y&lt;arr.length-x-1;y++){ if(arr[y]&gt;arr[y+1]){ int temp = arr[y]; arr[y] = arr[y+1]; arr[y+1] = temp; } } } } }4).查找（折半查找 只针对有序）插入（针对有序） 举例： class Test{ //定义功能：获取key第一次出现在数组中的位置，如果返回是-1，代表该key在数组中不存在 public static int GetIndex(int[] arr,int key){ for(int x=0;x&lt;arr.length;x++){ if(arr[x]==key) return x; } return -1; } //折半查找法:可以提高效率，必须保证数组时有序的数组 public static int HalfSearch(int[] arr,int key){ int min,max,mid; min = 0; max = arr.length-1; mid = (min+max)/2; while(arr[mid]!=key){ if(key&gt;arr[mid]) min = mid + 1; else if (key&lt;arr[mid]) max = mid - 1; if(min&gt;max) return -1; mid = (max+min)/2; } return mid; } public static void main(String[] args) { int[] arr = {1,3,5,7,8,23,54,12};//数组有序 int Index1 = HalfSearch(arr,54);//折半查找出54 System.out.println(&quot;index1=&quot;+Index1);//打印结果：index1=6 } }9、使用包对数组的常见操作数组的工具类Arrays：开发中主要用于操作数组用其工具类。 此类包含用来操作数组（比如排序和搜索）的各种方法。 其主要方法为： 1).排序：Arrays.sort( arr ); 2).二分查找：Arrays.binarySearch(arr, key); 如果它包含在数组中，则返回搜索键的索引；否则返回(-(插入点) - 1)。 3),复制指定的数组：Arrays.copyOf(arr, newLength); 返回新数组，长度不足则填充响应值。 4).复制指定范围的数组：Arrays.copyOfRange(arr,from,end);含头不含尾 5).toString: Arrays.toString(arr); 返回数组的字符串形式","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Java基础：上","slug":"Java基础：上","date":"2014-03-29T03:28:08.000Z","updated":"2019-09-05T02:50:38.328Z","comments":true,"path":"2014/03/29/Java基础：上/","link":"","permalink":"https://okfood.vip/blog/2014/03/29/Java基础：上/","excerpt":"","text":"JDK下载安装及环境变量设置 从官网可以下载到JDK，目前java已出java8最新版本。 和普通的安装软件差不多，按照步骤顺利安装，默认按照JDK的时候已经在jdk目录下安装了JRE，最后会询问你是否安装独立的JRE，初期学习可以不用安装，完成即可。 java环境配置（永久性） 右击计算机，选择属性，单击高级系统设置，弹出系统属性对话框。 选择高级，单击环境变量，弹出环境变量对话框。 在系统变量中单击新建变量名为JAVA_HOME，变量值为D:\\Java\\jdk1.8.0（根据自己Java安装地址进行设置），单击确定按钮。 找到Path变量，光标定位到最前面，添加%JAVA_HOME%\\bin;（注意有分号），单击确定按钮。 一直单击确定按钮退出即可。 java环境配置（临时性） set：用于查看本机的所有环境变量的信息。 set 变量名：查看具体一个环境变量的值。 set 变量名=具体值：给指定变量定义具体值。 想要在原有环境变量值的基础上添加新值呢？首先，通过%变量名%操作符获取到原有环境变量的值；然后加上新值后在定义给该变量名即可。 举例：给path环境变量加入新值 set path = 新值；%path% 注意：这种配置方式只在当前dos窗口有效。窗口关闭，配置消失。 进入命令行，输入set path=D:\\Java\\jdk1.8.0;%path% (自己JAVA的地址) classpath环境变量设置 set classpath=c:\\myclass（自己class文件路径），如果没配置，虚拟机就在你当前位置下查找，如果设置了classpath就在设置的位置找。 set classpath=.;c:\\myclass在设置位置找，找不到再到当前位置查找 注意：JDK 1.5以后classpath可以不用设置。 常用的几种dos命令行dir：列出当前目录下的文件以及文件夹 md：创建目录 rd：删除目录 cd：进入指定目录 cd..：退回到上一级目录 cd\\：退回到根目录 del：删除文件 cls：清屏 exit：退出dos命令行注释注释不会被JVM编译，只是为代码加上一些程序员懂的文字。 单行注释：//后面的数据内容一整行都被JVM忽略。 多行注释：/**/多行行注释可以嵌套单行注释，不能嵌套多行注释。 文档注释：/***/生成文档注释。标识符、关键字Java中的标识符 变量，方法，类和对象的名称都是标识符，程序员需要标识和使用的东西都需要标识符。 在Java语言里标识符以字母或下划线、$符号开头，后面字符可以是字母、数字、下划线、$符号。（其他符号都不能用来命名标识符） 标识符对字母大小写非常敏感，必须区分大小写，但是没有长度限制。 关键字不能用作标识符命名。 标识符中不能包含空格。 标识符是由Unicode字符组成的，因此可以使用汉字作为标识符(不推荐，尽量不用)。 eg: 包(文件夹，用于区分同名的类)全部小写。如果多级包，用.分开。举例： com 一级包 leo.dev 二级包 注意：www.leo.com(域名反写) 类和接口，如果是一个单词,首字母大写。举例： Demo，Test，Student 如果是多个单词，每个单词的首字母大写。举例： HelloWorld，StudyJava 变量和方法,如果是一个单词，首字母小写。举例： main()，name，age.show().method() 如果是多个单词，从第二个单词开始每个单词的首字母大写。举例： showName()，studentName() 常量，全部大写，如果多个单词组成，用 _ 连接。举例： PI，STUDENT_MAX_AGE 关键字Java中一些赋以特定的含义、并用做专门用途的单词称为关键字，也可叫保留字，关键字不能作为普通的标识符使用；所有Java关键字都是小写的，IF、THIS、NEW等都不是Java关键字；goto和const虽然从未使用，但也作被为Java保留关键字。 关键字含义说明： 常量、变量常量常量就是程序里持续不变的值，是不能改变的数据。 声明常量的格式如下： final 类型 常量名[，常量名]=值； Java中的常量包括整型常量、浮点型常量、布尔常量、字符常量等。 整型常量： 十进制：不能以0开头，多个0～9之间的数字 十六进制: 以0x或0X开头 0x8a 0X56d 八进制：必须以0开头 034 0376 长整型：必须以L结尾 87L 345L 浮点数常量： float型：2e3f 0.6f double型：4.1d 1.23d 布尔常量：true 和 false 字符常量： ‘a’ ‘5’ 字符串常量：“hello” “8698” “\\nmain” 转义字符\\n表示换行 null常量：null，表示对象的引用为空。 变量在java语言中存储一个数据信息，必须将它保存到一个变量中。变量在使用前必须有定义，即有确定的类型和名称。 特点：变量空间可以重复使用 变量空间的开辟需要什么要素呢？ 1，这个空间要存储什么数据？数据类型。 2，这个空间叫什么名字啊？变量名称。 3，这个空间的第一次的数据是什么？ 变量的初始化值。 变量的作用域和生存期： 变量的作用域： 作用域从变量定义的位置开始，到该变量所在的那对大括号结束。生命周期： 变量从定义的位置开始就在内存中活了； 变量到达它所在的作用域的时候就在内存中消失了。声明变量的语法： 类型 变量名[, 变量名][=初值]; 例如：int i; char c; float a, b, c;变量的声明有三种形式： 1、 声明变量。 例如: int i;2、 变量赋值。在变量赋值之前要先声明变量。 例如：int i; i=5;3、 变量的初始化。 例如：int i = 8;数据类型数据类型分类 Java中主要有8中基本数据类型，分别是boolean，byte，short，int，long，char，float，double，具体如下： boolean：（布尔型）数据值只有true或false，适用于逻辑计算。 byte：byte型（字节型）数据在内存中占用1个字节，表示的存储数据范围为：-128~127。 char：char型（字符型）数据在内存中占用2个字节。char型数据用来表示通常意义上的字符，每个字符占2个字节，Java字符采用Unicode编码，它的前128字节编码与ASCII兼容字符的存储范围在\\u0000~\\uFFFF，在定义字符型的数据时候要注意加’ ‘，比如 ‘1’表示字符’1’而不是数值1， short：short型（短整型）数据在内存中占用2个字节。 int：int型（整型）数据在内存中占用4个字节。 long：long型（长整型）数据在内存中占用8个字节。 float：float型（单精度浮点型）数据在内存中占用4个字节。（float精度为7-8位） double：double型（双精度浮点型）数据在内存中占用8个字节。 Java中所有的基本数据类型都有固定的存储范围和所占内存空间的大小，而不受具体操作系统的影响，来保证Java程序的可移植性。整形数据默认为int数据类型，浮点型默认为double数据类型，如果要表示long型数据或float型数据，要在相应的数值后面加上l、f或L、F，否则会出现编译问题。 基本数据类型之间的兼容性基本数据类型之间的转换：“小”的数据类型可以直接赋给“大”的数据类型。“大”的不能赋值给“小”的数据类型（会出现编译错误）。 数据类型大小关系如下： 整数类：long &gt; int &gt; short &gt; byte 浮点型：double &gt; float 整型数据类型可以赋给浮点数据类型比如： float&lt;—short float &lt;—int float&lt;—long double&lt;—long 注意： char 可以赋给long和int ，但是不能赋给short 和byte（编译错误） 。 char 可以赋给float和double。 当整数型常量被声明为long类型时，只能赋值给long型变量。 当整数型常量在0~65535之间时，可以被赋值给char型变量。 char型常量可以被赋值给整数类变量，只要整数变量的类型可以容纳char型文字常量所表示的数值。 浮点型常量默认为double型，而double型常量不能赋值给float型变量。 boolean与其他数据类型没有兼容性。 数据类型转换 自动类型转换（隐式类型转换） 需要同时满足两个条件： 两种类型彼此兼容 目标类型的取值范围要大于源类型(byte,short,char) –&gt; int –&gt; long –&gt; float –&gt; double 强制类型转换（显示类型转换） 当两种类型不兼容，或目标取值类型范围小于源类型时，自动类型转换无法进行，需要进行强制类型转换。 数据类型强制转换的格式为：（数据类型）数据表达式； 例如：int i = 5; byte b = (byte)i; boolean类型不参与转换（因为boolean值是常量，默认只有俩个值，要么true，要么false） 运算符算术运算符、关系运算符、赋值运算符、逻辑运算符、位运算符、条件运算符 算术运算符 例如：5/2结果为2两个整数之间的相除（/）运算结果还是整数，其结果是除的结果的整数部分。要获得实数结果，运算中至少一个浮点数。 例如：5/2.0结果为2.5 关系运算符 赋值运算符 逻辑运算符 在使用短路与（&amp;&amp;）时，如果第一个操作数（或表达式）为“假”，则不再计算第二个操作数（或表达式），直接返回“假”。 在使用短路或（||）时，如果第一个操作数（或表达式）为“真”，则不再计算第二个操作数（或表达式），直接返回“真”。 逻辑运算符只能用于布尔（boolean）类型之间；其结果值为布尔（boolean）类型。 位运算符 位运算符只可用于整数类型、char类型，不可应用于浮点类型。 条件运算符 条件运算符是一个三目运算符，也是唯一的一个三元运算符，符号为“? :”,在程序中能实现简单的判断功能。 语法格式：表达式1？表达式2：表达式3 其中表示1是一个布尔表达式，如果表达式1结果为true，则执行表达式2，否则执行表达式3。 举例说明： 求a，b的最大值。 int a=4,b=6,max; max=a&gt;b?a:b;//将a和b中的较大值赋给max","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"认识Java","slug":"认识Java","date":"2014-03-27T01:38:01.000Z","updated":"2019-09-05T02:01:54.951Z","comments":true,"path":"2014/03/27/认识Java/","link":"","permalink":"https://okfood.vip/blog/2014/03/27/认识Java/","excerpt":"","text":"编程中首先需要明确特定的思维和习惯性的步骤格式： 写代码 明确需求。我要做什么？ 分析思路。我要怎么做？1,2,3。 确定步骤。每一个思路部分用到哪些语句，方法，和对象。 代码实现。用具体的java语言代码把思路体现出来。 学习新技术的四点 该技术是什么？ 该技术有什么特点(使用注意)： 该技术怎么使用。demo 该技术什么时候用？test java概述1991 年Sun公司的James Gosling等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器。 1994年将Oak语言更名为Java。随着Java技术在We方面的不断成熟，已经成为Web应用程序的首选开发语言。是简单易学，完全面向对象，安全可靠，与平台无关的编程语言。 Java的三种技术架构 JAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发 JAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础 JAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序 JDK：Java Development Kit java的开发和运行环境，包括java的开发工具和JRE。 JDK包含的基本组件包括： javac – 编译器，将源程序转成字节码; jar – 打包工具，将相关的类文件打包成一个文件; javadoc – 文档生成器，从源码注释中提取文档; jdb – debugger，查错工具; java – 运行编译后的java程序（.class后缀的）; appletviewer：小程序浏览器，一种执行HTML文件上的Java小程序的Java浏览器; Javah：产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件; Javap：Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示字节代码含义; Jconsole: Java进行系统调试和监控的工具. 常用的包 java.lang： 这个是系统的基础类，比如String等都是这里面的，这个包是唯一一个可以不用引入(import)就可以使用的包； java.io： 这里面是所有输入输出有关的类，比如文件操作等； java.nio：为了完善io包中的功能，提高io包中性能而写的一个新包 ，例如NIO非堵塞应用； java.net: 这里面是与网络有关的类，比如URL，URLConnection等； java.util： 这个是系统辅助类，特别是集合类Collection，List，Map等； java.sql： 这个是数据库操作的类，Connection， Statement，ResultSet等； javax.servlet：这个是JSP，Servlet等使用到的类。 JRE：Java Runtime Environmentjava程序的运行环境，包括java运行的所需的类库、JVM和支持文件。 JVM：Java Virtual Machinejava虚拟机，一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个回收垃圾堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 Java特点 简单易用、完全面向对象； 与平台无关性、可扩展性强； 可移植性高、支持分布式编程； 健壮、安全可靠并性能优异； 支持多线程开发技术； 支持动态开发。","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://okfood.vip/blog/tags/JavaSE/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]}]}