{"meta":{"title":"上帝之手-Work makes the workman","subtitle":"Work makes the workman","description":"A blog website for writting articles by Leo","author":"Leo","url":"https://okfood.vip/blog"},"pages":[{"title":"","date":"2019-09-04T06:20:07.211Z","updated":"2019-09-03T07:38:56.940Z","comments":false,"path":"categories/index.html","permalink":"https://okfood.vip/blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-04T06:18:37.000Z","updated":"2019-09-04T06:18:38.000Z","comments":true,"path":"tags/index.html","permalink":"https://okfood.vip/blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.537Z","updated":"2019-09-03T09:54:07.684Z","comments":false,"path":"categories/Java/index.html","permalink":"https://okfood.vip/blog/categories/Java/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.534Z","updated":"2019-09-03T09:53:54.389Z","comments":false,"path":"categories/Android/index.html","permalink":"https://okfood.vip/blog/categories/Android/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T08:39:54.677Z","updated":"2019-09-04T08:39:54.677Z","comments":false,"path":"categories/前端/index.html","permalink":"https://okfood.vip/blog/categories/前端/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.529Z","updated":"2019-09-03T09:56:01.802Z","comments":false,"path":"categories/后端/index.html","permalink":"https://okfood.vip/blog/categories/后端/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T08:39:44.229Z","updated":"2019-09-04T08:39:44.229Z","comments":false,"path":"categories/算法/index.html","permalink":"https://okfood.vip/blog/categories/算法/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.522Z","updated":"2019-09-03T09:55:45.604Z","comments":false,"path":"categories/工具/index.html","permalink":"https://okfood.vip/blog/categories/工具/index.html","excerpt":"","text":""}],"posts":[{"title":"Flutter插件flutter-img-sync使用指南","slug":"Flutter插件flutter-img-sync使用指南","date":"2019-05-28T03:38:00.000Z","updated":"2019-09-04T09:02:26.488Z","comments":true,"path":"2019/05/28/Flutter插件flutter-img-sync使用指南/","link":"","permalink":"https://okfood.vip/blog/2019/05/28/Flutter插件flutter-img-sync使用指南/","excerpt":"","text":"flutter-img-synca plugin for flutter images synchronization Android Studio及IDEA可在插件商店中搜索并安装: flutter-img-sync 使用说明 vs code编辑器在扩展商店中搜索并安装： flutter-img-sync 使用说明 功能：将资产目录下的图片自动添加到pubspec.yaml的assets配置下面，并生成R文件，代码中直接引用R文件下的定义即可 效果演示(Android Studio or IDEA) 效果演示(vs code) How To Usestep1.创建资产图片存放目录创建资产图片存放目录 如: ./assets/img step2.修改pubspec.yaml定义资产图片存放目录，如: assets: # assets-generator-begin # assets/img/* # assets-generator-endstep3.执行 FlutterImgSync (flutter-img-sync) 命令执行后，图片将会被自动放置到pubspec.yaml文件的assets变量中 ./lib/r.dart 将会被创建 在代码中导入r.dart文件，然后引用R类的变量 step4.pub get 刷新一下","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://okfood.vip/blog/tags/Flutter/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"HashMap之10问","slug":"HashMap之10问","date":"2018-08-28T05:59:00.000Z","updated":"2019-09-04T09:23:16.527Z","comments":true,"path":"2018/08/28/HashMap之10问/","link":"","permalink":"https://okfood.vip/blog/2018/08/28/HashMap之10问/","excerpt":"","text":"为什么用HashMap？ HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射 HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap是非synchronized，所以HashMap很快 HashMap可以接受null键和值，而Hashtable则不能（原因就是equlas()方法需要对象，因为HashMap是后出的API经过处理才可以） HashMap的工作原理是什么？HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。 HashMap具体的存取过程： put键值对的方法，过程如下（JDK1.8） ①、判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容(初始化赋值) ②、根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转⑥，如果table[i]不为空，转向③ ③、判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals ④、判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤ ⑤、遍历table[i]，判断链表长度是否超过阀值( TREEIFY THRESHOLD==8)，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作，链表长度低于6，会把红黑树转回链表；遍历过程中若发现key已经存在直接覆盖value即可 ⑥、插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，就需要 resize（扩容2倍后重排） get键值对的方法，过程如下（JDK1.8） ①、指定key 通过hash函数得到key的hash值：int hash=key.hashCode() ②、调用内部方法 getNode()，得到桶号(一般为hash值对桶数求模：int index =hash % tab.length; jdk1.6版本后使用位运算替代模运算，int index=( tab.length - 1）&amp; hash ; ③、比较桶的内部元素是否与key相等，若都不相等，则没有找到；相等，则取出相等记录的value。 ④、如果得到 key 所在的桶的头结点恰好是红黑树节点，就调用红黑树节点的 getTreeNode() 方法，否则就遍历链表节点。getTreeNode 方法使通过调用树形节点的 find()方法进行查找。由于之前添加时已经保证这个树是有序的，因此查找时基本就是折半查找，效率很高。 ⑤、如果对比节点的哈希值和要查找的哈希值相等，就会判断 key 是否相等，相等就直接返回；不相等就从子树中递归查找。 有什么方法可以减少碰撞？ 扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。） 使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。 HashMap中hash函数怎么是是实现的?我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); }返回散列值也就是hashcode与其无符号右移16位后进行异或。 简单来说就是 高16bit不变，低16bit和高16bit做了一个异或(得到的hashcode转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或) (n-1) &amp; hash –&gt; 得到下标 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。 说说你对红黑树的见解？ 1、每个节点非红即黑 2、根节点总是黑色的 3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定） 4、每个叶子节点都是黑色的空节点（NIL节点） 5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 解决hash 碰撞还有那些办法？a. 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 b. 开放定址法：即发生冲突时，去寻找下一个空的哈希地址。只要哈希表足够大，总能找到空的哈希地址。 c. 再哈希法：即发生冲突时，由其他的函数再计算一次哈希值。 d. 建立公共溢出区：将哈希表分为基本表和溢出表，发生冲突时，将冲突的元素放入溢出表。 HashMap 就是使用链地址法来解决冲突的（jdk8中采用平衡树来替代链表存储冲突的元素，但hash() 方法原理相同）。当两个对象的hashcode相同时，它们的bucket位置相同，碰撞就会发生。此时，可以将 put 进来的 K- V 对象插入到链表的尾部。对于储存在同一个bucket位置的链表对象，可通过键对象的equals()方法用来找到键值对。 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作reHashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置 重新调整HashMap大小存在什么问题吗？ 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap） 为什么多线程会导致死循环，它是怎么发生的？HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。2.ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。","categories":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://okfood.vip/blog/tags/数据结构/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://okfood.vip/blog/categories/算法/"}]},{"title":"Android-M-Permission-Tool-Library","slug":"Android-M-Permission-Tool-Library","date":"2017-07-11T03:44:00.000Z","updated":"2019-09-04T08:56:42.041Z","comments":true,"path":"2017/07/11/Android-M-Permission-Tool-Library/","link":"","permalink":"https://okfood.vip/blog/2017/07/11/Android-M-Permission-Tool-Library/","excerpt":"简单易用的andorid M权限相关处理的库，通过极为简单的调用方式实现授权校验、授权申请，开发者可以根据结果反馈做相应的处理。项目源码Library","text":"简单易用的andorid M权限相关处理的库，通过极为简单的调用方式实现授权校验、授权申请，开发者可以根据结果反馈做相应的处理。项目源码Library Step1.添加依赖1implementation &apos;com.leo618:SplashAuth:0.0.3&apos; Step2.声明权限，在manifest中声明需要授权的权限。 举个例子如下:1234&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; Step3.项目manifest中添加提示对话框组件1234&lt;activity android:name=&quot;com.leo618.splashpermissionsauth.SplashAuthUI&quot; android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot; android:theme=&quot;@style/SplashPermissionsAuthThemeForSplash&quot; /&gt; Step4.使用栗子如下(共有三种使用姿势)： 1.校验是否授权 2.请求授权，在onActivityResult中处理结果 3.校验并请求授权，若存在未授权则启动申请授权，无法处理结果,需要用户再次点击操作触发已授权后的操作 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; private String[] perms = new String[]&#123; Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE, Manifest.permission.CAMERA, &#125;; //1.校验是否授权 public void check(View view) &#123; boolean checkResult = SplashAuthUI.check(this, perms); Toast.makeText(this, checkResult ? &quot;全部已授权&quot; : &quot;包含未授权&quot;, Toast.LENGTH_SHORT).show(); &#125; //2.请求授权，在onActivityResult中处理结果 public void request(View view) &#123; SplashAuthUI.launch(this, 100, perms); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if(requestCode == 100) &#123; String result = resultCode == RESULT_OK ? &quot;授权成功&quot; : &quot;授权失败&quot;; Toast.makeText(this, result, Toast.LENGTH_SHORT).show(); &#125; &#125; //3.校验并请求授权，若存在未授权则启动申请授权，无法处理结果,需要用户再次点击操作触发已授权后的操作 public void checkAndRequest(View view) &#123; boolean checkResult = SplashAuthUI.checkAndLaunch(this, perms, true); Toast.makeText(this, checkResult ? &quot;全部已授权&quot; : &quot;包含未授权&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"Permission","slug":"Permission","permalink":"https://okfood.vip/blog/tags/Permission/"},{"name":"AndroidM","slug":"AndroidM","permalink":"https://okfood.vip/blog/tags/AndroidM/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"AndroidStudio打包apk输出文件目录自定义","slug":"AndroidStudio打包apk输出文件目录自定义","date":"2017-04-25T08:49:00.000Z","updated":"2019-09-04T09:12:36.142Z","comments":true,"path":"2017/04/25/AndroidStudio打包apk输出文件目录自定义/","link":"","permalink":"https://okfood.vip/blog/2017/04/25/AndroidStudio打包apk输出文件目录自定义/","excerpt":"","text":"烦恼背景：每次AS打包后输出的apk会自动生成到指定的目录下，mapping文件也会在build目录下，打包完成需求去拷贝出来，很是麻烦，于是乎，也许可以实现将编译生成的apk包及mapping文件移到自己想要的一个项目目录里面，那岂不是美滋滋，于是就有了这篇文章。 项目源码地址： https://github.com/Leo0618/ASOutputFormat 混淆规则指定生成mappingproguard-rules.pro中加入生成mapping文件语句，如下： build文件配置的必要条件要实现指定输出位置，还需要app目录下的build.gradle文件需要至少有如下几点的配置： buildTypes需要有release类型的配置 productFlavors作为可选，可以不用配置，多渠道打包可使用其他方式（360加固保、美团多渠道打包工具等等） 最后一步做的就是应用gradle文件，在app目录下的build.gradle里面最末尾加入一行代码 apply from: &#39;../output_format.gradle&#39; , 并且你需要将output_format.gradle这个文件拷贝到你的项目根目录，文件下载 正常编译打包，输出效果 自己定义名称的方法可以根据自己情况设置输出根目录名称、mapping文件名称、apk文件名称、是否删除多渠道的原包apk目录等配置，在如下代码位置处修改： 123456789101112131415161718192021222324252627282930313233343536373839/** * 定义输出根目录名称 * @param versionName 可用的参数：当前打包版本名称 * @param versionCode 可用的参数：当前打包版本号码 * @param flavorName 可用的参数：flavor名称，此参数可能为空字符串 */@SuppressWarnings(&quot;GroovyUnusedDeclaration&quot;)static String outputFileDirName(versionName, versionCode, flavorName) &#123; return &quot;output/app_release-v&quot; + versionName + &quot;-&quot; + versionCode + &quot;-&quot; + dateRelease()&#125;/** * 定义输出mapping文件名称 * @param versionName 可用的参数：当前打包版本名称 * @param versionCode 可用的参数：当前打包版本号码 * @param flavorName 可用的参数：flavor名称，此参数可能为空字符串 */@SuppressWarnings(&quot;GroovyUnusedDeclaration&quot;)static String mappingFileName(versionName, versionCode, flavorName) &#123; return &quot;mapping-v&quot; + versionName + &quot;-&quot; + versionCode + &quot;-&quot; + dateRelease() + &quot;.txt&quot;&#125;/** * 定义输出apk文件名称 * @param versionName 可用的参数：当前打包版本名称 * @param versionCode 可用的参数：当前打包版本号码 * @param flavorName 可用的参数：flavor名称，此参数可能为空字符串 */@SuppressWarnings(&quot;GroovyUnusedDeclaration&quot;)static String apkFileName(versionName, versionCode, flavorName) &#123; return &quot;app-release-v&quot; + versionName + &quot;-&quot; + versionCode + &quot;-&quot; + dateRelease() + &quot;.apk&quot;&#125;/** * 是否删除多渠道的原包apk目录 */static boolean deleteInitApk() &#123; return true&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://okfood.vip/blog/tags/Android-Studio/"},{"name":"apk","slug":"apk","permalink":"https://okfood.vip/blog/tags/apk/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]},{"title":"Nginx-Tomcat极简方式配置Https","slug":"Nginx-Tomcat极简方式配置Https","date":"2016-08-08T09:55:00.000Z","updated":"2019-09-04T09:06:10.053Z","comments":true,"path":"2016/08/08/Nginx-Tomcat极简方式配置Https/","link":"","permalink":"https://okfood.vip/blog/2016/08/08/Nginx-Tomcat极简方式配置Https/","excerpt":"","text":"Nginx+Tomcat极简方式配置，实现https安全访问。 效果网站： https://okfood.vip Step1.获取证书并下载拷贝获取SSL证书并拷贝至指定目录：方式一：使用SSL For Free生成 方式二：阿里云腾讯云获取，获取方法官网有 此文以阿里云获取的SSL证书为例。 获取到证书后，nginx配置文件nginx.conf所在的目录下创建文件夹命名为cert,下载并将xxx.key和xxx.pem文件拷贝至cert文件夹下。 Step2.配置Nginx支持SSL编辑nginx.conf，我得配置文件在/etc/nginx/下面，修改如下配置，主要是ssl_certificate和ssl_certificate_key指向文件位置，xxx改成自己证书文件名称，其他配置可参考Nginx官网进行可选配置。 12345678910111213141516171819202122232425262728upstream tomcat &#123; server 127.0.0.1:8080 fail_timeout=0;&#125;# HTTPS serverserver &#123; listen 443 ssl; server_name localhost; ssl_certificate cert/xxx.pem; ssl_certificate_key cert/xxx.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto https; proxy_redirect off; proxy_connect_timeout 240; proxy_send_timeout 240; proxy_read_timeout 240; # note, there is not SSL here! plain HTTP is used proxy_pass http://tomcat; &#125;&#125; Step3.配置Tomcat支持SSL编辑server.xml，我的配置文件位于/www/server/apache-tomcat-8.5.32/conf/下面， 修改此处为如下， 1234&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;443&quot; proxyPort=&quot;443&quot; /&gt; 修改Host,节点下新增一个Valve 123456789&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot; remoteIpHeader=&quot;x-forwarded-for&quot; remoteIpProxiesHeader=&quot;x-forwarded-by&quot; protocolHeader=&quot;x-forwarded-proto&quot; /&gt;&lt;/Host&gt; Step4.保存文件到服务器上，重启一下Nginx和Tomcat，到此结束，就这么简单！","categories":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://okfood.vip/blog/tags/Nginx/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://okfood.vip/blog/tags/Tomcat/"},{"name":"https","slug":"https","permalink":"https://okfood.vip/blog/tags/https/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}]},{"title":"Linux系统下忘记MySQL的root密码怎么办？","slug":"Linux系统下忘记MySQL的root密码怎么办？","date":"2016-02-13T10:03:00.000Z","updated":"2019-09-04T08:59:55.824Z","comments":true,"path":"2016/02/13/Linux系统下忘记MySQL的root密码怎么办？/","link":"","permalink":"https://okfood.vip/blog/2016/02/13/Linux系统下忘记MySQL的root密码怎么办？/","excerpt":"","text":"修改MySQL的配置文件（默认为/etc/my.cnf）,在[mysqld]下添加一行skip-grant-tables 保存配置文件后，重启MySQL服务 service mysqld restart 再次进入MySQL命令行 mysql -u root -p,输入密码时直接回车，就会进入MySQL数据库了，这个时候按照常规流程修改root密码即可。依次输入： &gt;use mysql; 更改数据库 &gt;UPDATE user SET PASSWORD =password(&quot;这里写新密码&quot;) WHERE USER= &apos;root&apos;; 重设密码 &gt;flush privileges; 刷新MySQL的系统权限相关表，以防止更改后拒绝访问；或或者重启MySQL服务器 注意：若出现找不到PASSWORD字段时，使用authentication_string,即： &gt;UPDATE user SET authentication_string =password(&quot;这里写新密码&quot;) WHERE USER= &apos;root&apos;; 重设密码 密码修改完毕后，再按照步骤1中的流程，删掉配置文件中的那行，并且重启MySQL服务，新密码就生效了。","categories":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://okfood.vip/blog/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"https://okfood.vip/blog/tags/Linux/"},{"name":"数据库","slug":"数据库","permalink":"https://okfood.vip/blog/tags/数据库/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://okfood.vip/blog/categories/后端/"}]}]}