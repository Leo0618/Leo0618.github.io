{"meta":{"title":"上帝之手","subtitle":"Work makes the workman","description":"A blog website for writting articles by Leo","author":"Leo","url":"https://okfood.vip/blog"},"pages":[{"title":"","date":"2019-09-04T08:07:51.477Z","updated":"2019-09-04T07:43:46.175Z","comments":true,"path":"README.html","permalink":"https://okfood.vip/blog/README.html","excerpt":"","text":"1. hexo clean 2. npm i 3. gulp 4. hexo d"},{"title":"","date":"2019-09-04T06:20:07.211Z","updated":"2019-09-03T07:38:56.940Z","comments":false,"path":"categories/index.html","permalink":"https://okfood.vip/blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-04T06:18:37.000Z","updated":"2019-09-04T06:18:38.000Z","comments":true,"path":"tags/index.html","permalink":"https://okfood.vip/blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.534Z","updated":"2019-09-03T09:53:54.389Z","comments":false,"path":"categories/Android/index.html","permalink":"https://okfood.vip/blog/categories/Android/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.537Z","updated":"2019-09-03T09:54:07.684Z","comments":false,"path":"categories/Java/index.html","permalink":"https://okfood.vip/blog/categories/Java/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.529Z","updated":"2019-09-03T09:56:01.802Z","comments":false,"path":"categories/后端/index.html","permalink":"https://okfood.vip/blog/categories/后端/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-04T06:20:06.522Z","updated":"2019-09-03T09:55:45.604Z","comments":false,"path":"categories/工具/index.html","permalink":"https://okfood.vip/blog/categories/工具/index.html","excerpt":"","text":""}],"posts":[{"title":"HashMap啊","slug":"HashMap啊","date":"2019-09-03T10:25:00.000Z","updated":"2019-09-04T03:27:55.049Z","comments":true,"path":"2019/09/03/HashMap啊/","link":"","permalink":"https://okfood.vip/blog/2019/09/03/HashMap啊/","excerpt":"","text":"为什么用HashMap？ HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射 HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap是非synchronized，所以HashMap很快 HashMap可以接受null键和值，而Hashtable则不能（原因就是equlas()方法需要对象，因为HashMap是后出的API经过处理才可以） 111 222 HashMap的工作原理是什么？HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。 HashMap具体的存取过程： put键值对的方法，过程如下（JDK1.8） ①、判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容(初始化赋值) ②、根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转⑥，如果table[i]不为空，转向③ ③、判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals ④、判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤ ⑤、遍历table[i]，判断链表长度是否超过阀值( TREEIFY THRESHOLD==8)，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作，链表长度低于6，会把红黑树转回链表；遍历过程中若发现key已经存在直接覆盖value即可 ⑥、插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，就需要 resize（扩容2倍后重排） get键值对的方法，过程如下（JDK1.8） ①、指定key 通过hash函数得到key的hash值：int hash=key.hashCode() ②、调用内部方法 getNode()，得到桶号(一般为hash值对桶数求模：int index =hash % tab.length; jdk1.6版本后使用位运算替代模运算，int index=( tab.length - 1）&amp; hash ; ③、比较桶的内部元素是否与key相等，若都不相等，则没有找到；相等，则取出相等记录的value。 ④、如果得到 key 所在的桶的头结点恰好是红黑树节点，就调用红黑树节点的 getTreeNode() 方法，否则就遍历链表节点。getTreeNode 方法使通过调用树形节点的 find()方法进行查找。由于之前添加时已经保证这个树是有序的，因此查找时基本就是折半查找，效率很高。 ⑤、如果对比节点的哈希值和要查找的哈希值相等，就会判断 key 是否相等，相等就直接返回；不相等就从子树中递归查找。 有什么方法可以减少碰撞？ 扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。） 使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。 HashMap中hash函数怎么是是实现的?我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); }返回散列值也就是hashcode与其无符号右移16位后进行异或。 简单来说就是 高16bit不变，低16bit和高16bit做了一个异或(得到的hashcode转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或) (n-1) &amp; hash –&gt; 得到下标 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。 说说你对红黑树的见解？ 1、每个节点非红即黑 2、根节点总是黑色的 3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定） 4、每个叶子节点都是黑色的空节点（NIL节点） 5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 解决hash 碰撞还有那些办法？a. 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 b. 开放定址法：即发生冲突时，去寻找下一个空的哈希地址。只要哈希表足够大，总能找到空的哈希地址。 c. 再哈希法：即发生冲突时，由其他的函数再计算一次哈希值。 d. 建立公共溢出区：将哈希表分为基本表和溢出表，发生冲突时，将冲突的元素放入溢出表。 HashMap 就是使用链地址法来解决冲突的（jdk8中采用平衡树来替代链表存储冲突的元素，但hash() 方法原理相同）。当两个对象的hashcode相同时，它们的bucket位置相同，碰撞就会发生。此时，可以将 put 进来的 K- V 对象插入到链表的尾部。对于储存在同一个bucket位置的链表对象，可通过键对象的equals()方法用来找到键值对。 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作reHashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置 重新调整HashMap大小存在什么问题吗？ 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap） 为什么多线程会导致死循环，它是怎么发生的？HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。2.ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。","categories":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://okfood.vip/blog/tags/数据结构/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://okfood.vip/blog/categories/Java/"}]},{"title":"Flutter-Img-Sync使用指南","slug":"Flutter-Img-Sync使用指南","date":"2018-08-08T10:25:00.000Z","updated":"2019-09-04T07:38:55.763Z","comments":true,"path":"2018/08/08/Flutter-Img-Sync使用指南/","link":"","permalink":"https://okfood.vip/blog/2018/08/08/Flutter-Img-Sync使用指南/","excerpt":"","text":"flutter-img-synca plugin for flutter images synchronization 声明：插件灵感来自于asset_generator，致谢作者 Android Studio及IDEA可在插件商店中搜索并安装: flutter-img-sync 使用说明 vs code编辑器在扩展商店中搜索并安装： flutter-img-sync 使用说明 功能：将资产目录下的图片自动添加到pubspec.yaml的assets配置下面，并生成R文件，代码中直接引用R文件下的定义即可 如有疑问，加群讨论【AndroidRunner】 效果演示(Android Studio or IDEA) 效果演示(vs code) How To Usestep1.创建资产图片存放目录创建资产图片存放目录 如: ./assets/img step2.修改pubspec.yaml定义资产图片存放目录，如: assets: # assets-generator-begin # assets/img/* # assets-generator-endstep3.执行 FlutterImgSync (flutter-img-sync) 命令执行后，图片将会被自动放置到pubspec.yaml文件的assets变量中 ./lib/r.dart 将会被创建 在代码中导入r.dart文件，然后引用R类的变量 step4.pub get 刷新一下","categories":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://okfood.vip/blog/tags/Flutter/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://okfood.vip/blog/categories/Android/"}]}]}