<!DOCTYPE HTML>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="上帝之手-Work makes the workman">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/blog/">
    <link rel="dns-prefetch" href="https://okfood.vip/blog">
    <!--SEO-->

<meta name="keywords" content="JavaSE">


<meta name="description" content="面向对象概念是基于面向过程的一种思想。
强调的是功能行为。
将功能封装进对象，强调具备了功能的对象。
它有三个特征：封装、继承、多态。
特点面向对象就是一种常见的思想。符合人们的思考习惯。
面向...">


<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->

<title>
    
    Java面向对象之封装 |
    
    上帝之手-Work makes the workman
</title>

<link rel="alternate" href="/blog/atom.xml" title="上帝之手-Work makes the workman" type="application/atom+xml">


<link rel="icon" href="/blog/img/avatar_circle.png">

    

<link rel="stylesheet" href="/blog/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/blog/css/font-awesome.min.css?rev=4.7.0">
<link rel="stylesheet" href="/blog/css/style.css?rev=@@hash">
<link rel="stylesheet" href="/blog/assets/google-code-prettify/prettify.css">
    



    

</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    /blog/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/blog/" title='Leo'>
            <img src="/blog/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            
            <img src="/blog/img/branding.png" alt="博客-Leo" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://okfood.vip/blog">
                        上帝之手-Work makes the workman</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/blog/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/blog/categories/Java/"><i class="fa "></i>
                                Java</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/blog/categories/Android/"><i class="fa "></i>
                                Android</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/blog/categories/前端/"><i class="fa "></i>
                                前端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/blog/categories/后端/"><i class="fa "></i>
                                后端</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/blog/categories/算法/"><i class="fa "></i>
                                算法</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/blog/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Java面向对象之封装">
            
            Java面向对象之封装
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/blog/categories/Java/">Java</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/blog/tags/JavaSE/">JavaSE</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2014/04/29</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>是基于面向过程的一种思想。</p>
<p>强调的是功能行为。</p>
<p>将功能封装进对象，强调具备了功能的对象。</p>
<p>它有三个特征：封装、继承、多态。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>面向对象就是一种常见的思想。符合人们的思考习惯。</p>
<p>面向对象的出现，将复杂的问题简单化。</p>
<p>面向对象的出现，让曾经在过程中的执行者，变成了对象中的指挥者。</p>
<h2 id="对象和类的关系"><a href="#对象和类的关系" class="headerlink" title="对象和类的关系"></a>对象和类的关系</h2><p>1)、java中的类<br>把抽象出来的对象使用java表达出来，那就是类。<br>类是对具有相似性质的一类事物的抽象，类封装了一类对象的属性和方法。实例化一个类，可以获得属于该类的一个实例（即对象）。<br>比如“人”、“汽车”使用java表达出来就是一个类。</p>
<p>2)、java中的对象<br>java中的对象是在java中一个类的实例，也称实例对象。实例就是实际例子。<br>类可被认为是一个模板——你正在描述的一个对象模型，一个对象就是你每次使用的时候创建的一个类的实例的结果。</p>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><pre><code>new Person();//匿名对象。其实就是对象的简写格式。</code></pre><p>1)、当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。</p>
<p>2)、匿名对象可以作为实际参数进行传递。</p>
<p>注意：调用匿名对象的属性是没有意义。</p>
<h2 id="创建一个对象内存中做些什么事"><a href="#创建一个对象内存中做些什么事" class="headerlink" title="创建一个对象内存中做些什么事"></a>创建一个对象内存中做些什么事</h2><pre><code>Person p = new Person();</code></pre><ol>
<li><p>先将硬盘上指定位置的Person.class文件加载进内存。</p>
</li>
<li><p>执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。</p>
</li>
<li><p>在堆内存中开辟一个实体空间，分配了一个内存首地址值。new</p>
</li>
<li><p>在该实体空间中进行属性的空间分配，并进行了默认初始化。</p>
</li>
<li><p>对空间中的属性进行显示初始化。</p>
</li>
<li><p>进行实体的构造代码块初始化。</p>
</li>
<li><p>调用该实体对应的构造函数，进行构造函数初始化。（）</p>
</li>
<li><p>将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)</p>
</li>
</ol>
<h2 id="成员变量和局部变量的区别："><a href="#成员变量和局部变量的区别：" class="headerlink" title="成员变量和局部变量的区别："></a>成员变量和局部变量的区别：</h2><h3 id="定义位置"><a href="#定义位置" class="headerlink" title="定义位置"></a>定义位置</h3><p>成员变量直接定义在类中。</p>
<p>局部变量定义在方法中，参数上，语句中。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>成员变量在这个类中有效。</p>
<p>局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。</p>
<h3 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h3><p>成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。</p>
<p>局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。</p>
<p>所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p>
<p><strong>封装好处</strong>：</p>
<ol>
<li>将变化隔离。</li>
<li>便于使用。</li>
<li>提高重用性。</li>
<li>提高安全性。</li>
</ol>
<p>封装迫使用户通过方法访问数据能保护对象的数据不被误修改，还能使对象的重用变得更简单。数据隐藏通常指的就是封装，它将对象的外部界面与对象的实现区分开来，隐藏实现细节。迫使用户去使用外部界面，即使实现细节改变，还可以通过界面承担其功能而保留原样，确保调用啊的代码还继续工作，使得代码维护更简单。</p>
<p><strong>封装原则</strong>：将不需要对外提供的内容都隐藏起来；把属性都隐藏，提供公共方法对其访问。</p>
<p>private：关键字</p>
<p>A:用于修饰成员变量和成员方法。</p>
<p>B:被修饰的内容在其他类中是不可以被访问的。</p>
<p>注意：私有仅仅是封装的一种体现形式而已。</p>
<p><strong>总结</strong>：</p>
<p>开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。</p>
<p>这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX()，getXXX()对其进行操作。</p>
<p>举例：</p>
<pre><code>/*
private:私有，权限修饰符：用于修饰类中的成员（成员变量，成员函数）
私有只在本类中有效.
将age私有化以后，类以外即使建立了对象也不能直接访问
但是人应该有年龄，就需要在Person类中提供对于访问age的方式
注意:私有仅仅是封装的一种表现形式。
之所以对外提供访问方式，就是因为可以在访问方式中加入逻辑判断等语句
对访问的数据进行操作，提高代码的健壮性。
*/
class  Person{
    private int age;//定义一个私有属性

    //一个属性两个方法
    public void setAge(int a){
        if(a&gt;0 &amp;&amp; a&lt;130){
            age = a;
        }
        else{
            System.out.println(&quot;非法年龄&quot;);
        }
    }
    public int getAge(int a){
        return age;
    }

    void speak(){
        System.out.println(&quot;age=&quot;+age);
    }
}

class PersonDemo{
    public static void main(String[] args){
        Person p = new Person();
        //p.age = 24;
        p.setAge(-20);
        p.speak();
    }
}</code></pre><h1 id="构造方法、构造代码块、静态代码块、this"><a href="#构造方法、构造代码块、静态代码块、this" class="headerlink" title="构造方法、构造代码块、静态代码块、this"></a>构造方法、构造代码块、静态代码块、this</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>类有一个特殊的成员方法叫做构造方法，它的作用是创建对象并初始化成员变量，在创建对象时，会自动调用类的构造方法。</p>
<h3 id="构造方法定义规则"><a href="#构造方法定义规则" class="headerlink" title="构造方法定义规则"></a>构造方法定义规则</h3><ol>
<li><p>必须与类具有相同的名字；</p>
</li>
<li><p>没有方法的返回类型（包括没有void）；</p>
</li>
<li><p>一般都用public类型来说明；</p>
</li>
<li><p>一个类中可以以重载的形式定义多个构造方法。</p>
</li>
</ol>
<p>注意：每个类至少有一个构造方法，如果不写一个构造方法，java编程语言将提供一个默认的，该构造方法没有参数，而且方法体为空。如果已经定义了构造方法则系统不再提供默认的构造方法。</p>
<h3 id="一般方法和构造方法的区别"><a href="#一般方法和构造方法的区别" class="headerlink" title="一般方法和构造方法的区别"></a>一般方法和构造方法的区别</h3><p>一般方法：对象创建后，需要方法功能时才调用，而且可以被调用多次。</p>
<p>构造方法：对象创建时，就会调用与之对应的构造方法，给对象进行默认初始化，只调用一次。</p>
<h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><p>1).作用：给对象进行初始化。</p>
<p>对象一建立就运行，而且优先于构造方法执行。</p>
<p>2).和构造方法的区别：</p>
<ul>
<li>构造代码块是给所有对象进行统一初始化；</li>
<li>构造方法是给对应的对象初始化；</li>
</ul>
<p>注意：构造代码块中定义的是不同对象共性的初始化内容。</p>
<p>例如：</p>
<pre><code>class Person {
    private String name;
    private int age;
    //构造代码块，对象已建立就运行，优先于构造方法
    {
        System.out.println(&quot;1234&quot;);
    }
    // else code
}</code></pre><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>就是一个有静态关键字标示的一个代码块区域。定义在类中。</p>
<p>作用：可以完成类的初始化。</p>
<p>静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。</p>
<p>例如：</p>
<pre><code>static {  
    System.out.println(&quot;a&quot;);  
}  </code></pre><p>静态代码块、构造代码块、构造方法同时存在时的执行顺序：静态代码块——》构造代码块——》构造方法</p>
<p>举例：</p>
<pre><code>class Test {
    //静态代码块    类一加载就运行，仅一次
    static {
        System.out.println(&quot;我是静态代码块&quot;);
    }
    //构造代码块    对象一建立就运行，建立一次运行一次
    {
        System.out.println(&quot;我是构造代码块&quot;);
    }
    //构造函数    对象一建立就运行，建立一次运行一次
    Test() {
        System.out.println(&quot;我是构造函数&quot;);
    }
    //静态主函数
    public static void main(String[] args) {
        System.out.println(&quot;主函数来了&quot;);
        new Test();
        System.out.println(&quot;---------------------&quot;);
        new Test();
        System.out.println(&quot;---------------------&quot;);
        Test t = new Test();
    }
}
/*
打印结果如下：
我是静态代码块
主函数来了
我是构造代码块
我是构造函数
---------------------
我是构造代码块
我是构造函数
---------------------
我是构造代码块
我是构造函数
*/</code></pre><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>关键字this是用来指向当前对象或类实例的，功能说明如下：</p>
<p>1)、点取成员</p>
<p>this.day指的是调用当前对象的day字段，示例如下：</p>
<pre><code>public class Mydate{
    private int day,month,year;
    public void tomorrow(){
        this.day = this.day + 1;
        //else code
    }
}</code></pre><p>java编程语言自动将所有实例变量和方法引用与this关键字联系在一起，因此使用关键字在某些情况下是多余的，下面的代码与前面的代码等同。</p>
<pre><code>public class Mydate{
    private int day,month,year;
    public void tomorrow(){
        day = tday + 1;//在day前面没用this
        //else code
    }
}</code></pre><p>2)、区分同名变量</p>
<p>在类属性上定义的变量和方法内部定义的变量相同的时候，”this.变量”调用的是当前属性饿变量值，直接使用变量名称调用的是相对距离最近的变量的值。简单的说，哪个对象在调用this所在的函数，this就代表哪个对象。</p>
<pre><code>public class Test{
    int i = 2;
    public void t(){
        int i = 5;//跟属性的变量名称是相同的
        System.out.println(&quot;实例变量 i=&quot;+this.i);
        System.out.println(&quot;方法内部的变量 i=&quot;+i);
    }
}</code></pre><p>3)、作为方法名来初始化对象</p>
<p>也就是相当于调用本类的其他构造方法，它必须作为构造方法的第一句。</p>
<pre><code>public class Test{
    public Test(){
    this(3);//在这里调用本类的另外的构造方法
    }
    public Test(int a){
    }
    public static void main(String[] args){
        Test t = new Test();
    }
}</code></pre><p>4)、作为参数传递</p>
<p>需要在某些完全分离的类中调用一个方法，并将当前对象的一个引用作为参数传递。例如：</p>
<pre><code>Birthday bDay = new Birthday(this);</code></pre><p>综合举例：</p>
<pre><code>class Person {
    private String name;
    private int age;
    //构造代码块，对象已建立就运行，优先于构造方法
    {
        System.out.println(&quot;1234&quot;);
    }

    //1构造方法(此处默认的被修改)
    Person(){
        System.out.println(&quot;A:name=&quot;+name+&quot;,age=&quot;+age);
    }
    //2重载
    Person(String name){
        this.name = name;
    }
    //3重载
    Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    //打印姓名和年龄
    public void speak(){
        System.out.println(&quot;name=&quot;+this.name+&quot;...age=&quot;+this.age);
    }
    //设置姓名
    public void setName(String name){
        this.name = name;
    }
    //获取姓名
    public String getName(){
        return name;
    }

    /*
    需求：给人定义一个用于比较年龄是否相同的功能，是否是同龄人
    */
    public boolean compare(Person p){
        return this.age==p.age;
    }
}
class Test{
    public static void main(String[] args) {
        Person p1 = new Person();
        Person p2 = new Person(&quot;LiSi&quot;);
        Person p3 = new Person(&quot;Zhangsan&quot;,20);
        p3.speak();
        p3.setName(&quot;Wangwu&quot;);
        p3.speak();

        Person p4 = new Person(&quot;Chengliu&quot;,10);
        System.out.println(p4.getName());
        p4.speak();

        Person p5 = new Person(&quot;Lisi&quot;,30);
        Person p6 = new Person(&quot;Zhangsan&quot;,40);
        boolean b = p5.compare(p6);
        System.out.println(b);
    }
}
//打印结果如下：
/*
1234
A:name=null,age=0
1234
1234
name=Zhangsan...age=20
name=Wangwu...age=20
1234
Chengliu
name=Chengliu...age=10
1234
1234
false
*/</code></pre>
    </div>
    
    <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            <span class="reward-type">
                <img class="alipay" src="/blog/img/alipay.jpg"><b>支付宝打赏</b>
            </span>
            
            
            <span class="reward-type">
                <img class="wechat" src="/blog/img/reward-wepay.jpg"><b>微信打赏</b>
            </span>
            
        </div>
    </div>
    <p class="reward-tip">
        赞赏是不耍流氓的鼓励
    </p>
</div>
    
    <div class="post-footer">
        <div>
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/blog/2014/04/29/Java面向对象之继承/" class="pre-post btn btn-default" title='Java面向对象之继承'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            Java面向对象之继承</span>
    </a>
    
    
    <a href="/blog/2014/04/27/构造函数详解/" class="next-post btn btn-default" title='构造函数详解'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            构造函数详解</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
<p>评论系统未开启，无法评论！</p>

</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特点"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象和类的关系"><span class="toc-text">对象和类的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名对象"><span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一个对象内存中做些什么事"><span class="toc-text">创建一个对象内存中做些什么事</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量和局部变量的区别："><span class="toc-text">成员变量和局部变量的区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义位置"><span class="toc-text">定义位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存放位置"><span class="toc-text">存放位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#封装"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造方法、构造代码块、静态代码块、this"><span class="toc-text">构造方法、构造代码块、静态代码块、this</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法"><span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-1"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法定义规则"><span class="toc-text">构造方法定义规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一般方法和构造方法的区别"><span class="toc-text">一般方法和构造方法的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造代码块"><span class="toc-text">构造代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态代码块"><span class="toc-text">静态代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2014
                </span> |
                <span>
                    Powered by <a href="https://okfood.vip" class="copyright-links" target="_blank" rel="nofollow">Leo</a>
                </span>
            </div>
        </div>
    </div>
</div>


<script src="/blog/assets/tagcanvas.min.js?rev=2.9"></script>
<script>
var tagOption = {
    textColour: '#444', // 字体颜色
    outlineMethod: 'block', // 选中模式
    outlineColour: '#FFDAB9', // 选中模式的颜色
    interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
    textHeight: 13,
    outlineRadius: 3,
    freezeActive: true || '', // 选中的标签是否继续滚动
    frontSelect: true || '', // 不选标签云后部的标签
    initial: [0.1, -0.1],
    depth: 0.5,
    decel: 0.95,
    maxSpeed: 0.03,
    reverse: true || '', // 是否反向触发
    fadeIn: 500, // 进入动画时间
    wheelZoom: false || '' // 是否启用鼠标滚轮
}
TagCanvas.Start('tag-cloud-3d', '', tagOption);
</script>


<script src="/blog/assets/google-code-prettify/prettify.js?"></script>
<script src="/blog/js/app.js?rev=@@hash"></script>
</body>
</html>